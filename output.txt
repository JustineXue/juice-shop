

/* ===== FILE: ./Gruntfile.js ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

'use strict'

module.exports = function (grunt) {
  const os = grunt.option('os') || process.env.PCKG_OS_NAME || ''
  const platform = grunt.option('platform') || process.env.PCKG_CPU_ARCH || ''
  const node = grunt.option('node') || process.env.nodejs_version || process.env.PCKG_NODE_VERSION || ''

  grunt.initConfig({
    pkg: grunt.file.readJSON('package.json'),

    replace_json: {
      manifest: {
        src: 'package.json',
        changes: {
          'engines.node': (node || '<%= pkg.engines.node %>'),
          os: (os ? [os] : '<%= pkg.os %>'),
          cpu: (platform ? [platform] : '<%= pkg.cpu %>')
        }
      }
    },

    compress: {
      pckg: {
        options: {
          mode: os === 'linux' ? 'tgz' : 'zip',
          archive: 'dist/<%= pkg.name %>-<%= pkg.version %>' + (node ? ('_node' + node) : '') + (os ? ('_' + os) : '') + (platform ? ('_' + platform) : '') + (os === 'linux' ? '.tgz' : '.zip')
        },
        files: [
          {
            src: [
              '.well-known/**',
              'LICENSE',
              '*.md',
              'package.json',
              'ctf.key',
              'swagger.yml',
              'server.ts',
              'config.schema.yml',
              'build/**',
              '!build/reports/**',
              'bom.json',
              'bom.xml',
              'config/*.yml',
              'data/*.ts',
              'data/static/**',
              'data/chatbot/.gitkeep',
              'encryptionkeys/**',
              'frontend/dist/frontend/**',
              'frontend/dist/bom/**',
              'frontend/src/**/*.ts',
              'ftp/**',
              'i18n/.gitkeep',
              'lib/**',
              'models/*.ts',
              'node_modules/**',
              'routes/*.ts',
              'uploads/complaints/.gitkeep',
              'views/**'
            ],
            dest: 'juice-shop_<%= pkg.version %>/'
          }
        ]
      }
    }
  })

  grunt.registerTask('checksum', 'Create .md5 checksum files', function () {
    const fs = require('node:fs')
    const crypto = require('node:crypto')
    fs.readdirSync('dist/').forEach(file => {
      const buffer = fs.readFileSync('dist/' + file)
      const md5 = crypto.createHash('md5')
      md5.update(buffer)
      const md5Hash = md5.digest('hex')
      const md5FileName = 'dist/' + file + '.md5'
      grunt.file.write(md5FileName, md5Hash)
      grunt.log.write(`Checksum ${md5Hash} written to file ${md5FileName}.`).verbose.write('...').ok()
      grunt.log.writeln()
    })
  })

  grunt.loadNpmTasks('grunt-replace-json')
  grunt.loadNpmTasks('grunt-contrib-compress')
  grunt.registerTask('package', ['replace_json:manifest', 'compress:pckg', 'checksum'])
}


/* ===== FILE: ./frontend/.stylelintrc.js ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

module.exports = {
  extends: 'stylelint-config-sass-guidelines',
  plugins: [
    'stylelint-scss'
  ],
  rules: {
    'selector-max-id': 1,
    'selector-max-compound-selectors': 4,
    'selector-pseudo-element-no-unknown': [
      true,
      {
        'ignorePseudoElements': ['ng-deep']
      }
    ],
    'property-no-vendor-prefix': null,
    'value-no-vendor-prefix': null,
    'selector-no-vendor-prefix': null,
    'selector-no-qualifying-type': null,
    'selector-class-pattern': null
  }
}


/* ===== FILE: ./frontend/webpack.angular.js ===== */

// this file contains extras that should override angular's default configs

const { CycloneDxWebpackPlugin } = require('@cyclonedx/webpack-plugin')

module.exports = {
  plugins: [
    // @see https://www.npmjs.com/package/@cyclonedx/webpack-plugin
    new CycloneDxWebpackPlugin({
      outputLocation: '../bom', // The path is relative to webpack's overall output path,
      includeWellknown: false
    })
  ]
}


/* ===== FILE: ./frontend/.eslintrc.js ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

module.exports = {
  extends: [
    'standard-with-typescript',
    'plugin:@typescript-eslint/recommended-type-checked'
  ],
  root: true,
  parserOptions: {
    project: './src/tsconfig.*.json',
    sourceType: 'module'
  },
  ignorePatterns: [
    '.eslintrc.js',
  ],
  rules: {
    '@typescript-eslint/prefer-nullish-coalescing': 'off', // requires the `strictNullChecks` compiler option
    // FIXME warnings below this line need to be checked and fixed.
    '@typescript-eslint/strict-boolean-expressions': 'off',
    '@typescript-eslint/consistent-type-assertions': 'off',
    '@typescript-eslint/no-floating-promises': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/restrict-template-expressions': 'off',
    '@typescript-eslint/no-confusing-void-expression': 'off',
    '@typescript-eslint/require-await': 'off',
    'prefer-rest-params': 'off',
    // FIXME warnings below this line were introduced with turning on type recommendations.
    '@typescript-eslint/no-unsafe-member-access': 'off',
    '@typescript-eslint/no-unsafe-call': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    '@typescript-eslint/no-unsafe-argument': 'off',
    '@typescript-eslint/no-unsafe-return': 'off',
    '@typescript-eslint/no-unsafe-assignment': 'off',
    '@typescript-eslint/no-redundant-type-constituents': 'off',
    '@typescript-eslint/unbound-method': 'off'
  }
}


/* ===== FILE: ./frontend/src/hacking-instructor/challenges/domXss.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import {
  waitForInputToHaveValue,
  waitForElementsInnerHtmlToBe,
  waitInMs
} from '../helpers/helpers'
import { type ChallengeInstruction } from '../'

export const DomXssInstruction: ChallengeInstruction = {
  name: 'DOM XSS',
  hints: [
    {
      text:
        "For this challenge, we'll take a close look at the _Search_ field at the top of the screen.",
      fixture: '#product-search-fixture',
      unskippable: true,
      resolved: waitInMs(8000)
    },
    {
      text: "Let's start by searching for all products containing `owasp` in their name or description.",
      fixture: '#product-search-fixture',
      unskippable: true,
      resolved: waitForInputToHaveValue('#searchQuery input', 'owasp')
    },
    {
      text: 'Now hit enter.',
      fixture: '#product-search-fixture',
      unskippable: true,
      resolved: waitForElementsInnerHtmlToBe('#searchValue', 'owasp')
    },
    {
      text: 'Nice! You should now see many cool OWASP-related products.',
      fixture: '#product-search-fixture',
      resolved: waitInMs(8000)
    },
    {
      text: 'You might have noticed, that your search term is displayed above the results?',
      fixture: 'app-search-result',
      resolved: waitInMs(8000)
    },
    {
      text: 'What we will try now is a **Cross-Site Scripting (XSS)** attack, where we try to inject HTML or JavaScript code into the application.',
      fixture: 'app-search-result',
      resolved: waitInMs(15000)
    },
    {
      text: 'Change your search value into `<h1>owasp` to see if we can inject HTML.',
      fixture: '#product-search-fixture',
      unskippable: true,
      resolved: waitForInputToHaveValue('#searchQuery input', '<h1>owasp')
    },
    {
      text: 'Hit enter again.',
      fixture: '#product-search-fixture',
      unskippable: true,
      resolved: waitForElementsInnerHtmlToBe('#searchValue', '<h1>owasp</h1>') // Browsers will autocorrect the unclosed tag.
    },
    {
      text: "Hmm, this doesn't look normal, does it?",
      fixture: '.noResult',
      resolved: waitInMs(8000)
    },
    {
      text: 'If you right-click on the search term and inspect that part of the page with your browser, you will see that our `h1`-tag was _actually_ embedded into the page and is not just shown as plain text!',
      fixture: '.noResult',
      resolved: waitInMs(16000)
    },
    {
      text: "Let's now try to inject JavaScript. Type `<script>alert(xss)</script>` into the search box now.",
      fixture: '#product-search-fixture',
      unskippable: true,
      resolved: waitForInputToHaveValue('#searchQuery input', '<script>alert(xss)</script>')
    },
    {
      text: 'Hit enter again.',
      fixture: '#product-search-fixture',
      unskippable: true,
      resolved: waitForElementsInnerHtmlToBe('#searchValue', '<script>alert(xss)</script>')
    },
    {
      text: "😔 This didn't work as we hoped. If you inspect the page, you should see the `script`-tag but it is not executed for some reason.",
      fixture: '.noResult',
      resolved: waitInMs(10000)
    },
    {
      text: "Luckily there are _many_ different XSS payloads we can try. Let's try this one next: <code>&lt;iframe src=\"javascript:alert(&#96;xss&#96;)\"&gt;</code>.",
      fixture: '#product-search-fixture',
      unskippable: true,
      resolved: waitForInputToHaveValue('#searchQuery input', '<iframe src="javascript:alert(`xss`)">')
    },
    {
      text: 'Hit enter one more time. If an alert box appears, you must confirm it in order to close it.',
      fixture: '#product-search-fixture',
      unskippable: true,
      resolved: waitForElementsInnerHtmlToBe('#searchValue', '<iframe src="javascript:alert(`xss`)"></iframe>')
    },
    {
      text:
        '🎉 Congratulations! You just successfully performed an XSS attack!',
      fixture: '.noResult',
      resolved: waitInMs(8000)
    },
    {
      text:
        'More precisely, this was a **DOM XSS** attack, because your payload was handled and improperly embedded into the page by the application frontend code without even sending it to the server.',
      fixture: '.noResult',
      resolved: waitInMs(16000)
    }
  ]
}


/* ===== FILE: ./frontend/src/hacking-instructor/challenges/reflectedXss.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import {
  waitForRightUriQueryParamPair,
  waitInMs,
  waitForAngularRouteToBeVisited,
  waitForLogIn
} from '../helpers/helpers'
import { type ChallengeInstruction } from '../'

export const ReflectedXssInstruction: ChallengeInstruction = {
  name: 'Reflected XSS',
  hints: [
    {
      text:
          'To proceed with this challenge, you need to be logged in. We have detected that you are not currently logged in. Please log in to continue.',
      fixture: '#navbarAccount',
      unskippable: true,
      resolved: waitForLogIn()
    },
    {
      text:
          'Start by going to your saved addresses. You can find them by clicking on "Account" in the navigation bar, then on Orders & Payment, and then on My saved addresses.',
      fixture: 'app-navbar',
      unskippable: true,
      resolved: waitForAngularRouteToBeVisited('address/saved')
    },
    {
      text:
          'Add a new address.',
      fixture: 'app-navbar',
      unskippable: true,
      resolved: waitForAngularRouteToBeVisited('address/create')
    },
    {
      text:
          'You see a few fields to submit input. This is always a good starting point for checking potential XSS vulnerabilities. Pay attention to the pop-up once you submitted the new address.',
      fixture: 'app-navbar',
      unskippable: true,
      resolved: waitForAngularRouteToBeVisited('address/saved')
    },
    {
      text:
          'Observe how the name of the city was used in the pop-up once you submit the address. Let us try to check whether this page is vulnerable to reflected XSS. Submit a new address.',
      fixture: 'app-navbar',
      unskippable: true,
      resolved: waitForAngularRouteToBeVisited('address/create')
    },
    {
      text:
          'Use: <code>&lt;iframe src="javascript:alert(&#96;xss&#96;)"&gt;</code> as a city name.',
      fixture: 'app-navbar',
      unskippable: true,
      resolved: waitForAngularRouteToBeVisited('address/saved')
    },
    {
      text:
          'Hmmm, that did not seem to work :/. We might want to try another part of the website. Let us explore the order and payment pages. First, place an order. You can add any item to your basket and complete the purchase.',
      fixture: 'app-navbar',
      unskippable: true,
      resolved: waitForAngularRouteToBeVisited('order-completion')
    },
    {
      text:
          'Have a look at the Track Orders page.',
      fixture: 'app-navbar',
      unskippable: true,
      resolved: waitForAngularRouteToBeVisited('track-result')
    },
    {
      text:
          'In a reflected XSS attack, a payload is often included in URI or HTTP parameters. Pay attention to the id parameter in the url. Could it be vulnerable to reflected XSS? Give it a try by replacing the value of the id parameter with the payload: <code>&lt;iframe src="javascript:alert(&#96;xss&#96;)"&gt;</code>. Do not enter immediately. We will let you know once you have the correct URL in place.',
      fixture: 'app-navbar',
      resolved: waitForRightUriQueryParamPair('id', '<iframe src="javascript:alert(`xss`)">')
    },
    {
      text:
          'That looks right! Now you can hit enter to solve this challenge. If an alert box appears, confirm it to close it. Happy hacking :)',
      fixture: 'app-navbar',
      resolved: waitInMs(10000)
    }
  ]
}


/* ===== FILE: ./frontend/src/hacking-instructor/challenges/forgedFeedback.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import {
  waitInMs,
  sleep, waitForAngularRouteToBeVisited, waitForElementToGetClicked, waitForDevTools
} from '../helpers/helpers'
import { type ChallengeInstruction } from '../'

export const ForgedFeedbackInstruction: ChallengeInstruction = {
  name: 'Forged Feedback',
  hints: [
    {
      text:
          'To start this challenge, first go to the _Customer Feedback_ page.',
      fixture: 'app-navbar',
      fixtureAfter: true,
      unskippable: true,
      resolved: waitForAngularRouteToBeVisited('contact')
    },
    {
      text:
          'This challenge is about broken access controls. To pass it, you need to impersonate another user while providing feedback.',
      fixture: 'app-navbar',
      resolved: waitInMs(10000)
    },
    {
      text:
          'If you would now submit feedback, it would be posted by yourself while logged in or anonymously while logged out.',
      fixture: 'app-navbar',
      resolved: waitInMs(10000)
    },
    {
      text:
          'We will now search for any mistake the application developers might have made in setting the author of any new feedback.',
      fixture: 'app-navbar',
      resolved: waitInMs(10000)
    },
    {
      text:
          "Open the browser's _Development Tools_ and try finding anything interesting while inspecting the feedback form.",
      fixture: 'app-navbar',
      resolved: waitForDevTools()
    },
    {
      text:
          'There is more than meets the eye among the fields of the form... 😉',
      fixture: 'app-navbar',
      resolved: waitInMs(8000)
    },
    {
      text:
          "Once you found the field that shouldn't even be there, try manipulating its value to one that might represent another user!",
      fixture: 'app-navbar',
      unskippable: true,
      async resolved () {
        const userId = (document.getElementById('userId') as HTMLInputElement).value
        while (true) {
          if ((document.getElementById('userId') as HTMLInputElement).value !== userId) {
            break
          }
          await sleep(100)
        }
      }
    },
    {
      text:
          'You found and changed the invisible `userId`! Now submit the form to complete the challenge.',
      fixture: 'app-navbar',
      unskippable: true,
      resolved: waitForElementToGetClicked('#submitButton')
    },
    {
      text:
          '🎉 Congratulations, you successfully submitted a feedback as another user!',
      fixture: 'app-navbar',
      resolved: waitInMs(15000)
    }
  ]
}


/* ===== FILE: ./frontend/src/hacking-instructor/challenges/exposedCredentials.ts ===== */

/*
 * Copyright (c) 2014-2024 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import {
  waitForInputToHaveValue,
  waitForElementToGetClicked,
  waitInMs,
  waitForAngularRouteToBeVisited, waitForLogOut, waitForDevTools
} from '../helpers/helpers'
import { type ChallengeInstruction } from '../'

export const ExposedCredentialsInstruction: ChallengeInstruction = {
  name: 'Exposed credentials',
  hints: [
    {
      text:
        'To start this challenge, you will have to log out first.',
      fixture: '#navbarAccount',
      unskippable: true,
      resolved: waitForLogOut()
    },
    {
      text:
        'As the challenge suggests, let us have a look at the client-side code. Open the dev tools.',
      fixture: 'app-navbar',
      fixtureAfter: true,
      unskippable: true,
      resolved: waitForDevTools()
    },
    {
      text:
        'Go to Sources, and then inspect the main.js file. This is where all the client-side code is.',
      fixture: 'app-navbar',
      resolved: waitInMs(10000)
    },
    {
      text:
        'Now, why not search for some common words related to credentials? Maybe try password, pw, or username.',
      fixture: 'app-navbar',
      resolved: waitInMs(35000)
    },
    {
      text:
        'Once you found the hardcoded credentials, go to the login page.',
      fixture: 'app-navbar',
      resolved: waitForAngularRouteToBeVisited('login')
    },
    {
      text: 'Write the email address in the **email field**.',
      fixture: '#email',
      unskippable: true,
      resolved: waitForInputToHaveValue('#email', 'testing@juice-sh.op', { replacement: ['juice-sh.op', 'application.domain'] })
    },
    {
      text: 'Now write the password in the **password field**.',
      fixture: '#password',
      unskippable: true,
      resolved: waitForInputToHaveValue('#password', 'IamUsedForTesting')
    },
    {
      text: 'Press the _Log in_ button.',
      fixture: '#rememberMe',
      unskippable: true,
      resolved: waitForElementToGetClicked('#loginButton')
    },
    {
      text:
        '🎉 Congratulations! You have been logged in with exposed credentials!',
      fixture: 'app-navbar',
      resolved: waitInMs(5000)
    }
  ]
}


/* ===== FILE: ./frontend/src/hacking-instructor/challenges/privacyPolicy.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import {
  waitInMs, waitForAngularRouteToBeVisited, waitForElementToGetClicked, waitForLogIn
} from '../helpers/helpers'
import { type ChallengeInstruction } from '../'

export const PrivacyPolicyInstruction: ChallengeInstruction = {
  name: 'Privacy Policy',
  hints: [
    {
      text:
        'Log in with any user to begin this challenge. You can use an existing or freshly registered account.',
      fixture: 'app-navbar',
      fixtureAfter: true,
      unskippable: true,
      resolved: waitForLogIn()
    },
    {
      text:
        'Great, you are logged in! Now open the _Account_ menu.',
      fixture: '#navbarAccount',
      resolved: waitForElementToGetClicked('#navbarAccount')
    },
    {
      text:
        'Open the _Privacy & Security_ sub-menu and click _Privacy Policy_.',
      fixture: 'app-navbar',
      unskippable: true,
      resolved: waitForAngularRouteToBeVisited('privacy-security/privacy-policy')
    },
    {
      text: '🎉 That was super easy, right? This challenge is a bit of a joke actually, because nobody reads any fine print online... 🙈',
      fixture: 'app-navbar',
      resolved: waitInMs(60000)
    }
  ]
}


/* ===== FILE: ./frontend/src/hacking-instructor/challenges/loginAdmin.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import {
  waitForInputToHaveValue,
  waitForInputToNotBeEmpty,
  waitForElementToGetClicked,
  waitInMs,
  waitForAngularRouteToBeVisited, waitForLogOut
} from '../helpers/helpers'
import { type ChallengeInstruction } from '../'

export const LoginAdminInstruction: ChallengeInstruction = {
  name: 'Login Admin',
  hints: [
    {
      text:
        "To start this challenge, you'll have to log out first.",
      fixture: '#navbarAccount',
      unskippable: true,
      resolved: waitForLogOut()
    },
    {
      text:
        "Let's try if we find a way to log in with the administrator's user account. To begin, go to the _Login_ page via the _Account_ menu.",
      fixture: 'app-navbar',
      fixtureAfter: true,
      unskippable: true,
      resolved: waitForAngularRouteToBeVisited('login')
    },
    {
      text: 'To find a way around the normal login process we will try to use a **SQL Injection** (SQLi) attack.',
      fixture: '#email',
      resolved: waitInMs(8000)
    },
    {
      text: "A good starting point for simple SQL Injections is to insert quotation marks (like `\"` or `'`). These mess with the syntax of an insecurely concatenated query and might give you feedback if an endpoint is vulnerable or not.",
      fixture: '#email',
      resolved: waitInMs(15000)
    },
    {
      text: "Start with entering `'` in the **email field**.",
      fixture: '#email',
      unskippable: true,
      resolved: waitForInputToHaveValue('#email', "'")
    },
    {
      text: "Now put anything in the **password field**. It doesn't matter what.",
      fixture: '#password',
      unskippable: true,
      resolved: waitForInputToNotBeEmpty('#password')
    },
    {
      text: 'Press the _Log in_ button.',
      fixture: '#rememberMe',
      unskippable: true,
      resolved: waitForElementToGetClicked('#loginButton')
    },
    {
      text: "Nice! Do you see the red `[object Object]` error at the top? Unfortunately it isn't really telling us much about what went wrong...",
      fixture: '#rememberMe',
      resolved: waitInMs(10000)
    },
    {
      text: 'Maybe you will be able to find out more information about the error in the JavaScript console or the network tab of your browser!',
      fixture: '#rememberMe',
      resolved: waitInMs(10000)
    },
    {
      text: 'Did you spot the error message with the `SQLITE_ERROR` and the entire SQL query in the 500 response to `/login`? If not, keep the network tab open and click _Log in_ again. Then inspect the occurring response closely.',
      fixture: '#rememberMe',
      resolved: waitInMs(30000)
    },
    {
      text: "Let's try to manipulate the query a bit to make it useful. Try out typing `' OR true` into the **email field**.",
      fixture: '#email',
      unskippable: true,
      resolved: waitForInputToHaveValue('#email', "' OR true")
    },
    {
      text: 'Now click the _Log in_ button again.',
      fixture: '#rememberMe',
      unskippable: true,
      resolved: waitForElementToGetClicked('#loginButton')
    },
    {
      text: 'Mhh... The query is still invalid? Can you see why from the new error in the HTTP response?',
      fixture: '#rememberMe',
      resolved: waitInMs(8000)
    },
    {
      text: "We need to make sure that the rest of the query after our injection doesn't get executed. Any Ideas?",
      fixture: '#rememberMe',
      resolved: waitInMs(8000)
    },
    {
      text: 'You can comment out anything after your injection payload from query using comments in SQL. In SQLite databases you can use `--` for that.',
      fixture: '#rememberMe',
      resolved: waitInMs(10000)
    },
    {
      text: "So, type in `' OR true--` into the email field.",
      fixture: '#email',
      unskippable: true,
      resolved: waitForInputToHaveValue('#email', "' OR true--")
    },
    {
      text: 'Press the _Log in_ button again and sit back...',
      fixture: '#rememberMe',
      unskippable: true,
      resolved: waitForElementToGetClicked('#loginButton')
    },
    {
      text:
        'That worked, right?! To see with whose account you just logged in, open the _Account_ menu.',
      fixture: '#navbarAccount',
      unskippable: true,
      resolved: waitForElementToGetClicked('#navbarAccount')
    },
    {
      text:
        '🎉 Congratulations! You have been logged in as the **administrator** of the shop! (If you want to understand why, try to reproduce what your `\' OR true--` did _exactly_ to the query.)',
      fixture: 'app-navbar',
      resolved: waitInMs(20000)
    }
  ]
}


/* ===== FILE: ./frontend/src/hacking-instructor/challenges/passwordStrength.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import {
  waitForInputToHaveValue,
  waitForInputToNotBeEmpty,
  waitForElementToGetClicked,
  waitInMs,
  waitForAngularRouteToBeVisited, waitForLogOut
} from '../helpers/helpers'
import { type ChallengeInstruction } from '../'

export const PasswordStrengthInstruction: ChallengeInstruction = {
  name: 'Password Strength',
  hints: [
    {
      text:
        "To start this challenge, you'll have to log out first.",
      fixture: '#navbarAccount',
      unskippable: true,
      resolved: waitForLogOut()
    },
    {
      text:
        "In this challenge we'll try to log into the administrator's user account using his original credentials.",
      fixture: 'app-navbar',
      resolved: waitInMs(7000)
    },
    {
      text:
        "If you don't know it already, you must first find out the admin's email address. The user feedback and product reviews are good places to look into. When you have it, go to the _Login_ page.",
      fixture: 'app-navbar',
      fixtureAfter: true,
      unskippable: true,
      resolved: waitForAngularRouteToBeVisited('login')
    },
    {
      text: "Enter the admin's email address into the **email field**.",
      fixture: '#email',
      unskippable: true,
      resolved: waitForInputToHaveValue('#email', 'admin@juice-sh.op') // TODO Use domain from config instead
    },
    {
      text: 'Now for the password. Lucky for us, the admin chose a really, really, **really** stupid one. Just try any that comes to your mind!',
      fixture: '#password',
      unskippable: true,
      resolved: waitForInputToNotBeEmpty('#password')
    },
    {
      text: "🤦‍♂️ Nah, that was wrong! Keep trying! I'll tell you when you're one the right track.",
      fixture: '#password',
      unskippable: true,
      resolved: waitForInputToHaveValue('#password', 'admin')
    },
    {
      text: 'Okay, you are one the right track, but this would have been the worst password in the world for an admin. He spiced it up a little bit with some extra non-letter characters. Keep trying!',
      fixture: '#password',
      unskippable: true,
      resolved: waitForInputToHaveValue('#password', 'admin1')
    },
    {
      text: "🔥 Yes, it's getting warmer! Try adding some more numbers maybe?",
      fixture: '#password',
      unskippable: true,
      resolved: waitForInputToHaveValue('#password', 'admin12')
    },
    {
      text: "🧯 It's getting hot! Just one more digit...",
      fixture: '#password',
      unskippable: true,
      resolved: waitForInputToHaveValue('#password', 'admin123')
    },
    {
      text: 'Okay, now press the _Log in_ button.',
      fixture: '#rememberMe',
      unskippable: true,
      resolved: waitForElementToGetClicked('#loginButton')
    },
    {
      text:
        '🎉 Congratulations! You have been logged in as the **administrator** of the shop thanks to his very ill chosen password!',
      fixture: 'app-navbar',
      resolved: waitInMs(20000)
    }
  ]
}


/* ===== FILE: ./frontend/src/hacking-instructor/challenges/viewBasket.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import {
  waitInMs,
  sleep, waitForAngularRouteToBeVisited, waitForLogIn, waitForDevTools
} from '../helpers/helpers'
import { type ChallengeInstruction } from '../'

export const ViewBasketInstruction: ChallengeInstruction = {
  name: 'View Basket',
  hints: [
    {
      text:
          "This challenge is about **Horizontal Privilege Escalation**, meaning you are supposed to access data that does not belong to your own account but to another user's.",
      fixture: 'app-navbar',
      resolved: waitInMs(18000)
    },
    {
      text:
          "To start this challenge, you'll have to log in first.",
      fixture: 'app-navbar',
      unskippable: true,
      resolved: waitForLogIn()
    },
    {
      text:
          "First, go to the _Your Basket_ page to view your own shopping basket. It's likely to be empty, if you didn't add anything yet.",
      fixture: 'app-navbar',
      unskippable: true,
      resolved: waitForAngularRouteToBeVisited('basket')
    },
    {
      text:
          "To pass this challenge, you will need to peek into another user's basket while remaining logged in with your own account.",
      fixture: 'app-navbar',
      resolved: waitInMs(8000)
    },
    {
      text:
          'If the application stores a reference to the basket somewhere in the browser, that might be a possible attack vector.',
      fixture: 'app-navbar',
      resolved: waitInMs(12000)
    },
    {
      text:
          "Open the browser's _Development Tools_ and locate the _Session Storage_ tab. Similar to 🍪s, it can be used to store data in key/value pairs for each website.",
      fixture: 'app-navbar',
      resolved: waitForDevTools()
    },
    {
      text:
          'Look over the names of the used session keys. Do you see something that might be related to the shopping basket? Try setting it to a different value! ✍️',
      fixture: 'app-navbar',
      unskippable: true,
      async resolved () {
        const bid = sessionStorage.getItem('bid')
        while (true) {
          if (sessionStorage.getItem('bid') !== bid) {
            break
          }
          await sleep(100)
        }
      }
    },
    {
      text:
        'Great, you have changed the `bid` value which might be some ID for the shopping basket!',
      fixture: 'app-navbar',
      resolved: waitInMs(8000)
    },
    {
      text:
          'Now, go to any other screen and then back to _Your Basket_. If nothing happens you might have set an invalid or non-existing `bid`. Try another in that case.',
      fixture: 'app-navbar',
      fixtureAfter: true,
      unskippable: true,
      async resolved () {
        const total = sessionStorage.getItem('itemTotal')
        while (true) {
          if (sessionStorage.getItem('itemTotal') !== total) {
            break
          }
          await sleep(100)
        }
      }
    },
    {
      text:
          "🎉 Congratulations! You are now viewing another user's shopping basket!",
      fixture: 'app-basket',
      resolved: waitInMs(15000)
    }
  ]
}


/* ===== FILE: ./frontend/src/hacking-instructor/challenges/loginJim.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import {
  waitForInputToHaveValue,
  waitForElementToGetClicked,
  waitInMs,
  waitForAngularRouteToBeVisited, waitForLogOut, waitForInputToNotHaveValueAndNotBeEmpty
} from '../helpers/helpers'
import { type ChallengeInstruction } from '../'

export const LoginJimInstruction: ChallengeInstruction = {
  name: 'Login Jim',
  hints: [
    {
      text:
        "To start this challenge, you'll have to log out first.",
      fixture: '#navbarAccount',
      unskippable: true,
      resolved: waitForLogOut() // TODO Add check if "Login Admin" is solved and if not recommend doing that first
    },
    {
      text:
        "Let's try if we find a way to log in with Jim's user account. To begin, go to the _Login_ page via the _Account_ menu.",
      fixture: 'app-navbar',
      fixtureAfter: true,
      unskippable: true,
      resolved: waitForAngularRouteToBeVisited('login')
    },
    {
      text:
        "As you would expect you need to supply Jim's email address and password to log in regularly. But you might have neither at the moment.",
      fixture: 'app-navbar',
      resolved: waitInMs(15000)
    },
    {
      text:
        'If we had at least the email address, we could then try a **SQL Injection** (SQLi) attack to avoid having to supply a password.',
      fixture: 'app-navbar',
      resolved: waitInMs(15000)
    },
    {
      text:
        "So, let's go find out Jim's email! Luckily the shop is very bad with privacy and leaks emails in different places, for instance in the product reviews.",
      fixture: 'app-navbar',
      resolved: waitInMs(15000)
    },
    {
      text:
        'Go back to the product list and click on some to open their details dialog which also hold the user reviews.',
      fixture: '.fill-remaining-space',
      resolved: waitForAngularRouteToBeVisited('search')
    },
    {
      text:
        'Once you found a user review by Jim and learned his email, go to the _Login_ screen.',
      fixture: '.fill-remaining-space',
      unskippable: true,
      resolved: waitForAngularRouteToBeVisited('login')
    },
    {
      text: "Supply Jim's email address in the **email field**.",
      fixture: '#email',
      unskippable: true,
      resolved: waitForInputToHaveValue('#email', 'jim@juice-sh.op', { replacement: ['juice-sh.op', 'application.domain'] })
    },
    {
      text: "Now put anything in the **password field**. Let's assume we don't know it yet, even if you happen to already do.",
      fixture: '#password',
      unskippable: true,
      resolved: waitForInputToNotHaveValueAndNotBeEmpty('#password', 'ncc-1701')
    },
    {
      text: 'Press the _Log in_ button.',
      fixture: '#rememberMe',
      unskippable: true,
      resolved: waitForElementToGetClicked('#loginButton')
    },
    {
      text: "This didn't work, but did you honestly expect it to? We need to craft an SQLi attack first!",
      fixture: '#rememberMe',
      resolved: waitInMs(10000)
    },
    {
      text: "You can comment out the entire password check clause of the DB query by adding `'--` to Jim's email address!",
      fixture: '#email',
      unskippable: true,
      resolved: waitForInputToHaveValue('#email', "jim@juice-sh.op'--", { replacement: ['juice-sh.op', 'application.domain'] })
    },
    {
      text: 'Now click the _Log in_ button again.',
      fixture: '#rememberMe',
      unskippable: true,
      resolved: waitForElementToGetClicked('#loginButton')
    },
    {
      text:
        '🎉 Congratulations! You have been logged in as Jim!',
      fixture: 'app-navbar',
      resolved: waitInMs(5000)
    }
  ]
}


/* ===== FILE: ./frontend/src/hacking-instructor/challenges/adminSection.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import {
  waitInMs,
  waitForElementToGetClicked,
  waitForAngularRouteToBeVisited,
  waitForAdminLogIn
} from '../helpers/helpers'
import { type ChallengeInstruction } from '../'

export const AdminSectionInstruction: ChallengeInstruction = {
  name: 'Admin Section',
  hints: [
    {
      text: 'For this challenge, you need to be logged in as an admin. If you have not done so yet, solve the admin login challenge first. Otherwise, log in as an admin.',
      fixture: '.fill-remaining-space',
      unskippable: false,
      resolved: waitForAdminLogIn()
    },
    {
      text: 'A good way to start looking for an admin section is by understanding what technologies a website is built on. One way to do this is by clicking through the website and being attentive to hints. Start by opening the side menu (the hamburger icon in the top left corner).',
      fixture: '.fill-remaining-space',
      unskippable: true,
      resolved: waitForElementToGetClicked('button[aria-label="Open Sidenav"]')
    },
    {
      text: 'Inspect those icons. Can you guess what they are?',
      fixture: '.appVersion',
      fixtureAfter: true,
      unskippable: true,
      resolved: waitInMs(8000)
    },
    {
      text: 'This is the tech stack of the website. You see HTML, JavaScript, and more.',
      fixture: '.appVersion',
      fixtureAfter: true,
      unskippable: true,
      resolved: waitInMs(8000)
    },
    {
      text: 'You could search for common web technologies and see if you recognize any logos.',
      fixture: '.appVersion',
      fixtureAfter: true,
      unskippable: true,
      resolved: waitInMs(8000)
    },
    {
      text: 'And you will find that the first logo is Angular.',
      fixture: '.appVersion',
      fixtureAfter: true,
      unskippable: true,
      resolved: waitInMs(8000)
    },
    {
      text: 'Close the side menu again.',
      fixture: '.appVersion',
      fixtureAfter: true,
      unskippable: true,
      resolved: waitInMs(4000)
    },
    {
      text: 'These kinds of hints can tell you a lot. For example, if we found a WordPress site, a common admin path to look for would be /wp-admin.',
      fixture: 'app-navbar',
      fixtureAfter: true,
      unskippable: true,
      resolved: waitInMs(10000)
    },
    {
      text: 'In Angular, each route maps a URL path to a component. To find the admin section, try navigating to the /admin path and see what happens.',
      fixture: 'app-navbar',
      fixtureAfter: true,
      unskippable: true,
      resolved: waitForAngularRouteToBeVisited('admin')
    },
    {
      text: 'Mmmmh, this did not work as expected. Let us try another one. Maybe /administration will work?',
      fixture: 'app-navbar',
      fixtureAfter: true,
      unskippable: true,
      resolved: waitForAngularRouteToBeVisited('administration')
    },
    {
      text: '🎉 Congratulations! You successfully accessed the admin section!',
      fixture: 'app-navbar',
      resolved: waitInMs(6000)
    },
    {
      text: 'Most often, it is harder to find the tech stack. Instead of guessing common admin paths, another approach would be to use the developer tools. In this case, you would notice many "ng" references, which hint towards Angular. By understanding routes and paths in Angular, you could open the debugger, inspect the JavaScript files for paths, and find /administration.',
      fixture: 'app-navbar',
      resolved: waitInMs(16000)
    },
    {
      text: 'Always keep your eyes open when inspecting a website. Once you have identified the technologies used, leverage them to your advantage, and do not forget to read the docs!',
      fixture: 'app-navbar',
      resolved: waitInMs(10000)
    },
    {
      text: 'If you like, try to access the admin section without admin credentials. What do you think would happen? Happy hacking :)',
      fixture: 'app-navbar',
      resolved: waitInMs(8000)
    }
  ]
}


/* ===== FILE: ./frontend/src/hacking-instructor/challenges/codingChallenges.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import {
  waitInMs, waitForElementToGetClicked, waitForAngularRouteToBeVisited
} from '../helpers/helpers'
import { type ChallengeInstruction } from '../'

export const CodingChallengesInstruction: ChallengeInstruction = {
  name: 'Coding Challenges',
  hints: [
    {
      text:
        'To do the tutorial on _Coding Challenges_, you have to find and visit the _Score Board_ first. Once there, you have to click the tutorial button for the _Score Board_ challenge to proceed.',
      fixture: 'app-navbar',
      fixtureAfter: true,
      unskippable: true,
      resolved: waitForAngularRouteToBeVisited('score-board') // FIXME The tutorial does not progress automatically. Workaround ^^^^^^^^^^^^^^^^ instruction above should be removed when fixed.
    },
    {
      text:
        'Many Juice Shop hacking challenges come with an associated _Coding Challenge_ which will teach you more about the underlying vulnerability on source code level.',
      fixture: '#Score\\ Board\\.solved',
      resolved: waitInMs(15000)
    },
    {
      text:
        'You can launch a Coding Challenge via the `<>`-button. Click the one for the _Score Board_ challenge now.',
      fixture: '#codingChallengeTutorialButton',
      unskippable: true,
      resolved: waitForElementToGetClicked('#Score\\ Board\\.codingChallengeButton')
    },
    {
      text:
        'All Coding Challenges take place in a modal dialog like this. They consist of two parts, one for finding and one for fixing the vulnerability in the code.',
      fixture: '#code-snippet',
      resolved: waitInMs(15000)
    },
    {
      text:
        'The code snippet below shows a part of the actual application source code retrieved in real-time.',
      fixture: '#code-snippet',
      resolved: waitInMs(10000)
    },
    {
      text:
        'You will always get a snippet that is involved in the security vulnerability or flaw behind the corresponding hacking challenge. In this case, you see the routing code that exposes all dialogs, including the supposedly "well-hidden" Score Board.',
      fixture: '#code-snippet',
      resolved: waitInMs(20000)
    },
    {
      text:
        'For the "Find It" part of this coding challenge, tick the 🔲 on all lines of code that you think are responsible for exposing the Score Board. When done, click the _Submit_ button.',
      fixture: '#code-snippet',
      fixtureAfter: true,
      unskippable: true,
      resolved: waitForElementToGetClicked('#line114')
    },
    {
      text:
        'That\'s the one! Click the _Submit_ button proceed.',
      fixture: '#code-snippet',
      fixtureAfter: true,
      unskippable: true,
      resolved: waitForElementToGetClicked('#findItSubmitButton')
    },
    {
      text:
        '🎊! You made it half-way through! In phase two you are now presented with several fix options. You must select the one which you think is the **best possible** fix for the security vulnerability.',
      fixture: '#code-snippet',
      resolved: waitInMs(10000)
    },
    {
      text:
        'This coding challenge is a bit "special", because the Score Board is crucial for progress tracking and acts as a hub for the other challenges. Keep that in mind when picking the _Correct Fix_ from the options _Fix 1_, _2_ and _3_.',
      fixture: '#code-snippet',
      fixtureAfter: true,
      unskippable: true,
      resolved: waitForElementToGetClicked('#fixItSubmitButton')
    },
    {
      text:
        'If you did\'nt get the answer right, just try again until the 🎊-cannon fires. Then click _Close_ to end the coding challenge and return to the Score Board.',
      fixture: '#code-snippet',
      fixtureAfter: true,
      unskippable: true,
      resolved: waitForElementToGetClicked('#fixItCloseButton')
    }
  ]
}


/* ===== FILE: ./frontend/src/hacking-instructor/challenges/scoreBoard.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import {
  waitInMs, waitForAngularRouteToBeVisited, waitForDevTools
} from '../helpers/helpers'
import { type ChallengeInstruction } from '../'

export const ScoreBoardInstruction: ChallengeInstruction = {
  name: 'Score Board',
  hints: [
    {
      text:
        'This application is riddled with security vulnerabilities. Your progress exploiting these is tracked on a _Score Board_.',
      fixture: 'app-navbar',
      unskippable: true,
      resolved: waitInMs(10000)
    },
    {
      text:
        "You won't find a link to it in the navigation or side bar, though. Finding the _Score Board_ is in itself actually one of the hacking challenges.",
      fixture: 'app-navbar',
      resolved: waitInMs(12000)
    },
    {
      text:
        'You could just start guessing the URL of the _Score Board_ or comb through the client-side JavaScript code for useful information.',
      fixture: 'app-navbar',
      resolved: waitInMs(12000)
    },
    {
      text:
        'You find the JavaScript code in the DevTools of your browser that will open with `F12`.',
      fixture: 'app-navbar',
      resolved: waitForDevTools()
    },
    {
      text:
        "Look through the client-side JavaScript in the _Sources_ tab for clues. Or just start URL guessing. It's up to you!",
      fixture: 'app-navbar',
      unskippable: true,
      resolved: waitForAngularRouteToBeVisited('score-board')
    },
    {
      text: '🎉 Congratulations! You found the _Score Board_! Good luck and happy hacking!',
      fixture: 'app-score-board',
      resolved: waitInMs(60000)
    }
  ]
}


/* ===== FILE: ./frontend/src/hacking-instructor/challenges/loginBender.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import {
  waitForInputToHaveValue,
  waitForElementToGetClicked,
  waitInMs,
  waitForAngularRouteToBeVisited, waitForLogOut, waitForInputToNotHaveValueAndNotBeEmpty
} from '../helpers/helpers'
import { type ChallengeInstruction } from '../'

export const LoginBenderInstruction: ChallengeInstruction = {
  name: 'Login Bender',
  hints: [
    {
      text:
        "To start this challenge, you'll have to log out first.",
      fixture: '#navbarAccount',
      unskippable: true,
      resolved: waitForLogOut() // TODO Add check if "Login Admin" is solved and if not recommend doing that first
    },
    {
      text:
        "Let's try if we find a way to log in with Bender's user account. To begin, go to the _Login_ page via the _Account_ menu.",
      fixture: 'app-navbar',
      fixtureAfter: true,
      unskippable: true,
      resolved: waitForAngularRouteToBeVisited('login')
    },
    {
      text:
        "As you would expect you need to supply Bender's email address and password to log in regularly. But you might have neither at the moment.",
      fixture: 'app-navbar',
      resolved: waitInMs(15000)
    },
    {
      text:
        'If we had at least the email address, we could then try a **SQL Injection** (SQLi) attack to avoid having to supply a password.',
      fixture: 'app-navbar',
      resolved: waitInMs(15000)
    },
    {
      text:
        "So, let's go find out Bender's email! Luckily the shop is very bad with privacy and leaks emails in different places, for instance in the user feedback.",
      fixture: 'app-navbar',
      resolved: waitInMs(15000)
    },
    {
      text:
        'Go to the _About Us_ page where user feedback is displayed among other things.',
      fixture: 'app-navbar',
      fixtureAfter: true,
      resolved: waitForAngularRouteToBeVisited('about')
    },
    {
      text:
        'Once you found an entry by Bender in the feedback carousel leaking enough of his email to deduce the rest, go to the _Login_ screen.',
      fixture: 'app-about',
      unskippable: true,
      resolved: waitForAngularRouteToBeVisited('login')
    },
    {
      text: "Supply Bender's email address in the **email field**.",
      fixture: '#email',
      unskippable: true,
      resolved: waitForInputToHaveValue('#email', 'bender@juice-sh.op', { replacement: ['juice-sh.op', 'application.domain'] })
    },
    {
      text: "Now put anything in the **password field**. Let's assume we don't know it yet, even if you happen to already do.",
      fixture: '#password',
      unskippable: true,
      resolved: waitForInputToNotHaveValueAndNotBeEmpty('#password', 'OhG0dPlease1nsertLiquor!')
    },
    {
      text: 'Press the _Log in_ button.',
      fixture: '#rememberMe',
      unskippable: true,
      resolved: waitForElementToGetClicked('#loginButton')
    },
    {
      text: "This didn't work, but did you honestly expect it to? We need to craft an SQLi attack first!",
      fixture: '#rememberMe',
      resolved: waitInMs(10000)
    },
    {
      text: "You can comment out the entire password check clause of the DB query by adding `'--` to Bender's email address!",
      fixture: '#email',
      unskippable: true,
      resolved: waitForInputToHaveValue('#email', "bender@juice-sh.op'--", { replacement: ['juice-sh.op', 'application.domain'] })
    },
    {
      text: 'Now click the _Log in_ button again.',
      fixture: '#rememberMe',
      unskippable: true,
      resolved: waitForElementToGetClicked('#loginButton')
    },
    {
      text:
        '🎉 Congratulations! You have been logged in as Bender!',
      fixture: 'app-navbar',
      resolved: waitInMs(5000)
    }
  ]
}


/* ===== FILE: ./frontend/src/hacking-instructor/challenges/bonusPayload.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import {
  waitForInputToHaveValue,
  waitForElementsInnerHtmlToBe,
  waitInMs
} from '../helpers/helpers'
import { type ChallengeInstruction } from '../'

export const BonusPayloadInstruction: ChallengeInstruction = {
  name: 'Bonus Payload',
  hints: [
    {
      text:
        'Assuming you did the **DOM XSS** tutorial already, this one just uses a funnier payload on the _Search_ field.',
      fixture: '#product-search-fixture',
      unskippable: true,
      resolved: waitInMs(10000) // TODO Add check if "DOM XSS" is solved and if not recommend doing that first
    },
    {
      text: 'Enter or paste this payload into the _Search_ field: <code>&lt;iframe width=&quot;100%&quot; height=&quot;166&quot; scrolling=&quot;no&quot; frameborder=&quot;no&quot; allow=&quot;autoplay&quot; src=&quot;https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/771984076&amp;color=%23ff5500&amp;auto&lowbar;play=true&amp;hide&lowbar;related=false&amp;show&lowbar;comments=true&amp;show&lowbar;user=true&amp;show&lowbar;reposts=false&amp;show&lowbar;teaser=true&quot;&gt;&lt;/iframe&gt;</code>.',
      fixture: '#product-search-fixture',
      unskippable: true,
      resolved: waitForInputToHaveValue('#searchQuery input', '<iframe width="100%" height="166" scrolling="no" frameborder="no" allow="autoplay" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/771984076&color=%23ff5500&auto_play=true&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true"></iframe>')
    },
    {
      text: 'Make sure your speaker volume is cranked up. Then hit enter.',
      fixture: '#product-search-fixture',
      unskippable: true,
      resolved: waitForElementsInnerHtmlToBe('#searchValue', '<iframe width="100%" height="166" scrolling="no" frameborder="no" allow="autoplay" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/771984076&color=%23ff5500&auto_play=true&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true"></iframe>')
    },
    {
      text:
        '🎉 Congratulations and enjoy the music!',
      fixture: '.noResult',
      resolved: waitInMs(5000)
    }
  ]
}


/* ===== FILE: ./frontend/src/hacking-instructor/tutorialUnavailable.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import {
  waitInMs
} from './helpers/helpers'
import { type ChallengeInstruction } from './'

export const TutorialUnavailableInstruction: ChallengeInstruction = {
  name: null,
  hints: [
    {
      text:
        '😓 Sorry, this hacking challenge does not have a step-by-step tutorial (yet) ... 🧭 Can you find your own way to solve it?',
      fixture: 'app-navbar',
      resolved: waitInMs(15000)
    },
    {
      text:
        '✍️ Do you want to contribute a tutorial for this challenge? [Check out our documentation](https://pwning.owasp-juice.shop/companion-guide/latest/part5/tutorials.html) to learn how! 🏫',
      fixture: 'app-navbar',
      resolved: waitInMs(15000)
    },
    {
      text:
        'And now: 👾 **GLHF** with this challenge!',
      fixture: 'app-navbar',
      resolved: waitInMs(10000)
    }
  ]
}


/* ===== FILE: ./frontend/src/hacking-instructor/index.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import snarkdown from 'snarkdown'

import { LoginAdminInstruction } from './challenges/loginAdmin'
import { DomXssInstruction } from './challenges/domXss'
import { ScoreBoardInstruction } from './challenges/scoreBoard'
import { PrivacyPolicyInstruction } from './challenges/privacyPolicy'
import { LoginJimInstruction } from './challenges/loginJim'
import { ViewBasketInstruction } from './challenges/viewBasket'
import { ForgedFeedbackInstruction } from './challenges/forgedFeedback'
import { PasswordStrengthInstruction } from './challenges/passwordStrength'
import { BonusPayloadInstruction } from './challenges/bonusPayload'
import { LoginBenderInstruction } from './challenges/loginBender'
import { TutorialUnavailableInstruction } from './tutorialUnavailable'
import { CodingChallengesInstruction } from './challenges/codingChallenges'
import { AdminSectionInstruction } from './challenges/adminSection'
import { ReflectedXssInstruction } from './challenges/reflectedXss'
import { ExposedCredentialsInstruction } from './challenges/exposedCredentials'

const challengeInstructions: ChallengeInstruction[] = [
  ScoreBoardInstruction,
  LoginAdminInstruction,
  LoginJimInstruction,
  DomXssInstruction,
  PrivacyPolicyInstruction,
  ViewBasketInstruction,
  ForgedFeedbackInstruction,
  PasswordStrengthInstruction,
  BonusPayloadInstruction,
  LoginBenderInstruction,
  CodingChallengesInstruction,
  AdminSectionInstruction,
  ReflectedXssInstruction,
  ExposedCredentialsInstruction
]

export interface ChallengeInstruction {
  name: string
  hints: ChallengeHint[]
}

export interface ChallengeHint {
  /**
   * Text in the hint box
   * Can be formatted using markdown
   */
  text: string
  /**
   * Query Selector String of the Element the hint should be displayed next to.
   */
  fixture: string
  /**
   * Set to true if the hint should be displayed after the target
   * Defaults to false (hint displayed before target)
   */
  fixtureAfter?: boolean
  /**
   * Set to true if the hint should not be able to be skipped by clicking on it.
   * Defaults to false
   */
  unskippable?: boolean
  /**
   * Function declaring the condition under which the tutorial will continue.
   */
  resolved: () => Promise<void>
}

function createElement (tag: string, styles: Record<string, string>, attributes: Record<string, string> = {}): HTMLElement {
  const element = document.createElement(tag)
  Object.assign(element.style, styles)
  for (const [key, value] of Object.entries(attributes)) {
    element.setAttribute(key, value)
  }
  return element
}

function loadHint (hint: ChallengeHint): HTMLElement {
  const target = document.querySelector(hint.fixture)

  if (!target) {
    return null as unknown as HTMLElement
  }

  const wrapper = createElement('div', { position: 'absolute' })

  const elemStyles = {
    position: 'absolute',
    zIndex: '20000',
    backgroundColor: 'rgba(50, 115, 220, 0.9)',
    maxWidth: '400px',
    minWidth: hint.text.length > 100 ? '350px' : '250px',
    padding: '16px',
    borderRadius: '8px',
    whiteSpace: 'initial',
    lineHeight: '1.3',
    top: '24px',
    fontFamily: 'Roboto,Helvetica Neue,sans-serif',
    fontSize: '14px',
    display: 'flex',
    alignItems: 'center',
    cursor: hint.unskippable ? 'default' : 'pointer',
    animation: 'flash 0.2s'
  }

  const elem = createElement('div', elemStyles, { id: 'hacking-instructor', title: hint.unskippable ? '' : 'Double-click to skip' })

  const pictureStyles = {
    minWidth: '64px',
    minHeight: '64px',
    width: '64px',
    height: '64px',
    marginRight: '8px'
  }

  const picture = createElement('img', pictureStyles, { src: '/assets/public/images/hackingInstructor.png' })

  const textBox = createElement('span', { flexGrow: '2' })
  textBox.innerHTML = snarkdown(hint.text)

  const cancelButtonStyles = {
    textDecoration: 'none',
    backgroundColor: 'transparent',
    border: 'none',
    color: 'white',
    fontSize: 'large',
    position: 'relative',
    zIndex: '20001',
    top: '32px',
    left: '5px',
    cursor: 'pointer'
  }

  const cancelButton = createElement('button', cancelButtonStyles, { id: 'cancelButton', title: 'Cancel the tutorial' })
  cancelButton.innerHTML = '<div>&times;</div>'

  elem.appendChild(picture)
  elem.appendChild(textBox)

  const relAnchor = createElement('div', { position: 'relative', display: 'inline' })
  relAnchor.appendChild(elem)
  relAnchor.appendChild(cancelButton)

  wrapper.appendChild(relAnchor)

  if (hint.fixtureAfter) {
    target.parentElement.insertBefore(wrapper, target.nextSibling)
  } else {
    target.parentElement.insertBefore(wrapper, target)
  }

  return wrapper
}

async function waitForDoubleClick (element: HTMLElement) {
  return await new Promise((resolve) => {
    element.addEventListener('dblclick', resolve)
  })
}

async function waitForCancel (element: HTMLElement) {
  return await new Promise((resolve) => {
    element.addEventListener('click', () => {
      resolve('break')
    })
  })
}

export function hasInstructions (challengeName: string): boolean {
  return challengeInstructions.find(({ name }) => name === challengeName) !== undefined
}

function isElementInViewport (el: HTMLElement): boolean {
  const rect = el.getBoundingClientRect()
  return (
    rect.top >= 0 &&
    rect.left >= 0 &&
    rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
    rect.right <= (window.innerWidth || document.documentElement.clientWidth)
  )
}

export async function startHackingInstructorFor (challengeName: string): Promise<void> {
  const challengeInstruction = challengeInstructions.find(({ name }) => name === challengeName) ?? TutorialUnavailableInstruction

  for (const hint of challengeInstruction.hints) {
    const element = loadHint(hint)
    if (!element) {
      console.warn(`Could not find Element with fixture "${hint.fixture}"`)
      continue
    }

    if (!isElementInViewport(element)) {
      element.scrollIntoView()
    }

    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
    const continueConditions: Array<Promise<void | unknown>> = [
      hint.resolved()
    ]

    if (!hint.unskippable) {
      continueConditions.push(waitForDoubleClick(element))
    }
    continueConditions.push(waitForCancel(document.getElementById('cancelButton')))

    const command = await Promise.race(continueConditions)
    if (command === 'break') {
      element.remove()
      break
    }

    element.remove()
  }
}


/* ===== FILE: ./frontend/src/hacking-instructor/helpers/helpers.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import jwtDecode from 'jwt-decode'

let config
const playbackDelays = {
  faster: 0.5,
  fast: 0.75,
  normal: 1.0,
  slow: 1.25,
  slower: 1.5
}

export async function sleep (timeInMs: number): Promise<void> {
  await new Promise((resolve) => {
    setTimeout(resolve, timeInMs)
  })
}

export function waitForInputToHaveValue (inputSelector: string, value: string, options: any = { ignoreCase: true, replacement: [] }) {
  return async () => {
    const inputElement: HTMLInputElement = document.querySelector(
      inputSelector
    )

    if (options.replacement?.length === 2) {
      if (!config) {
        const res = await fetch('/rest/admin/application-configuration')
        const json = await res.json()
        config = json.config
      }
      const propertyChain = options.replacement[1].split('.')
      let replacementValue = config
      for (const property of propertyChain) {
        replacementValue = replacementValue[property]
      }
      value = value.replace(options.replacement[0], replacementValue)
    }

    while (true) {
      if (options.ignoreCase && inputElement.value.toLowerCase() === value.toLowerCase()) {
        break
      } else if (!options.ignoreCase && inputElement.value === value) {
        break
      }
      await sleep(100)
    }
  }
}

export function waitForInputToNotHaveValue (inputSelector: string, value: string, options = { ignoreCase: true }) {
  return async () => {
    const inputElement: HTMLInputElement = document.querySelector(
      inputSelector
    )

    while (true) {
      if (options.ignoreCase && inputElement.value.toLowerCase() !== value.toLowerCase()) {
        break
      } else if (!options.ignoreCase && inputElement.value !== value) {
        break
      }
      await sleep(100)
    }
  }
}

export function waitForInputToNotHaveValueAndNotBeEmpty (inputSelector: string, value: string, options = { ignoreCase: true }) {
  return async () => {
    const inputElement: HTMLInputElement = document.querySelector(
      inputSelector
    )

    while (true) {
      if (inputElement.value !== '') {
        if (options.ignoreCase && inputElement.value.toLowerCase() !== value.toLowerCase()) {
          break
        } else if (!options.ignoreCase && inputElement.value !== value) {
          break
        }
      }
      await sleep(100)
    }
  }
}

export function waitForInputToNotBeEmpty (inputSelector: string) {
  return async () => {
    const inputElement: HTMLInputElement = document.querySelector(
      inputSelector
    )

    while (true) {
      if (inputElement.value && inputElement.value !== '') {
        break
      }
      await sleep(100)
    }
  }
}

export function waitForElementToGetClicked (elementSelector: string) {
  return async () => {
    const element = document.querySelector(
      elementSelector
    )
    if (!element) {
      console.warn(`Could not find Element with selector "${elementSelector}"`)
    }

    await new Promise<void>((resolve) => {
      element.addEventListener('click', () => { resolve() })
    })
  }
}

export function waitForElementsInnerHtmlToBe (elementSelector: string, value: string) {
  return async () => {
    while (true) {
      const element = document.querySelector(
        elementSelector
      )

      if (element && element.innerHTML === value) {
        break
      }
      await sleep(100)
    }
  }
}

export function waitInMs (timeInMs: number) {
  return async () => {
    if (!config) {
      const res = await fetch('/rest/admin/application-configuration')
      const json = await res.json()
      config = json.config
    }
    let delay = playbackDelays[config.hackingInstructor.hintPlaybackSpeed]
    delay ??= 1.0
    await sleep(timeInMs * delay)
  }
}

export function waitForAngularRouteToBeVisited (route: string) {
  return async () => {
    while (true) {
      if (window.location.hash.startsWith(`#/${route}`)) {
        break
      }
      await sleep(100)
    }
  }
}

export function waitForLogIn () {
  return async () => {
    while (true) {
      if (localStorage.getItem('token') !== null) {
        break
      }
      await sleep(100)
    }
  }
}

export function waitForAdminLogIn () {
  return async () => {
    while (true) {
      let role: string = ''
      try {
        const token: string = localStorage.getItem('token')
        const decodedToken = jwtDecode(token)
        const payload = decodedToken as any
        role = payload.data.role
      } catch {
        console.log('Role from token could not be accessed.')
      }
      if (role === 'admin') {
        break
      }
      await sleep(100)
    }
  }
}

export function waitForLogOut () {
  return async () => {
    while (true) {
      if (localStorage.getItem('token') === null) {
        break
      }
      await sleep(100)
    }
  }
}

/**
 * see https://stackoverflow.com/questions/7798748/find-out-whether-chrome-console-is-open/48287643#48287643
 * does detect when devtools are opened horizontally or vertically but not when undocked or open on page load
 */
export function waitForDevTools () {
  const initialInnerHeight = window.innerHeight
  const initialInnerWidth = window.innerWidth
  return async () => {
    while (true) {
      if (window.innerHeight !== initialInnerHeight || window.innerWidth !== initialInnerWidth) {
        break
      }
      await sleep(100)
    }
  }
}

export function waitForSelectToHaveValue (selectSelector: string, value: string) {
  return async () => {
    const selectElement: HTMLSelectElement = document.querySelector(
      selectSelector
    )

    while (true) {
      if (selectElement.options[selectElement.selectedIndex].value === value) {
        break
      }
      await sleep(100)
    }
  }
}

export function waitForSelectToNotHaveValue (selectSelector: string, value: string) {
  return async () => {
    const selectElement: HTMLSelectElement = document.querySelector(
      selectSelector
    )

    while (true) {
      if (selectElement.options[selectElement.selectedIndex].value !== value) {
        break
      }
      await sleep(100)
    }
  }
}

export function waitForRightUriQueryParamPair (key: string, value: string) {
  return async () => {
    while (true) {
      const encodedValue: string = encodeURIComponent(value).replace(/%3A/g, ':')
      const encodedKey: string = encodeURIComponent(key).replace(/%3A/g, ':')
      const expectedHash: string = `#/track-result/new?${encodedKey}=${encodedValue}`

      if (window.location.hash === expectedHash) {
        break
      }
      await sleep(100)
    }
  }
}


/* ===== FILE: ./frontend/src/index.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>OWASP Juice Shop</title>
  <meta name="description" content="Probably the most modern and sophisticated insecure web application">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link id="favicon" rel="icon" type="image/x-icon" href="assets/public/favicon_js.ico">
  <link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.css" />
  <script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.1.0/cookieconsent.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
  <script>
    window.addEventListener("load", function(){
      window.cookieconsent.initialise({
        "palette": {
          "popup": { "background": "var(--theme-primary)", "text": "var(--theme-text)" },
          "button": { "background": "var(--theme-accent)", "text": "var(--theme-text)" }
        },
        "theme": "classic",
        "position": "bottom-right",
        "content": { "message": "This website uses fruit cookies to ensure you get the juiciest tracking experience.", "dismiss": "Me want it!", "link": "But me wait!", "href": "https://www.youtube.com/watch?v=9PnbKL3wuH4" }
      })});
  </script>
</head>
<body class="mat-app-background mat-typography bluegrey-lightgreen-theme">
  <app-root></app-root>
</body>
</html>


/* ===== FILE: ./frontend/src/app/app.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<mat-sidenav-container fullscreen>
  <mat-sidenav #sidenav mode="over">
    <sidenav (sidenavToggle)="sidenav.toggle()"></sidenav>
  </mat-sidenav>
  <app-navbar (sidenavToggle)="sidenav.toggle()"></app-navbar>
  <app-server-started-notification></app-server-started-notification>
  <app-challenge-solved-notification></app-challenge-solved-notification>
  <app-welcome></app-welcome>
  <router-outlet></router-outlet>
</mat-sidenav-container>


/* ===== FILE: ./frontend/src/app/address-select/address-select.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<div id="card">
     <app-address [showNextButton]="showNextButton"></app-address>
</div>



/* ===== FILE: ./frontend/src/app/address-select/address-select.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateModule, TranslateService } from '@ngx-translate/core'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { MatCardModule } from '@angular/material/card'
import { MatFormFieldModule } from '@angular/material/form-field'
import { type ComponentFixture, TestBed, waitForAsync } from '@angular/core/testing'
import { MatInputModule } from '@angular/material/input'
import { ReactiveFormsModule } from '@angular/forms'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'

import { MatTableModule } from '@angular/material/table'
import { MatExpansionModule } from '@angular/material/expansion'
import { MatDividerModule } from '@angular/material/divider'
import { MatRadioModule } from '@angular/material/radio'
import { MatDialogModule } from '@angular/material/dialog'
import { AddressComponent } from '../address/address.component'
import { AddressSelectComponent } from './address-select.component'
import { RouterTestingModule } from '@angular/router/testing'
import { DeliveryMethodComponent } from '../delivery-method/delivery-method.component'
import { MatIconModule } from '@angular/material/icon'
import { MatTooltipModule } from '@angular/material/tooltip'
import { MatCheckboxModule } from '@angular/material/checkbox'
import { EventEmitter } from '@angular/core'
import { of } from 'rxjs'
import { MatSnackBar } from '@angular/material/snack-bar'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('AddressSelectComponent', () => {
  let component: AddressSelectComponent
  let fixture: ComponentFixture<AddressSelectComponent>
  let snackBar: any
  let translateService

  beforeEach(waitForAsync(() => {
    translateService = jasmine.createSpyObj('TranslateService', ['get'])
    translateService.get.and.returnValue(of({}))
    translateService.onLangChange = new EventEmitter()
    translateService.onTranslationChange = new EventEmitter()
    translateService.onDefaultLangChange = new EventEmitter()
    snackBar = jasmine.createSpyObj('MatSnackBar', ['open'])
    snackBar.open.and.returnValue(null)

    TestBed.configureTestingModule({
      imports: [RouterTestingModule.withRoutes([
        { path: 'delivery-method', component: DeliveryMethodComponent }
      ]),
      TranslateModule.forRoot(),
      ReactiveFormsModule,
      BrowserAnimationsModule,
      MatCardModule,
      MatTableModule,
      MatFormFieldModule,
      MatInputModule,
      MatExpansionModule,
      MatDividerModule,
      MatRadioModule,
      MatDialogModule,
      MatIconModule,
      MatTooltipModule,
      MatCheckboxModule,
      AddressSelectComponent, AddressComponent, DeliveryMethodComponent],
      providers: [{ provide: TranslateService, useValue: translateService },
        { provide: MatSnackBar, useValue: snackBar }, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(AddressSelectComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should store address id on calling getMessage', () => {
    component.getMessage(1)
    expect(component.addressId).toBe(1)
  })
})


/* ===== FILE: ./frontend/src/app/address-select/address-select.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Component, NgZone } from '@angular/core'
import { Router } from '@angular/router'
import { AddressComponent } from '../address/address.component'

@Component({
  selector: 'app-address-select',
  templateUrl: './address-select.component.html',
  styleUrls: ['./address-select.component.scss'],
  imports: [AddressComponent]
})
export class AddressSelectComponent {
  public addressId: any = undefined
  public showNextButton: boolean = true

  constructor (private readonly router: Router, private readonly ngZone: NgZone) {}

  getMessage (id) {
    this.addressId = id
  }
}


/* ===== FILE: ./frontend/src/app/password-strength-info/password-strength-info.component.html ===== */

<!--
  ~ Copyright (c) 2014-2024 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<mat-card class="info-card">
  <mat-card-content>
    <div class="info-row">
      @if (passwordComponent.containAtLeastOneLowerCaseLetter) {
        <mat-icon color="primary" fontIcon="done">done</mat-icon>
      }
      @else {
        <mat-icon color="warn" fontIcon="error">error</mat-icon>
      }
      <span>{{lowerCaseCriteriaMsg}}</span>
    </div>
    <div class="info-row">
      @if (passwordComponent.containAtLeastOneUpperCaseLetter) {
        <mat-icon color="primary" fontIcon="done">done</mat-icon>
      }
      @else {
        <mat-icon color="warn" fontIcon="error">error</mat-icon>
      }
      <span>{{upperCaseCriteriaMsg}}</span>
    </div>
    <div class="info-row">
      @if (passwordComponent.containAtLeastOneDigit) {
        <mat-icon color="primary" fontIcon="done">done</mat-icon>
      }
      @else {
        <mat-icon color="warn" fontIcon="error">error</mat-icon>
      }
      <span>{{digitsCriteriaMsg}}</span>
    </div>
    <div class="info-row">
      @if (passwordComponent.containAtLeastOneSpecialChar) {
        <mat-icon color="primary" fontIcon="done">done</mat-icon>
      }
      @else {
        <mat-icon color="warn" fontIcon="error">error</mat-icon>
      }
      <span>{{specialCharsCriteriaMsg}}</span>
    </div>
    <div class="info-row">
      @if (passwordComponent.containAtLeastMinChars) {
        <mat-icon color="primary" fontIcon="done">done</mat-icon>
      }
      @else {
        <mat-icon color="warn" fontIcon="error">error</mat-icon>
      }
      <span>{{minCharsCriteriaMsg}}</span>
    </div>
  </mat-card-content>
</mat-card>


/* ===== FILE: ./frontend/src/app/password-strength-info/password-strength-info.component.spec.ts ===== */

import { type ComponentFixture, TestBed } from '@angular/core/testing'

import { PasswordStrengthInfoComponent } from './password-strength-info.component'

describe('PasswordStrengthInfoComponent', () => {
  let component: PasswordStrengthInfoComponent
  let fixture: ComponentFixture<PasswordStrengthInfoComponent>

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [PasswordStrengthInfoComponent]
    })
      .compileComponents()

    fixture = TestBed.createComponent(PasswordStrengthInfoComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  xit('should create', () => {
    expect(component).toBeTruthy()
  })

  // todo: unit test each conditional | passwordLength message
})


/* ===== FILE: ./frontend/src/app/password-strength-info/password-strength-info.component.ts ===== */

/*
 * Copyright (c) 2014-2024 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Component, Input, OnInit } from '@angular/core'
import { PasswordStrengthComponent } from '../password-strength/password-strength.component'
import { MatCardModule } from '@angular/material/card'
import { MatIconModule } from '@angular/material/icon'

@Component({
  selector: 'app-password-strength-info',
  imports: [MatCardModule, MatIconModule],
  templateUrl: './password-strength-info.component.html',
  styleUrl: './password-strength-info.component.scss'
})
export class PasswordStrengthInfoComponent implements OnInit {
  @Input()
    passwordComponent: PasswordStrengthComponent

  @Input()
    enableScoreInfo = false

  @Input()
    lowerCaseCriteriaMsg = 'contains at least one lower character'

  @Input()
    upperCaseCriteriaMsg = 'contains at least one upper character'

  @Input()
    digitsCriteriaMsg = 'contains at least one digit character'

  @Input()
    specialCharsCriteriaMsg = 'contains at least one special character'

  @Input()
    minCharsCriteriaMsg: string

  ngOnInit (): void {
    if (!this.minCharsCriteriaMsg) {
      this.minCharsCriteriaMsg = `contains at least ${this.passwordComponent.minLength} characters`
    }
  }
}


/* ===== FILE: ./frontend/src/app/accounting/accounting.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateModule } from '@ngx-translate/core'
import { MatDividerModule } from '@angular/material/divider'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { type ComponentFixture, fakeAsync, TestBed, waitForAsync } from '@angular/core/testing'
import { AccountingComponent } from './accounting.component'
import { ProductService } from '../Services/product.service'
import { RouterTestingModule } from '@angular/router/testing'
import { MatGridListModule } from '@angular/material/grid-list'
import { MatCardModule } from '@angular/material/card'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'
import { MatTableModule } from '@angular/material/table'
import { MatPaginatorModule } from '@angular/material/paginator'
import { of } from 'rxjs'
import { QuantityService } from '../Services/quantity.service'
import { MatFormFieldModule } from '@angular/material/form-field'
import { throwError } from 'rxjs/internal/observable/throwError'
import { OrderHistoryService } from '../Services/order-history.service'
import { MatIconModule } from '@angular/material/icon'
import { MatTooltipModule } from '@angular/material/tooltip'
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('AccountingComponent', () => {
  let component: AccountingComponent
  let fixture: ComponentFixture<AccountingComponent>
  let productService
  let quantityService
  let orderHistoryService
  let snackBar: any

  beforeEach(waitForAsync(() => {
    quantityService = jasmine.createSpyObj('QuantityService', ['getAll', 'put'])
    quantityService.getAll.and.returnValue(of([]))
    quantityService.put.and.returnValue(of({}))
    productService = jasmine.createSpyObj('ProductService', ['search', 'get', 'put'])
    productService.search.and.returnValue(of([]))
    productService.get.and.returnValue(of({}))
    productService.put.and.returnValue(of({}))
    orderHistoryService = jasmine.createSpyObj('OrderHistoryService', ['getAll', 'toggleDeliveryStatus'])
    orderHistoryService.getAll.and.returnValue(of([]))
    orderHistoryService.toggleDeliveryStatus.and.returnValue(of({}))
    snackBar = jasmine.createSpyObj('MatSnackBar', ['open'])
    snackBar.open.and.returnValue(null)

    TestBed.configureTestingModule({
      imports: [RouterTestingModule,
        TranslateModule.forRoot(),
        BrowserAnimationsModule,
        MatTableModule,
        MatPaginatorModule,
        MatFormFieldModule,
        MatDividerModule,
        MatGridListModule,
        MatCardModule,
        MatIconModule,
        MatTooltipModule,
        MatSnackBarModule,
        AccountingComponent],
      providers: [
        { provide: ProductService, useValue: productService },
        { provide: QuantityService, useValue: quantityService },
        { provide: OrderHistoryService, useValue: orderHistoryService },
        { provide: MatSnackBar, useValue: snackBar },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(AccountingComponent)
    component = fixture.componentInstance
    component.ngAfterViewInit()
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should load products, quantitites and orders when initiated', () => {
    quantityService.getAll.and.returnValue(of([]))
    productService.search.and.returnValue(of([]))
    orderHistoryService.getAll.and.returnValue(of([]))
    component.ngAfterViewInit()
    expect(quantityService.getAll).toHaveBeenCalled()
    expect(productService.search).toHaveBeenCalled()
    expect(orderHistoryService.getAll).toHaveBeenCalled()
  })

  it('should hold no products when product search API call fails', () => {
    productService.search.and.returnValue(throwError('Error'))
    component.loadProducts()
    fixture.detectChanges()
    expect(component.tableData).toEqual([])
  })

  it('should hold no orders when getAll orders API call fails', () => {
    orderHistoryService.getAll.and.returnValue(throwError('Error'))
    component.loadOrders()
    fixture.detectChanges()
    expect(component.orderData).toEqual([])
  })

  it('should hold no quantities when getAll quanitity API call fails', () => {
    quantityService.getAll.and.returnValue(throwError('Error'))
    component.loadQuantity()
    fixture.detectChanges()
    expect(component.quantityMap).toEqual({})
  })

  it('should log error from product search API call directly to browser console', fakeAsync(() => {
    productService.search.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.loadProducts()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should log error from getAll orders API call directly to browser console', fakeAsync(() => {
    orderHistoryService.getAll.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.loadOrders()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should load orders when toggleDeliveryStatus gets called', () => {
    orderHistoryService.getAll.and.returnValue(throwError('Error'))
    orderHistoryService.toggleDeliveryStatus.and.returnValue(of({}))
    component.changeDeliveryStatus(true, 1)
    expect(orderHistoryService.getAll).toHaveBeenCalled()
  })

  it('should log error from toggleDeliveryStatus API call directly to browser console', fakeAsync(() => {
    orderHistoryService.toggleDeliveryStatus.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.changeDeliveryStatus(true, 1)
    expect(snackBar.open).toHaveBeenCalled()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should log error from getAll quantity API call directly to browser console', fakeAsync(() => {
    quantityService.getAll.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.loadQuantity()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should log and display errors while modifying price', fakeAsync(() => {
    productService.put.and.returnValue(throwError({ error: 'Error' }))
    console.log = jasmine.createSpy('log')
    component.modifyPrice(1, 100)
    fixture.detectChanges()
    expect(snackBar.open).toHaveBeenCalled()
    expect(console.log).toHaveBeenCalledWith({ error: 'Error' })
  }))

  it('should log and display errors while modifying quantity', fakeAsync(() => {
    quantityService.put.and.returnValue(throwError({ error: 'Error' }))
    console.log = jasmine.createSpy('log')
    component.modifyQuantity(1, 100)
    fixture.detectChanges()
    expect(snackBar.open).toHaveBeenCalled()
    expect(console.log).toHaveBeenCalledWith({ error: 'Error' })
  }))

  it('should show confirmation on modifying quantity of a product', fakeAsync(() => {
    quantityService.put.and.returnValue(of({ ProductId: 1 }))
    component.tableData = [{ id: 1, name: 'Apple Juice' }]
    component.modifyQuantity(1, 100)
    fixture.detectChanges()
    expect(snackBar.open).toHaveBeenCalled()
  }))

  it('should show confirmation on modifying price of a product', fakeAsync(() => {
    productService.put.and.returnValue(of({ name: 'Apple Juice' }))
    component.modifyPrice(1, 100)
    fixture.detectChanges()
    expect(snackBar.open).toHaveBeenCalled()
  }))

  it('should modify quantity of a product', () => {
    quantityService.put.and.returnValue(of({ ProductId: 1 }))
    component.tableData = [{ id: 1, name: 'Apple Juice' }]
    quantityService.getAll.and.returnValue(of([]))
    component.modifyQuantity(1, 100)
    expect(quantityService.put).toHaveBeenCalled()
    expect(quantityService.getAll).toHaveBeenCalled()
  })

  it('should modify price of a product', () => {
    productService.search.and.returnValue(of([]))
    productService.put.and.returnValue(of({ name: 'Apple Juice' }))
    component.modifyPrice(1, 100)
    expect(productService.put).toHaveBeenCalled()
    expect(productService.search).toHaveBeenCalled()
  })
})


/* ===== FILE: ./frontend/src/app/accounting/accounting.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<mat-card appearance="outlined" class="mat-elevation-z6 mat-own-card">
  <div class="mdc-card">
    <h1 translate>ACCOUNTING</h1>

    <div class="container">
      <div class="orders-table">
        <div class="heading">
          <span translate>TITLE_TRACK_ORDERS</span>
        </div>
        <mat-table [dataSource]="orderSource">
          <ng-container matColumnDef="OrderId">
            <mat-header-cell *matHeaderCellDef translate="LABEL_ORDER_ID"></mat-header-cell>
            <mat-cell *matCellDef="let element"> {{element.orderId }}</mat-cell>
          </ng-container>

          <ng-container matColumnDef="Price">
            <mat-header-cell *matHeaderCellDef translate="LABEL_PRICE" style="max-width: 96px;"></mat-header-cell>
            <mat-cell *matCellDef="let element" style="max-width: 96px;"> {{element.totalPrice?.toFixed(2) }}&curren;</mat-cell>
          </ng-container>

          <ng-container matColumnDef="Status">
            <mat-header-cell *matHeaderCellDef translate="LABEL_STATUS" style="max-width: 96px;"></mat-header-cell>
            <mat-cell *matCellDef="let element" style="max-width: 96px;">
              <div *ngIf="!element.delivered" class="error" translate>LABEL_IN_TRANSIT</div>
              <div *ngIf="element.delivered" class="confirmation" translate>LABEL_DELIVERED</div>
            </mat-cell>
          </ng-container>

          <ng-container matColumnDef="StatusButton">
            <mat-header-cell *matHeaderCellDef style="max-width: 96px;"></mat-header-cell>
            <mat-cell *matCellDef="let element" style="max-width: 96px;">
              <button *ngIf="element.delivered" mat-icon-button aria-label="Print order confirmation"
                      matTooltip="{{ 'LABEL_MARK_AS_TRANSIT' | translate }}" matTooltipPosition="below"
                      (click)="changeDeliveryStatus(element.delivered, element.id)">
                <mat-icon>
                  cached
                </mat-icon>
              </button>
              <button *ngIf="!element.delivered" mat-icon-button aria-label="Print order confirmation"
                      matTooltip="{{ 'LABEL_MARK_AS_DELIVERED' | translate }}" matTooltipPosition="below"
                      (click)="changeDeliveryStatus(element.delivered, element.id)">
                <mat-icon>
                  check_circle
                </mat-icon>
              </button>
            </mat-cell>
          </ng-container>

          <mat-header-row *matHeaderRowDef="orderHistoryColumns"></mat-header-row>
          <mat-row *matRowDef="let row; columns: orderHistoryColumns;"></mat-row>

        </mat-table>

        <mat-paginator #paginatorOrderHistory
                      [pageSize]="10"
                      class="mat-elevation-z0"
                      color="accent">
        </mat-paginator>
      </div>

      <div class="inventory-table">
        <div class="heading">
          <span translate>TITLE_ALL_PRODUCTS</span>
        </div>
        <mat-table [dataSource]="dataSource">
          <ng-container matColumnDef="Product">
            <mat-header-cell *matHeaderCellDef translate="LABEL_PRODUCT"></mat-header-cell>
            <mat-cell *matCellDef="let element">{{element.name}}</mat-cell>
          </ng-container>

          <ng-container matColumnDef="Price">
            <mat-header-cell *matHeaderCellDef translate="LABEL_PRICE"></mat-header-cell>
            <mat-cell *matCellDef="let element">
              <mat-form-field class="input-field">
                <input #price matInput type="number" value="{{ element.price }}">
                <button mat-icon-button (click)="modifyPrice(element.id, price.value)" matSuffix><i
                  class="fas fa-check"></i>
                </button>
              </mat-form-field>
            </mat-cell>
          </ng-container>

          <ng-container matColumnDef="Quantity">
            <mat-header-cell *matHeaderCellDef translate="LABEL_QUANTITY"></mat-header-cell>
            <mat-cell *matCellDef="let element">
              <mat-form-field class="input-field">
                <input #quanitity matInput type="number" value="{{ quantityMap[element.id].quantity }}">
                <button mat-icon-button (click)="modifyQuantity(quantityMap[element.id].id, quanitity.value)" matSuffix>
                  <i class="fas fa-check"></i>
                </button>
              </mat-form-field>
            </mat-cell>
          </ng-container>

          <mat-header-row *matHeaderRowDef="displayedColumns"></mat-header-row>
          <mat-row *matRowDef="let row; columns: displayedColumns;"></mat-row>

        </mat-table>

        <mat-paginator #paginator
                      [pageSize]="10"
                      class="mat-elevation-z0"
                      color="accent">
        </mat-paginator>
      </div>
    </div>
  </div>
</mat-card>


/* ===== FILE: ./frontend/src/app/accounting/accounting.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { ProductService } from '../Services/product.service'
import { type AfterViewInit, Component, type OnDestroy, ViewChild } from '@angular/core'
import { MatPaginator } from '@angular/material/paginator'
import { type Subscription } from 'rxjs'
import { MatTableDataSource, MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow } from '@angular/material/table'
import { QuantityService } from '../Services/quantity.service'
import { library } from '@fortawesome/fontawesome-svg-core'
import { faCheck } from '@fortawesome/free-solid-svg-icons'
import { OrderHistoryService } from '../Services/order-history.service'
import { SnackBarHelperService } from '../Services/snack-bar-helper.service'
import { MatInputModule } from '@angular/material/input'
import { MatFormFieldModule, MatSuffix } from '@angular/material/form-field'
import { MatIconModule } from '@angular/material/icon'
import { MatTooltip } from '@angular/material/tooltip'
import { MatIconButton } from '@angular/material/button'
import { NgIf } from '@angular/common'
import { FlexModule } from '@angular/flex-layout/flex'
import { TranslateModule } from '@ngx-translate/core'
import { MatCardModule } from '@angular/material/card'

library.add(faCheck)

interface Order {
  id: string
  orderId: string
  totalPrice: number
  delivered: boolean
}

@Component({
  selector: 'app-accounting',
  templateUrl: './accounting.component.html',
  styleUrls: ['./accounting.component.scss'],
  imports: [MatCardModule, TranslateModule, FlexModule, MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, NgIf, MatIconButton, MatTooltip, MatIconModule, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow, MatPaginator, MatFormFieldModule, MatInputModule, MatSuffix]
})
export class AccountingComponent implements AfterViewInit, OnDestroy {
  public orderHistoryColumns = ['OrderId', 'Price', 'Status', 'StatusButton']
  @ViewChild('paginatorOrderHistory', { static: true }) paginatorOrderHistory: MatPaginator
  public orderData: Order[]
  public orderSource
  public displayedColumns = ['Product', 'Price', 'Quantity']
  public tableData: any[]
  public dataSource
  @ViewChild('paginator', { static: true }) paginator: MatPaginator
  private productSubscription: Subscription
  private quantitySubscription: Subscription
  public quantityMap: any
  constructor (private readonly productService: ProductService, private readonly quantityService: QuantityService, private readonly orderHistoryService: OrderHistoryService, private readonly snackBarHelperService: SnackBarHelperService) { }

  ngAfterViewInit () {
    this.loadQuantity()
    this.loadProducts()
    this.loadOrders()
  }

  loadQuantity () {
    this.quantitySubscription = this.quantityService.getAll().subscribe((stock) => {
      this.quantityMap = {}
      stock.forEach((item) => {
        this.quantityMap[item.ProductId] = {
          id: item.id,
          quantity: item.quantity
        }
      })
    }, (err) => { console.log(err) })
  }

  loadProducts () {
    this.productSubscription = this.productService.search('').subscribe((tableData: any) => {
      this.tableData = tableData
      this.dataSource = new MatTableDataSource<Element>(this.tableData)
      this.dataSource.paginator = this.paginator
    }, (err) => { console.log(err) })
  }

  loadOrders () {
    this.orderHistoryService.getAll().subscribe((orders) => {
      this.orderData = []
      for (const order of orders) {
        this.orderData.push({
          id: order._id,
          orderId: order.orderId,
          totalPrice: order.totalPrice,
          delivered: order.delivered
        })
      }
      this.orderSource = new MatTableDataSource<Order>(this.orderData)
      this.orderSource.paginator = this.paginatorOrderHistory
    }, (err) => { console.log(err) })
  }

  ngOnDestroy () {
    if (this.productSubscription) {
      this.productSubscription.unsubscribe()
    }
    if (this.quantitySubscription) {
      this.quantitySubscription.unsubscribe()
    }
  }

  modifyQuantity (id, value) {
    this.quantityService.put(id, { quantity: value < 0 ? 0 : value }).subscribe((quantity) => {
      const product = this.tableData.find((product) => {
        return product.id === quantity.ProductId
      })
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      this.snackBarHelperService.open(`Quantity for ${product.name} has been updated.`, 'confirmBar')
      this.loadQuantity()
    }, (err) => {
      this.snackBarHelperService.open(err.error, 'errorBar')
      console.log(err)
    })
  }

  modifyPrice (id, value) {
    this.productService.put(id, { price: value < 0 ? 0 : value }).subscribe((product) => {
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      this.snackBarHelperService.open(`Price for ${product.name} has been updated.`, 'confirmBar')
      this.loadProducts()
    }, (err) => {
      this.snackBarHelperService.open(err.error, 'errorBar')
      console.log(err)
    })
  }

  changeDeliveryStatus (deliveryStatus, orderId) {
    this.orderHistoryService.toggleDeliveryStatus(orderId, { deliveryStatus }).subscribe(() => {
      this.loadOrders()
    }, (err) => {
      this.snackBarHelperService.open(err, 'errorBar')
      console.log(err)
    })
  }
}


/* ===== FILE: ./frontend/src/app/navbar/navbar.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Component, EventEmitter, NgZone, type OnInit, Output } from '@angular/core'
import { environment } from '../../environments/environment'
import { ChallengeService } from '../Services/challenge.service'
import { UserService } from '../Services/user.service'
import { AdministrationService } from '../Services/administration.service'
import { ConfigurationService } from '../Services/configuration.service'
import { CookieService } from 'ngy-cookie'
import { TranslateService, TranslateModule } from '@ngx-translate/core'
import { Router, RouterLink } from '@angular/router'
import { SocketIoService } from '../Services/socket-io.service'
import { LanguagesService } from '../Services/languages.service'
import { MatSnackBar } from '@angular/material/snack-bar'
import { BasketService } from '../Services/basket.service'
import { FormsModule } from '@angular/forms'
import { MatFormFieldModule } from '@angular/material/form-field'
import { MatInputModule } from '@angular/material/input'

import {
  faBomb,
  faComment,
  faInfoCircle,
  faLanguage,
  faMapMarker,
  faRecycle,
  faSearch,
  faShoppingCart,
  faSignInAlt,
  faSignOutAlt,
  faThermometerEmpty,
  faThermometerFull,
  faThermometerHalf,
  faThermometerQuarter,
  faThermometerThreeQuarters,
  faTrophy,
  faUserCircle,
  faUserSecret
} from '@fortawesome/free-solid-svg-icons'
import { faComments } from '@fortawesome/free-regular-svg-icons'
import { faGithub } from '@fortawesome/free-brands-svg-icons'
import { library } from '@fortawesome/fontawesome-svg-core'
import { LoginGuard } from '../app.guard'
import { roles } from '../roles'
import { MatDivider } from '@angular/material/divider'
import { MatRadioButton } from '@angular/material/radio'
import { NgIf, NgFor } from '@angular/common'
import { MatMenuTrigger, MatMenu, MatMenuItem } from '@angular/material/menu'
import { MatSearchBarComponent } from '../mat-search-bar/mat-search-bar.component'
import { ExtendedModule } from '@angular/flex-layout/extended'
import { MatIconModule } from '@angular/material/icon'
import { MatTooltip } from '@angular/material/tooltip'
import { MatButtonModule } from '@angular/material/button'
import { FlexModule } from '@angular/flex-layout/flex'
import { MatToolbar, MatToolbarRow } from '@angular/material/toolbar'

library.add(faLanguage, faSearch, faSignInAlt, faSignOutAlt, faComment, faBomb, faTrophy, faInfoCircle, faShoppingCart, faUserSecret, faRecycle, faMapMarker, faUserCircle, faGithub, faComments, faThermometerEmpty, faThermometerQuarter, faThermometerHalf, faThermometerThreeQuarters, faThermometerFull)

@Component({
  selector: 'app-navbar',
  templateUrl: './navbar.component.html',
  styleUrls: ['./navbar.component.scss'],
  imports: [
    MatToolbar, FlexModule, MatToolbarRow, MatButtonModule, MatTooltip,
    MatIconModule, RouterLink, ExtendedModule, MatSearchBarComponent,
    MatMenuTrigger, MatMenu, NgIf, MatMenuItem, NgFor, MatRadioButton,
    TranslateModule, MatDivider, MatFormFieldModule, MatInputModule, FormsModule
  ]
})
export class NavbarComponent implements OnInit {
  public userEmail: string = ''
  public languages: any[] = []
  public filteredLanguages: any[] = []
  public languageSearchQuery: string = ''
  public selectedLanguage: string = 'placeholder'
  public version: string = ''
  public applicationName: string = 'OWASP Juice Shop'
  public showGitHubLink: boolean = true
  public logoSrc: string = 'assets/public/images/JuiceShop_Logo.png'
  public scoreBoardVisible: boolean = false
  public shortKeyLang: string = 'placeholder'
  public itemTotal = 0

  @Output() public sidenavToggle = new EventEmitter()

  constructor (private readonly administrationService: AdministrationService, private readonly challengeService: ChallengeService,
    private readonly configurationService: ConfigurationService, private readonly userService: UserService, private readonly ngZone: NgZone,
    private readonly cookieService: CookieService, private readonly router: Router, private readonly translate: TranslateService,
    private readonly io: SocketIoService, private readonly langService: LanguagesService, private readonly loginGuard: LoginGuard,
    private readonly snackBar: MatSnackBar, private readonly basketService: BasketService) { }

  ngOnInit (): void {
    this.getLanguages()
    this.basketService.getItemTotal().subscribe(x => (this.itemTotal = x))
    this.administrationService.getApplicationVersion().subscribe((version: any) => {
      if (version) {
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        this.version = `v${version}`
      }
    }, (err) => { console.log(err) })

    this.configurationService.getApplicationConfiguration().subscribe((config: any) => {
      if (config?.application?.name) {
        this.applicationName = config.application.name
      }
      if (config?.application) {
        this.showGitHubLink = config.application.showGitHubLinks
      }

      if (config?.application?.logo) {
        let logo: string = config.application.logo

        if (logo.substring(0, 4) === 'http') {
          logo = decodeURIComponent(logo.substring(logo.lastIndexOf('/') + 1))
        }
        this.logoSrc = 'assets/public/images/' + logo
      }
    }, (err) => { console.log(err) })

    if (localStorage.getItem('token')) {
      this.getUserDetails()
    } else {
      this.userEmail = ''
    }

    this.userService.getLoggedInState().subscribe((isLoggedIn) => {
      if (isLoggedIn) {
        this.getUserDetails()
      } else {
        this.userEmail = ''
      }
    })

    this.getScoreBoardStatus()

    this.ngZone.runOutsideAngular(() => {
      this.io.socket().on('challenge solved', (challenge) => {
        if (challenge.key === 'scoreBoardChallenge') {
          this.scoreBoardVisible = true
        }
      })
    })
  }

  filterLanguages (): void {
    if (!this.languageSearchQuery) {
      this.filteredLanguages = [...this.languages]
      return
    }

    const query = this.languageSearchQuery.toLowerCase()
    this.filteredLanguages = this.languages.filter((lang: any) => {
      // Filter by language name
      if (lang.lang.toLowerCase().includes(query)) {
        return true
      }

      // Filter by language key (e.g., 'en', 'fr', 'hi')
      if (lang.key.toLowerCase().includes(query)) {
        return true
      }

      // Filter by any additional language properties if needed
      if (lang.shortKey?.toLowerCase()?.includes(query)) {
        return true
      }

      return false
    })
  }

  checkLanguage () {
    if (this.cookieService.get('language')) {
      const langKey = this.cookieService.get('language')
      this.translate.use(langKey)
      this.selectedLanguage = this.languages.find((y: { key: string }) => y.key === langKey)
      this.shortKeyLang = this.languages.find((y: { key: string }) => y.key === langKey).shortKey
    } else {
      this.changeLanguage('en')
      this.selectedLanguage = this.languages.find((y: { key: string }) => y.key === 'en')
      this.shortKeyLang = this.languages.find((y: { key: string }) => y.key === 'en').shortKey
    }
  }

  search (value: string) {
    if (value) {
      const queryParams = { queryParams: { q: value } }
      this.ngZone.run(async () => await this.router.navigate(['/search'], queryParams))
    } else {
      this.ngZone.run(async () => await this.router.navigate(['/search']))
    }
  }

  getUserDetails () {
    this.userService.whoAmI().subscribe((user: any) => {
      this.userEmail = user.email
    }, (err) => { console.log(err) })
  }

  isLoggedIn () {
    return localStorage.getItem('token')
  }

  logout () {
    this.userService.saveLastLoginIp().subscribe((user: any) => { this.noop() }, (err) => { console.log(err) })
    localStorage.removeItem('token')
    this.cookieService.remove('token')
    sessionStorage.removeItem('bid')
    sessionStorage.removeItem('itemTotal')
    this.userService.isLoggedIn.next(false)
    this.ngZone.run(async () => await this.router.navigate(['/']))
  }

  changeLanguage (langKey: string) {
    this.translate.use(langKey)
    const expires = new Date()
    expires.setFullYear(expires.getFullYear() + 1)
    this.cookieService.put('language', langKey, { expires })
    if (this.languages.find((y: { key: string }) => y.key === langKey)) {
      const language = this.languages.find((y: { key: string }) => y.key === langKey)
      this.shortKeyLang = language.shortKey
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      const snackBarRef = this.snackBar.open(`Language has been changed to ${language.lang}`, 'Force page reload', {
        duration: 5000,
        panelClass: ['mat-body']
      })
      snackBarRef.onAction().subscribe(() => {
        location.reload()
      })
    }
  }

  getScoreBoardStatus () {
    this.challengeService.find({ name: 'Score Board' }).subscribe((challenges: any) => {
      this.ngZone.run(() => {
        this.scoreBoardVisible = challenges[0].solved
      })
    }, (err) => { console.log(err) })
  }

  goToProfilePage () {
    window.location.replace(environment.hostServer + '/profile')
  }

  goToDataErasurePage () {
    window.location.replace(environment.hostServer + '/dataerasure')
  }

  onToggleSidenav = () => {
    this.sidenavToggle.emit()
  }

  // eslint-disable-next-line no-empty,@typescript-eslint/no-empty-function
  noop () { }

  getLanguages () {
    this.langService.getLanguages().subscribe((res: any[]) => {
      this.languages = res
      this.filteredLanguages = Array.isArray(res) ? [...res] : []
      this.checkLanguage()
    })
  }

  isAccounting () {
    const payload = this.loginGuard.tokenDecode()
    return payload?.data && payload.data.role === roles.accounting
  }
}


/* ===== FILE: ./frontend/src/app/navbar/navbar.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<mat-toolbar class="mat-elevation-z6" color="primary" fxLayout="column" xmlns="http://www.w3.org/1999/html">

  <mat-toolbar-row fxLayout="row">

    <button (click)="onToggleSidenav()" mat-icon-button style="height:48px; width: 48px;" aria-label="Open Sidenav"
            matTooltip="{{ 'SIDENAV_HINT' | translate }}" matTooltipPosition="below">
      <mat-icon>menu</mat-icon>
    </button>

    <button mat-button routerLink="/search" style="height:60px;" class="buttons" aria-label="Back to homepage">
      <div id="homeButton">
        <img [src]="logoSrc" class="logo" alt={{applicationName}}>
        <span fxHide.lt-sm fxShow style="font-size: x-large"> {{applicationName}} </span>
      </div>
    </button>

    <span class="fill-remaining-space"></span>

    <div>
      <div id="product-search-fixture"></div>
    </div>
    <app-mat-search-bar #searchControl id="searchQuery" (onEnter)="search(searchControl.value)"
                    aria-label="Click to search"></app-mat-search-bar>

    <button [matMenuTriggerFor]="userMenu" mat-button style="vertical-align: middle; height:48px;" class="buttons"
            fxHide.lt-md fxShow aria-label="Show/hide account menu" id="navbarAccount">
      <mat-icon>
        account_circle
      </mat-icon>
      <span> {{"ACCOUNT" | translate}} </span>
    </button>

    <mat-menu #userMenu="matMenu">
      <button *ngIf="!isLoggedIn()" mat-menu-item routerLink="/login" aria-label="Go to login page"
              id="navbarLoginButton">
        <mat-icon>
          exit_to_app
        </mat-icon>
        <span>
          {{"TITLE_LOGIN" | translate }}
        </span>
      </button>
      <button (click)="goToProfilePage()" *ngIf="isLoggedIn()" mat-menu-item aria-label="Go to user profile">
        <mat-icon>
          account_circle
        </mat-icon>
        <span>
          {{userEmail}}
        </span>
      </button>
      <button *ngIf="isLoggedIn() && isAccounting()" mat-menu-item routerLink="/accounting"
              aria-label="Go to accounting page">
        <mat-icon>
          account_balance
        </mat-icon>
        <span>
          {{"ACCOUNTING" | translate}}
        </span>
      </button>
      <button mat-menu-item *ngIf="isLoggedIn()" [matMenuTriggerFor]="ordersSubMenu"
              aria-label="Show Orders and Payment Menu">
        <mat-icon>
          check_circle_outline
        </mat-icon>
        <span>
          {{ "ORDERS_AND_PAYMENT" | translate }}
        </span>
      </button>
      <button mat-menu-item *ngIf="isLoggedIn()" [matMenuTriggerFor]="privacySubMenu"
              aria-label="Show Privacy and Security Menu">
        <mat-icon>
          security
        </mat-icon>
        <span>
          {{ "PRIVACY_AND_SECURITY" | translate }}
        </span>
      </button>
      <button (click)="logout()" *ngIf="isLoggedIn()" mat-menu-item aria-label="Logout" id="navbarLogoutButton">
        <mat-icon>
          power_settings_new
        </mat-icon>
        <span>
          {{"TITLE_LOGOUT" | translate }}
        </span>
      </button>
    </mat-menu>

    <button *ngIf="isLoggedIn()" mat-button routerLink="/basket" style="height:48px;" class="buttons"
            aria-label="Show the shopping cart">
      <mat-icon>
        shopping_cart
      </mat-icon>
      <span fxHide.lt-md fxShow style="margin-right: 10px;"> {{"TITLE_BASKET" | translate}}</span>
      <span class="fa-layers-counter fa-layers-top-right fa-3x warn-notification"
            style="font-size: 47px;">{{itemTotal}}</span>
    </button>

    <button id="navbarLanguageButton" [matMenuTriggerFor]="menu" mat-button style="height:48px; width: 48px;" class="buttons"
            aria-label="Language selection menu"
            matTooltip="{{ 'LANGUAGE_SEL_HINT' | translate }}" matTooltipPosition="below">
      <mat-icon>
        language
      </mat-icon>
      <span fxHide.lt-md fxShow> {{shortKeyLang}} </span>
    </button>

    <mat-menu #menu="matMenu" [overlapTrigger]="true">
      <div class="language-search-container" (click)="$event.stopPropagation()">
        <mat-form-field class="language-search-field">
          <mat-icon matPrefix class="search-icon">search</mat-icon>
          <mat-label>{{ 'SEARCH' | translate }}</mat-label>
          <input type="search" matInput [(ngModel)]="languageSearchQuery" (input)="filterLanguages()">
        </mat-form-field>
      </div>
      @for (language of filteredLanguages; track language.key) {
        <mat-radio-button 
          (click)="changeLanguage(language.key)" 
          [value]="language"
          class="mat-menu-item"
          style="width: 240px;"
          [checked]="selectedLanguage === language"
          [aria-label]="language.lang"
        >
          <div class="mat-body" style="display: inline-block; width: 200px; margin-left: 5px;">
            <span *ngFor="let icon of language.icons" [class]="'fi fi-' + icon"></span>
            {{language?.lang}}
          </div>
          <i [class]="'fas fa-thermometer-' + language.gauge + (language.percentage > 70 ? ' confirmation' : ' error')"></i>
        </mat-radio-button>
      }
    </mat-menu>

    <mat-menu #privacySubMenu="matMenu">
      <button mat-menu-item [routerLink]="['privacy-security/privacy-policy']" aria-label="Go to privacy policy page">
        <mat-icon>
          assignment
        </mat-icon>
        <span translate>TITLE_PRIVACY_POLICY</span>
      </button>
      <button mat-menu-item [routerLink]="['privacy-security/data-export']" aria-label="Go to data export page">
        <mat-icon>
          get_app
        </mat-icon>
        <span translate>TITLE_REQUEST_DATA_EXPORT</span>
      </button>
      <button mat-menu-item (click) = "goToDataErasurePage()" aria-label="Go to data subject page">
        <mat-icon>
          delete_forever
        </mat-icon>
        <span translate>DATA_SUBJECT_TITLE</span>
      </button>
      <mat-divider></mat-divider>
      <button mat-menu-item [routerLink]="['privacy-security/change-password']" aria-label="Go to change password page">
        <mat-icon>
          edit
        </mat-icon>
        <span translate>TITLE_CHANGE_PASSWORD</span>
      </button>
      <button mat-menu-item [routerLink]="['privacy-security/two-factor-authentication']"
              aria-label="Go to two factor authentication page">
        <mat-icon>
          exposure_plus_2
        </mat-icon>
        <span translate>TITLE_TWO_FACTOR_AUTH_CONFIG</span>
      </button>
      <button mat-menu-item [routerLink]="['privacy-security/last-login-ip']" aria-label="Go to last login ip page">
        <mat-icon>
          place
        </mat-icon>
        <span translate>LAST_LOGIN_IP</span>
      </button>
    </mat-menu>

    <mat-menu #ordersSubMenu="matMenu">
      <button mat-menu-item routerLink="/order-history" aria-label="Go to order history page">
        <mat-icon>
          archive
        </mat-icon>
        <span>
          {{"LABEL_ORDER_HISTORY" | translate}}
        </span>
      </button>
      <button mat-menu-item routerLink="/recycle" aria-label="Go to recycling page">
        <mat-icon>
          autorenew
        </mat-icon>
        <span>
          {{"NAV_RECYCLE" | translate}}
        </span>
      </button>
      <mat-divider></mat-divider>
      <button *ngIf="isLoggedIn()" mat-menu-item routerLink="/address/saved" aria-label="Go to saved address page">
        <mat-icon>
          my_location
        </mat-icon>
        <span>
          {{"MY_SAVED_ADRESSES" | translate}}
        </span>
      </button>
      <button *ngIf="isLoggedIn()" mat-menu-item routerLink="/saved-payment-methods"
              aria-label="Go to saved payment methods page">
        <mat-icon>
          credit_card
        </mat-icon>
        <span>
          {{"MY_PAYMENT_OPTIONS" | translate}}
        </span>
      </button>
      <button *ngIf="isLoggedIn()" mat-menu-item routerLink="/wallet" aria-label="Go to wallet page">
        <mat-icon>
          account_balance_wallet
        </mat-icon>
        <span>
          {{"DIGITAL_WALLET" | translate}}
        </span>
      </button>

    </mat-menu>

  </mat-toolbar-row>
</mat-toolbar>


/* ===== FILE: ./frontend/src/app/navbar/navbar.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { ChallengeService } from '../Services/challenge.service'
import { SearchResultComponent } from '../search-result/search-result.component'
import { TranslateModule, TranslateService } from '@ngx-translate/core'
import { UserService } from '../Services/user.service'
import { ConfigurationService } from '../Services/configuration.service'
import { type ComponentFixture, fakeAsync, TestBed, tick, waitForAsync } from '@angular/core/testing'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { NavbarComponent } from './navbar.component'
import { Location } from '@angular/common'

import { BrowserAnimationsModule } from '@angular/platform-browser/animations'
import { MatSelectModule } from '@angular/material/select'
import { MatFormFieldModule } from '@angular/material/form-field'
import { MatIconModule } from '@angular/material/icon'
import { MatToolbarModule } from '@angular/material/toolbar'
import { MatButtonModule } from '@angular/material/button'
import { AdministrationService } from '../Services/administration.service'
import { RouterTestingModule } from '@angular/router/testing'
import { MatMenuModule } from '@angular/material/menu'
import { MatTooltipModule } from '@angular/material/tooltip'
import { CookieModule, CookieService } from 'ngy-cookie'
import { SocketIoService } from '../Services/socket-io.service'
import { of, throwError } from 'rxjs'
import { MatCardModule } from '@angular/material/card'
import { MatInputModule } from '@angular/material/input'
import { MatTableModule } from '@angular/material/table'
import { MatPaginatorModule } from '@angular/material/paginator'
import { MatDialogModule } from '@angular/material/dialog'
import { MatDividerModule } from '@angular/material/divider'
import { MatGridListModule } from '@angular/material/grid-list'
import { LoginGuard } from '../app.guard'
import { MatRadioModule } from '@angular/material/radio'
import { MatSnackBarModule } from '@angular/material/snack-bar'
import { MatSearchBarComponent } from '../mat-search-bar/mat-search-bar.component'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

class MockSocket {
  on (str: string, callback: any) {
    callback(str)
  }
}

describe('NavbarComponent', () => {
  let component: NavbarComponent
  let fixture: ComponentFixture<NavbarComponent>
  let administrationService: any
  let configurationService: any
  let userService: any
  let challengeService: any
  let translateService: any
  let cookieService: any
  let mockSocket: any
  let socketIoService: any
  let location: Location
  let loginGuard

  beforeEach(waitForAsync(() => {
    administrationService = jasmine.createSpyObj('AdministrationService', ['getApplicationVersion'])
    administrationService.getApplicationVersion.and.returnValue(of(undefined))
    configurationService = jasmine.createSpyObj('ConfigurationService', ['getApplicationConfiguration'])
    configurationService.getApplicationConfiguration.and.returnValue(of({}))
    userService = jasmine.createSpyObj('UserService', ['whoAmI', 'getLoggedInState', 'saveLastLoginIp'])
    userService.whoAmI.and.returnValue(of({}))
    userService.getLoggedInState.and.returnValue(of(true))
    userService.saveLastLoginIp.and.returnValue(of({}))
    userService.isLoggedIn = jasmine.createSpyObj('userService.isLoggedIn', ['next'])
    userService.isLoggedIn.next.and.returnValue({})
    challengeService = jasmine.createSpyObj('ChallengeService', ['find'])
    challengeService.find.and.returnValue(of([{ solved: false }]))
    cookieService = jasmine.createSpyObj('CookieService', ['remove', 'get', 'put'])
    mockSocket = new MockSocket()
    socketIoService = jasmine.createSpyObj('SocketIoService', ['socket'])
    socketIoService.socket.and.returnValue(mockSocket)
    loginGuard = jasmine.createSpyObj('LoginGuard', ['tokenDecode'])
    loginGuard.tokenDecode.and.returnValue(of(true))

    TestBed.configureTestingModule({
      imports: [RouterTestingModule.withRoutes([
        { path: 'search', component: SearchResultComponent }
      ]),
      CookieModule.forRoot(),
      TranslateModule.forRoot(),
      BrowserAnimationsModule,
      MatToolbarModule,
      MatIconModule,
      MatFormFieldModule,
      MatSelectModule,
      MatButtonModule,
      MatMenuModule,
      MatTooltipModule,
      MatCardModule,
      MatInputModule,
      MatTableModule,
      MatPaginatorModule,
      MatDialogModule,
      MatDividerModule,
      MatGridListModule,
      MatRadioModule,
      MatSnackBarModule,
      NavbarComponent, SearchResultComponent, MatSearchBarComponent],
      providers: [
        { provide: AdministrationService, useValue: administrationService },
        { provide: ConfigurationService, useValue: configurationService },
        { provide: UserService, useValue: userService },
        { provide: ChallengeService, useValue: challengeService },
        { provide: CookieService, useValue: cookieService },
        { provide: SocketIoService, useValue: socketIoService },
        { provide: LoginGuard, useValue: loginGuard },
        TranslateService,
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()

    location = TestBed.inject(Location)
    translateService = TestBed.inject(TranslateService)
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(NavbarComponent)
    component = fixture.componentInstance
    localStorage.removeItem('token')
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should hold application version', () => {
    administrationService.getApplicationVersion.and.returnValue(of('x.y.z'))
    component.ngOnInit()
    expect(component.version).toBe('vx.y.z')
  })

  it('should show nothing on missing application version', () => {
    administrationService.getApplicationVersion.and.returnValue(of(undefined))
    component.ngOnInit()
    expect(component.version).toBe('')
  })

  it('should show nothing on error retrieving application version', fakeAsync(() => {
    administrationService.getApplicationVersion.and.returnValue(throwError('Error'))
    component.ngOnInit()
    expect(component.version).toBe('')
  }))

  it('should log errors directly to browser console', fakeAsync(() => {
    administrationService.getApplicationVersion.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.ngOnInit()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should use default application name if not customized', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({}))
    component.ngOnInit()
    expect(component.applicationName).toBe('OWASP Juice Shop')
  })

  it('should use custom application name URL if configured', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { name: 'name' } }))
    component.ngOnInit()
    expect(component.applicationName).toBe('name')
  })

  it('should set user email on page reload if user is authenticated', () => {
    userService.whoAmI.and.returnValue(of({ email: 'dummy@dummy.com' }))
    localStorage.setItem('token', 'token')
    component.ngOnInit()
    expect(component.userEmail).toBe('dummy@dummy.com')
  })

  it('should set user email on getting logged in', () => {
    localStorage.removeItem('token')
    userService.getLoggedInState.and.returnValue(of(true))
    userService.whoAmI.and.returnValue(of({ email: 'dummy@dummy.com' }))
    component.ngOnInit()
    expect(component.userEmail).toBe('dummy@dummy.com')
  })

  it('should log errors directly to browser console when getting user failed', fakeAsync(() => {
    userService.whoAmI.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.ngOnInit()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should show GitHub button by default', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({}))
    component.ngOnInit()
    expect(component.showGitHubLink).toBe(true)
  })

  it('should hide GitHub ribbon if so configured', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { showGitHubLinks: false } }))
    component.ngOnInit()
    expect(component.showGitHubLink).toBe(false)
  })

  it('should log error while getting application configuration from backend API directly to browser console', fakeAsync(() => {
    configurationService.getApplicationConfiguration.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.ngOnInit()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should hide Score Board menu item when corresponding challenge was not solved yet', () => {
    challengeService.find.and.returnValue(of([{ solved: false }]))
    component.ngOnInit()
    expect(component.scoreBoardVisible).toBeFalsy()
  })

  it('should show Score Board menu item if corresponding challenge has been solved', () => {
    challengeService.find.and.returnValue(of([{ solved: true }]))
    component.ngOnInit()
    expect(component.scoreBoardVisible).toBe(true)
  })

  it('forwards to search result with search query as URL parameter', fakeAsync(() => {
    component.search('lemon juice')
    tick()
    expect(location.path()).toBe(encodeURI('/search?q=lemon juice'))
  }))

  it('forwards to search result with empty search criteria if no search query is present', fakeAsync(() => {
    component.search('')
    tick()
    expect(location.path()).toBe(encodeURI('/search'))
  }))

  it('should remove authentication token from localStorage', () => {
    spyOn(localStorage, 'removeItem')
    component.logout()
    expect(localStorage.removeItem).toHaveBeenCalledWith('token')
  })

  it('should remove authentication token from cookies', () => {
    component.logout()
    expect(cookieService.remove).toHaveBeenCalledWith('token')
  })

  it('should remove basket id from session storage', () => {
    spyOn(sessionStorage, 'removeItem')
    component.logout()
    expect(sessionStorage.removeItem).toHaveBeenCalledWith('bid')
  })

  it('should remove basket item total from session storage', () => {
    spyOn(sessionStorage, 'removeItem')
    component.logout()
    expect(sessionStorage.removeItem).toHaveBeenCalledWith('itemTotal')
  })

  it('should set the login status to be false via UserService', () => {
    component.logout()
    expect(userService.isLoggedIn.next).toHaveBeenCalledWith(false)
  })

  it('should save the last login IP address', () => {
    component.logout()
    expect(userService.saveLastLoginIp).toHaveBeenCalled()
  })

  it('should forward to main page', fakeAsync(() => {
    component.logout()
    tick()
    expect(location.path()).toBe('/')
  }))

  it('should set selected a language', () => {
    spyOn(translateService, 'use').and.callFake((lang: any) => lang)
    component.changeLanguage('xx')
    expect(translateService.use).toHaveBeenCalledWith('xx')
  })
})


/* ===== FILE: ./frontend/src/app/two-factor-auth-enter/two-factor-auth-enter.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type ComponentFixture, TestBed, waitForAsync } from '@angular/core/testing'

import { TwoFactorAuthEnterComponent } from './two-factor-auth-enter.component'
import { SearchResultComponent } from '../search-result/search-result.component'
import { UserService } from '../Services/user.service'
import { WindowRefService } from '../Services/window-ref.service'

import { ReactiveFormsModule } from '@angular/forms'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { RouterTestingModule } from '@angular/router/testing'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'

import { TranslateModule } from '@ngx-translate/core'
import { CookieModule, CookieService } from 'ngy-cookie'

import { MatCardModule } from '@angular/material/card'
import { MatFormFieldModule } from '@angular/material/form-field'
import { MatButtonModule } from '@angular/material/button'
import { MatInputModule } from '@angular/material/input'
import { MatCheckboxModule } from '@angular/material/checkbox'
import { MatIconModule } from '@angular/material/icon'
import { MatTableModule } from '@angular/material/table'
import { MatPaginatorModule } from '@angular/material/paginator'
import { MatDialogModule } from '@angular/material/dialog'
import { MatDividerModule } from '@angular/material/divider'
import { MatGridListModule } from '@angular/material/grid-list'
import { MatSnackBarModule } from '@angular/material/snack-bar'
import { MatTooltipModule } from '@angular/material/tooltip'

import { of } from 'rxjs'
import { TwoFactorAuthService } from '../Services/two-factor-auth-service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('TwoFactorAuthEnterComponent', () => {
  let component: TwoFactorAuthEnterComponent
  let fixture: ComponentFixture<TwoFactorAuthEnterComponent>
  let cookieService: any
  let userService: any
  let twoFactorAuthService: any

  beforeEach(waitForAsync(() => {
    userService = jasmine.createSpyObj('UserService', ['login'])
    userService.login.and.returnValue(of({}))
    userService.isLoggedIn = jasmine.createSpyObj('userService.isLoggedIn', ['next'])
    userService.isLoggedIn.next.and.returnValue({})
    twoFactorAuthService = jasmine.createSpyObj('TwoFactorAuthService', ['verify'])
    twoFactorAuthService.verify.and.returnValue(of({ }))

    TestBed.configureTestingModule({
      imports: [RouterTestingModule.withRoutes([
        { path: 'search', component: SearchResultComponent }
      ]),
      ReactiveFormsModule,
      CookieModule.forRoot(),
      TranslateModule.forRoot(),
      BrowserAnimationsModule,
      MatCheckboxModule,
      MatFormFieldModule,
      MatCardModule,
      MatIconModule,
      MatInputModule,
      MatTableModule,
      MatPaginatorModule,
      MatDialogModule,
      MatDividerModule,
      MatButtonModule,
      MatGridListModule,
      MatSnackBarModule,
      MatTooltipModule,
      TwoFactorAuthEnterComponent, SearchResultComponent],
      providers: [
        { provide: UserService, useValue: userService },
        { provide: TwoFactorAuthService, useValue: twoFactorAuthService },
        CookieService,
        WindowRefService,
        CookieService,
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
    cookieService = TestBed.inject(CookieService)
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(TwoFactorAuthEnterComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should store authentication token in cookie', () => {
    twoFactorAuthService.verify.and.returnValue(of({ token: 'TOKEN' }))
    component.verify()

    expect(cookieService.get('token')).toBe('TOKEN')
  })

  it('should store authentication token in local storage', () => {
    twoFactorAuthService.verify.and.returnValue(of({ token: 'TOKEN' }))
    component.verify()

    expect(localStorage.getItem('token')).toBe('TOKEN')
  })

  it('should store basket ID in session storage', () => {
    twoFactorAuthService.verify.and.returnValue(of({ bid: 42 }))
    component.verify()

    expect(sessionStorage.getItem('bid')).toBe('42')
  })

  xit('should notify about user login after 2FA verification', () => { // FIXME Spy call is not registered at all
    component.verify()

    expect(userService.isLoggedIn.next).toHaveBeenCalledWith(true)
  })
})


/* ===== FILE: ./frontend/src/app/two-factor-auth-enter/two-factor-auth-enter.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<div fxLayoutAlign="center">
  <mat-card appearance="outlined" class="mat-elevation-z6">
    <div class="mdc-card">

      <h1 translate>TITLE_TWO_FACTOR_AUTHENTICATION</h1>

      <p translate>TITLE_TWO_FACTOR_AUTH_ENTER</p>

      <div *ngIf="errored" class="error" style="margin-bottom: 10px;" translate>INVALID_TWO_FACTOR_AUTH_TOKEN</div>

      <form (ngSubmit)="verify()" [formGroup]="twoFactorForm">

        <div class="form-container">
          <mat-form-field id="inputToken" appearance="outline" color="accent">
            <mat-label translate>LABEL_TWO_FACTOR_AUTH_TOKEN</mat-label>
            <input #tokenInput formControlName="token" type="text" minlength="6" maxlength="6" pattern="^[\d]{6}$" matInput id="totpToken"
                  aria-label="Field for entering the Two Factor token" placeholder="{{ '2FA_ENTER_CODE_PLACEHOLDER' | translate}}">
            <mat-icon matSuffix matTooltip="{{ 'INITIAL_TOKEN_TOOLTIP' | translate}}"
                      matTooltipPosition=right
                      aria-label="The code to be entered from the authenticator must have 6 digits.">
              help_outline
            </mat-icon>
            <mat-hint align="end">{{tokenInput.value?.length || 0}}/6</mat-hint>
            <mat-error translate>INVALID_TWO_FACTOR_AUTH_TOKEN</mat-error>
          </mat-form-field>
        </div>

        <button type="submit" color="primary" mat-raised-button [disabled]="twoFactorForm.invalid" id="totpSubmitButton" aria-label="Button to confirm the input">
          <mat-icon>lock_open</mat-icon>
          {{'BTN_LOGIN' | translate}}
        </button>
      </form>

    </div>
  </mat-card>
</div>


/* ===== FILE: ./frontend/src/app/two-factor-auth-enter/two-factor-auth-enter.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Component, NgZone } from '@angular/core'
import { UntypedFormControl, UntypedFormGroup, Validators, FormsModule, ReactiveFormsModule } from '@angular/forms'
import { TwoFactorAuthService } from '../Services/two-factor-auth-service'
import { CookieService } from 'ngy-cookie'
import { UserService } from '../Services/user.service'
import { Router } from '@angular/router'
import { library } from '@fortawesome/fontawesome-svg-core'
import { faUnlockAlt } from '@fortawesome/free-solid-svg-icons'
import { MatButtonModule } from '@angular/material/button'
import { MatTooltip } from '@angular/material/tooltip'
import { MatIconModule } from '@angular/material/icon'
import { MatInputModule } from '@angular/material/input'
import { MatFormFieldModule, MatLabel, MatSuffix, MatHint, MatError } from '@angular/material/form-field'
import { NgIf } from '@angular/common'
import { TranslateModule } from '@ngx-translate/core'
import { MatCardModule } from '@angular/material/card'
import { FlexModule } from '@angular/flex-layout/flex'

library.add(faUnlockAlt)

interface TokenEnterFormFields {
  token: string
}

@Component({
  selector: 'app-two-factor-auth-enter',
  templateUrl: './two-factor-auth-enter.component.html',
  styleUrls: ['./two-factor-auth-enter.component.scss'],
  imports: [FlexModule, MatCardModule, TranslateModule, NgIf, FormsModule, ReactiveFormsModule, MatFormFieldModule, MatLabel, MatInputModule, MatIconModule, MatSuffix, MatTooltip, MatHint, MatError, MatButtonModule, MatIconModule]
})
export class TwoFactorAuthEnterComponent {
  public twoFactorForm: UntypedFormGroup = new UntypedFormGroup({
    token: new UntypedFormControl('', [Validators.minLength(6), Validators.maxLength(6), Validators.required, Validators.pattern('^[\\d]{6}$')])
  })

  public errored: boolean = false

  constructor (
    private readonly twoFactorAuthService: TwoFactorAuthService,
    private readonly cookieService: CookieService,
    private readonly userService: UserService,
    private readonly router: Router,
    private readonly ngZone: NgZone
  ) { }

  verify () {
    const fields: TokenEnterFormFields = this.twoFactorForm.value

    this.twoFactorAuthService.verify(fields.token).subscribe((authentication) => {
      localStorage.setItem('token', authentication.token)
      const expires = new Date()
      expires.setHours(expires.getHours() + 8)
      this.cookieService.put('token', authentication.token, { expires })
      sessionStorage.setItem('bid', authentication.bid?.toString())
      /* Use userService to notifiy if user has logged in */
      /* this.userService.isLoggedIn = true; */
      this.userService.isLoggedIn.next(true)
      this.ngZone.run(async () => await this.router.navigate(['/search']))
    }, (error) => {
      this.errored = true
      setTimeout(() => {
        this.errored = false
      }, 5 * 1000)
      return error
    })
  }
}


/* ===== FILE: ./frontend/src/app/basket/basket.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateModule } from '@ngx-translate/core'
import { MatInputModule } from '@angular/material/input'
import { MatExpansionModule } from '@angular/material/expansion'
import { MatDialogModule } from '@angular/material/dialog'
import { type ComponentFixture, TestBed, waitForAsync } from '@angular/core/testing'

import { BasketComponent } from './basket.component'
import { MatCardModule } from '@angular/material/card'
import { MatTableModule } from '@angular/material/table'
import { MatButtonModule } from '@angular/material/button'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { ReactiveFormsModule } from '@angular/forms'
import { MatFormFieldModule } from '@angular/material/form-field'
import { MatButtonToggleModule } from '@angular/material/button-toggle'
import { RouterTestingModule } from '@angular/router/testing'
import { PurchaseBasketComponent } from '../purchase-basket/purchase-basket.component'
import { DeluxeGuard } from '../app.guard'
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('BasketComponent', () => {
  let component: BasketComponent
  let fixture: ComponentFixture<BasketComponent>
  let deluxeGuard
  let snackBar: any

  beforeEach(waitForAsync(() => {
    TestBed.configureTestingModule({
      imports: [RouterTestingModule,
        TranslateModule.forRoot(),
        BrowserAnimationsModule,
        ReactiveFormsModule,
        MatFormFieldModule,
        MatInputModule,
        MatCardModule,
        MatTableModule,
        MatButtonModule,
        MatExpansionModule,
        MatDialogModule,
        MatButtonToggleModule,
        MatSnackBarModule,
        BasketComponent, PurchaseBasketComponent],
      providers: [
        { provide: DeluxeGuard, useValue: deluxeGuard },
        { provide: MatSnackBar, useValue: snackBar },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(BasketComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should store product count on calling getProductCount', () => {
    component.getProductCount(1)
    expect(component.productCount).toBe(1)
  })

  it('should store bonus points on calling getBonusPoints', () => {
    component.getBonusPoints([1, 10])
    expect(component.bonus).toBe(10)
  })

  it('should store itemTotal in session storage', () => {
    spyOn(sessionStorage, 'setItem')
    component.getBonusPoints([1, 10])
    expect(sessionStorage.setItem).toHaveBeenCalledWith('itemTotal', 1 as any)
  })
})


/* ===== FILE: ./frontend/src/app/basket/basket.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Component, NgZone } from '@angular/core'
import { library } from '@fortawesome/fontawesome-svg-core'
import { faCartArrowDown } from '@fortawesome/free-solid-svg-icons'
import { Router } from '@angular/router'
import { TranslateModule } from '@ngx-translate/core'
import { MatButtonModule } from '@angular/material/button'
import { PurchaseBasketComponent } from '../purchase-basket/purchase-basket.component'
import { MatCardModule } from '@angular/material/card'

library.add(faCartArrowDown)

@Component({
  selector: 'app-basket',
  templateUrl: './basket.component.html',
  styleUrls: ['./basket.component.scss'],
  imports: [MatCardModule, PurchaseBasketComponent, MatButtonModule, TranslateModule]
})
export class BasketComponent {
  public productCount: number = 0
  public bonus: number = 0

  constructor (private readonly router: Router, private readonly ngZone: NgZone) {}

  checkout () {
    this.ngZone.run(async () => await this.router.navigate(['/address/select']))
  }

  getProductCount (total) {
    this.productCount = total
  }

  getBonusPoints (total) {
    sessionStorage.setItem('itemTotal', total[0])
    this.bonus = total[1]
  }
}


/* ===== FILE: ./frontend/src/app/basket/basket.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<mat-card appearance="outlined" class="mat-elevation-z6">
  <div class="mdc-card">
    <app-purchase-basket [allowEdit]="true" (emitTotal)="getBonusPoints($event)"
                        (emitProductCount)="getProductCount($event)"></app-purchase-basket>
    <button id="checkoutButton" class="checkout-button" color="primary" [disabled]="productCount < 1" (click)="checkout()"
            mat-raised-button><i class="fas fa-cart-arrow-down"></i> {{"BTN_CHECKOUT" | translate}}
    </button>
    <div class="hint" translate [translateParams]="{'bonus': bonus}">CHECKOUT_FOR_BONUS_POINTS</div>
  </div>
</mat-card>


/* ===== FILE: ./frontend/src/app/data-export/data-export.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type ComponentFixture, fakeAsync, TestBed, waitForAsync } from '@angular/core/testing'
import { DataExportComponent } from './data-export.component'
import { TranslateModule, TranslateService } from '@ngx-translate/core'
import { ImageCaptchaService } from '../Services/image-captcha.service'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { ReactiveFormsModule } from '@angular/forms'
import { of, throwError } from 'rxjs'
import { DomSanitizer } from '@angular/platform-browser'
import { SecurityContext } from '@angular/core'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'
import { DataSubjectService } from '../Services/data-subject.service'
import { MatFormFieldModule } from '@angular/material/form-field'
import { MatInputModule } from '@angular/material/input'
import { MatCardModule } from '@angular/material/card'
import { MatRadioModule } from '@angular/material/radio'
import { MatButtonModule } from '@angular/material/button'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('DataExportComponent', () => {
  let component: DataExportComponent
  let fixture: ComponentFixture<DataExportComponent>
  let imageCaptchaService: any
  let dataSubjectService: any
  let domSanitizer: DomSanitizer

  beforeEach(waitForAsync(() => {
    imageCaptchaService = jasmine.createSpyObj('ImageCaptchaService', ['getCaptcha'])
    imageCaptchaService.getCaptcha.and.returnValue(of({}))
    dataSubjectService = jasmine.createSpyObj('DataSubjectService', ['dataExport'])

    TestBed.configureTestingModule({
      imports: [TranslateModule.forRoot(),
        MatFormFieldModule,
        ReactiveFormsModule,
        BrowserAnimationsModule,
        MatInputModule,
        MatCardModule,
        MatRadioModule,
        MatButtonModule,
        DataExportComponent],
      providers: [
        { provide: ImageCaptchaService, useValue: imageCaptchaService },
        { provide: DataSubjectService, useValue: dataSubjectService },
        TranslateService,
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    }).compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(DataExportComponent)
    component = fixture.componentInstance
    domSanitizer = TestBed.inject(DomSanitizer)
    fixture.detectChanges()
  })

  it('should compile', () => {
    expect(component).toBeTruthy()
  })

  it('should reinitizalise form by calling resetForm', () => {
    component.captchaControl.setValue('captcha')
    component.formatControl.setValue('1')
    component.resetForm()
    expect(component.captchaControl.value).toBe('')
    expect(component.captchaControl.pristine).toBe(true)
    expect(component.captchaControl.untouched).toBe(true)
    expect(component.formatControl.value).toBe('')
    expect(component.formatControl.pristine).toBe(true)
    expect(component.formatControl.untouched).toBe(true)
  })

  it('should be compulsory to select export format', () => {
    component.formatControl.setValue('')
    expect(component.formatControl.valid).toBeFalsy()
  })

  it('should be compulsory to answer the captcha when captcha is present', () => {
    component.captchaControl.setValue('')
    expect(component.captchaControl.valid).toBeFalsy()
    component.captchaControl.setValue('12345')
    expect(component.captchaControl.valid).toBe(true)
  })

  it('should store the captcha on getting new captcha', () => {
    imageCaptchaService.getCaptcha.and.returnValue(of({ image: '<svg>captcha</svg>' }))
    component.getNewCaptcha()
    const sanitezedCaptcha = domSanitizer.sanitize(SecurityContext.HTML, component.captcha)
    expect(sanitezedCaptcha).toBe('<svg>captcha</svg>')
  })

  it('should show the confirmation and fetch user data and reset data export form on requesting data export', () => {
    dataSubjectService.dataExport.and.returnValue(of({ confirmation: 'Data being exported', userData: '{ user data }' }))
    spyOn(component, 'resetForm')
    spyOn(component, 'ngOnInit')
    component.save()
    expect(component.confirmation).toBe('Data being exported')
    expect(component.userData).toBe('{ user data }')
    expect(component.error).toBeNull()
    expect(component.ngOnInit).toHaveBeenCalled()
    expect(component.resetForm).toHaveBeenCalled()
  })

  it('should clear the form and display error if exporting data fails', fakeAsync(() => {
    dataSubjectService.dataExport.and.returnValue(throwError({ error: 'Error' }))
    spyOn(component, 'resetFormError')
    component.save()
    expect(component.confirmation).toBeNull()
    expect(component.error).toBe('Error')
    expect(component.resetFormError).toHaveBeenCalled()
  }))
})


/* ===== FILE: ./frontend/src/app/data-export/data-export.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Component, type OnInit } from '@angular/core'
import { UntypedFormControl, Validators, FormsModule, ReactiveFormsModule } from '@angular/forms'
import { ImageCaptchaService } from '../Services/image-captcha.service'
import { DataSubjectService } from '../Services/data-subject.service'
import { DomSanitizer } from '@angular/platform-browser'
import { MatButtonModule } from '@angular/material/button'
import { MatInputModule } from '@angular/material/input'
import { MatLabel, MatFormFieldModule, MatHint, MatError } from '@angular/material/form-field'
import { MatRadioGroup, MatRadioButton } from '@angular/material/radio'
import { NgIf } from '@angular/common'
import { TranslateModule } from '@ngx-translate/core'
import { MatCardModule } from '@angular/material/card'
import { FlexModule } from '@angular/flex-layout/flex'
import { MatIconModule } from '@angular/material/icon'

@Component({
  selector: 'app-data-export',
  templateUrl: './data-export.component.html',
  styleUrls: ['./data-export.component.scss'],
  imports: [FlexModule, MatCardModule, TranslateModule, NgIf, MatRadioGroup, FormsModule, ReactiveFormsModule, MatLabel, MatRadioButton, MatFormFieldModule, MatInputModule, MatHint, MatError, MatButtonModule, MatIconModule]
})
export class DataExportComponent implements OnInit {
  public captchaControl: UntypedFormControl = new UntypedFormControl('', [Validators.required, Validators.minLength(5)])
  public formatControl: UntypedFormControl = new UntypedFormControl('', [Validators.required])
  public captcha: any
  private dataRequest: any = undefined
  public confirmation: any
  public error: any
  public lastSuccessfulTry: any
  public presenceOfCaptcha: boolean = false
  public userData: any

  constructor (public sanitizer: DomSanitizer, private readonly imageCaptchaService: ImageCaptchaService, private readonly dataSubjectService: DataSubjectService) { }
  ngOnInit (): void {
    this.needCaptcha()
    this.dataRequest = {}
  }

  needCaptcha () {
    const nowTime = new Date()
    const timeOfCaptcha = localStorage.getItem('lstdtxprt') ? new Date(JSON.parse(String(localStorage.getItem('lstdtxprt')))) : new Date(0)
    if (nowTime.getTime() - timeOfCaptcha.getTime() < 300000) {
      this.getNewCaptcha()
      this.presenceOfCaptcha = true
    }
  }

  getNewCaptcha () {
    this.imageCaptchaService.getCaptcha().subscribe((data: any) => {
      this.captcha = this.sanitizer.bypassSecurityTrustHtml(data.image)
    })
  }

  save () {
    if (this.presenceOfCaptcha) {
      this.dataRequest.answer = this.captchaControl.value
    }
    this.dataRequest.format = this.formatControl.value
    this.dataSubjectService.dataExport(this.dataRequest).subscribe((data: any) => {
      this.error = null
      this.confirmation = data.confirmation
      this.userData = data.userData
      window.open('', '_blank', 'width=500')?.document.write(this.userData)
      this.lastSuccessfulTry = new Date()
      localStorage.setItem('lstdtxprt', JSON.stringify(this.lastSuccessfulTry))
      this.ngOnInit()
      this.resetForm()
    }, (error) => {
      this.error = error.error
      this.confirmation = null
      this.resetFormError()
    })
  }

  resetForm () {
    this.captchaControl.markAsUntouched()
    this.captchaControl.markAsPristine()
    this.captchaControl.setValue('')
    this.formatControl.markAsUntouched()
    this.formatControl.markAsPristine()
    this.formatControl.setValue('')
  }

  resetFormError () {
    this.captchaControl.markAsUntouched()
    this.captchaControl.markAsPristine()
    this.captchaControl.setValue('')
  }
}


/* ===== FILE: ./frontend/src/app/data-export/data-export.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<div fxLayoutAlign="center">
  <mat-card appearance="outlined" class="mat-elevation-z6">
    <div class="mdc-card">
      <h1 translate>TITLE_REQUEST_DATA_EXPORT</h1>

      <div *ngIf="error">
        <p class="error">{{error}}</p>
      </div>

      <div class="form-container" id="data-export-form">
        <mat-radio-group id="formatControl" [formControl]="formatControl" aria-label="Select an option">
          <mat-label class="radio-label" translate>EXPORT_LABEL <span>:</span></mat-label>
          <mat-radio-button value="1" aria-label="Export Option JSON">JSON</mat-radio-button>
          <mat-radio-button value="2" aria-label="Export Option PDF" disabled>PDF</mat-radio-button>
          <mat-radio-button value="3" aria-label="Export Option Excel" disabled>Excel</mat-radio-button>
        </mat-radio-group>

        <div *ngIf="presenceOfCaptcha">
          <div>
            <span style="float: left; margin-top: 40px; font-weight: 500; margin-bottom: 20px;" translate>CAPTCHA <span>:</span></span>
            <div class="captcha-image" [innerHTML]="captcha" style="margin-left: 10px;"></div>
          </div>
          <mat-form-field style="margin-top: 10px; width: 100%;" appearance="outline" color="accent">
            <mat-label translate>ENTER_CAPTCHA</mat-label>
            <input #captchaInput [formControl]="captchaControl" type="text" matInput
                  placeholder="{{ 'TYPE_THESE_LETTERS' | translate: {length: '5'} }}" maxlength="5"
                  aria-label="Input for the CAPTCHA">
            <mat-hint align="end">{{captchaInput.value?.length || 0}}/5</mat-hint>
            <mat-error *ngIf="captchaControl.invalid && captchaControl.errors.required " translate>MANDATORY_CAPTCHA
            </mat-error>
            <mat-error *ngIf="captchaControl.invalid && captchaControl.errors.minlength" translate>MANDATORY_CAPTCHA
            </mat-error>
          </mat-form-field>
        </div>
      </div>
      <button type="submit" style="margin-top: 15px;" id="submitButton" color="primary" mat-raised-button (click)="save()"
              [disabled]="formatControl.invalid || (captchaControl.invalid && presenceOfCaptcha)"
              aria-label="Button to send the request">
        <mat-icon>download</mat-icon>
        {{'BTN_REQUEST' | translate}}
      </button>
      <div class="hint">
        <span translate>DATA_EXPORT_HINT</span>
      </div>
    </div>
  </mat-card>
</div>


/* ===== FILE: ./frontend/src/app/delivery-method/delivery-method.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<mat-card appearance="outlined" class="mat-elevation-z6">
  <div class="mdc-card">

    <div *ngIf="address" class="addressCont">
      <h1 translate>LABEL_DELIVERY_ADDRESS</h1>
      <div>{{address?.fullName}}</div>
      <div>{{address?.streetAddress}}, {{address?.city}}, {{address?.state}}, {{address?.zipCode}}</div>
      <div>{{address?.country}}</div>
      <div><span translate>PHONE_NUMBER</span> {{address?.mobileNum}}</div>
    </div>
    <mat-divider *ngIf="address" class="detail-divider"></mat-divider>
    <div style="height: 12px;"></div>
    <div>
      <h1 translate>LABEL_CHOOSE_A_DELIVERY_SPEED</h1>
      <mat-table [dataSource]="dataSource">
        <ng-container matColumnDef="Selection">
          <mat-header-cell *matHeaderCellDef fxFlex="20%"></mat-header-cell>
          <mat-cell *matCellDef="let element; let row" fxFlex="20%">
            <mat-radio-button (click)=selectMethod(element.id) [checked]="selection.isSelected(row)"
                              (change)="$event ? selection.toggle(row) : null"></mat-radio-button>
          </mat-cell>
        </ng-container>
        <ng-container matColumnDef="Name">
          <mat-header-cell *matHeaderCellDef fxFlex="30%"></mat-header-cell>
          <mat-cell *matCellDef="let element" fxFlex="30%"><i [ngClass]="element.icon"></i>&nbsp;{{ element.name }}</mat-cell>
        </ng-container>
        <ng-container matColumnDef="Price">
          <mat-header-cell *matHeaderCellDef translate="LABEL_PRICE" fxFlex="25%" class="table-header-label"></mat-header-cell>
          <mat-cell *matCellDef="let element" fxFlex="25%">{{ element.price.toFixed(2) }}&curren;</mat-cell>
        </ng-container>
        <ng-container matColumnDef="ETA">
          <mat-header-cell *matHeaderCellDef translate="LABEL_EXPECTED_DELIVERY" fxFlex="25%" class="table-header-label"></mat-header-cell>
          <mat-cell *matCellDef="let element" fxFlex="25%">{{ element.eta }} {{"LABEL_DAYS" | translate}}</mat-cell>
        </ng-container>
        <mat-header-row *matHeaderRowDef="displayedColumns"></mat-header-row>
        <mat-row *matRowDef="let row; columns: displayedColumns; let element"
                (click)="selection.toggle(row); selectMethod(element.id)"></mat-row>
      </mat-table>
    </div>
    <div style="margin-top: 20px;">
      <button mat-stroked-button class="btn btn-return" (click)="routeToPreviousUrl()">
        <mat-icon>
          navigate_before
        </mat-icon>
        {{'LABEL_BACK' | translate}}
      </button>
      <button mat-raised-button mat-button class="btn nextButton" color="primary"
              aria-label="Proceed to delivery method selection" [disabled]="deliveryMethodId === undefined"
              (click)="chooseDeliveryMethod()">
        <mat-icon>
          navigate_next
        </mat-icon>
        <span translate>LABEL_CONTINUE</span>
      </button>
    </div>
  </div>
</mat-card>


/* ===== FILE: ./frontend/src/app/delivery-method/delivery-method.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Component, NgZone, type OnInit } from '@angular/core'
import { DeliveryService } from '../Services/delivery.service'
import { AddressService } from '../Services/address.service'
import { MatTableDataSource, MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow } from '@angular/material/table'
import { Router } from '@angular/router'
import { Location, NgIf, NgClass } from '@angular/common'
import { type DeliveryMethod } from '../Models/deliveryMethod.model'
import { library } from '@fortawesome/fontawesome-svg-core'
import { faRocket, faShippingFast, faTruck } from '@fortawesome/free-solid-svg-icons'
import { SelectionModel } from '@angular/cdk/collections'
import { MatIconModule } from '@angular/material/icon'
import { MatButtonModule } from '@angular/material/button'
import { ExtendedModule } from '@angular/flex-layout/extended'
import { MatRadioButton } from '@angular/material/radio'
import { FlexModule } from '@angular/flex-layout/flex'
import { MatDivider } from '@angular/material/divider'
import { TranslateModule } from '@ngx-translate/core'
import { MatCardModule } from '@angular/material/card'

library.add(faRocket, faShippingFast, faTruck)

@Component({
  selector: 'app-delivery-method',
  templateUrl: './delivery-method.component.html',
  styleUrls: ['./delivery-method.component.scss'],
  imports: [MatCardModule, NgIf, TranslateModule, MatDivider, MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell, FlexModule, MatCellDef, MatCell, MatRadioButton, NgClass, ExtendedModule, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow, MatButtonModule, MatIconModule]
})
export class DeliveryMethodComponent implements OnInit {
  public displayedColumns = ['Selection', 'Name', 'Price', 'ETA']
  public methods: DeliveryMethod[]
  public address: any
  public dataSource
  public deliveryMethodId: number = undefined
  selection = new SelectionModel<DeliveryMethod>(false, [])

  constructor (private readonly location: Location, private readonly deliverySerivce: DeliveryService,
    private readonly addressService: AddressService, private readonly router: Router, private readonly ngZone: NgZone) { }

  ngOnInit (): void {
    this.addressService.getById(sessionStorage.getItem('addressId')).subscribe((address) => {
      this.address = address
    }, (error) => { console.log(error) })

    this.deliverySerivce.get().subscribe((methods) => {
      console.log(methods)
      this.methods = methods
      this.dataSource = new MatTableDataSource<DeliveryMethod>(this.methods)
    }, (error) => { console.log(error) })
  }

  selectMethod (id) {
    if (this.selection.hasValue() || id) {
      this.deliveryMethodId = id
    } else {
      this.deliveryMethodId = undefined
    }
  }

  routeToPreviousUrl () {
    this.location.back()
  }

  chooseDeliveryMethod () {
    sessionStorage.setItem('deliveryMethodId', this.deliveryMethodId.toString())
    this.ngZone.run(async () => await this.router.navigate(['/payment', 'shop']))
  }
}


/* ===== FILE: ./frontend/src/app/delivery-method/delivery-method.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateModule } from '@ngx-translate/core'
import { MatInputModule } from '@angular/material/input'
import { type ComponentFixture, fakeAsync, TestBed, waitForAsync } from '@angular/core/testing'
import { MatCardModule } from '@angular/material/card'
import { MatTableModule } from '@angular/material/table'
import { MatButtonModule } from '@angular/material/button'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { ReactiveFormsModule } from '@angular/forms'
import { MatButtonToggleModule } from '@angular/material/button-toggle'
import { RouterTestingModule } from '@angular/router/testing'
import { AddressService } from '../Services/address.service'
import { of } from 'rxjs/internal/observable/of'
import { throwError } from 'rxjs'
import { MatIconModule } from '@angular/material/icon'
import { MatTooltipModule } from '@angular/material/tooltip'
import { DeliveryService } from '../Services/delivery.service'
import { DeliveryMethodComponent } from './delivery-method.component'
import { PaymentComponent } from '../payment/payment.component'
import { PaymentMethodComponent } from '../payment-method/payment-method.component'
import { MatRadioModule } from '@angular/material/radio'
import { MatExpansionModule } from '@angular/material/expansion'
import { MatDividerModule } from '@angular/material/divider'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('DeliveryMethodComponent', () => {
  let component: DeliveryMethodComponent
  let fixture: ComponentFixture<DeliveryMethodComponent>
  let addressService: any
  let deliveryService: any

  beforeEach(waitForAsync(() => {
    addressService = jasmine.createSpyObj('AddressService', ['getById'])
    addressService.getById.and.returnValue(of([]))
    deliveryService = jasmine.createSpyObj('DeliveryService', ['get'])
    deliveryService.get.and.returnValue(of([]))

    TestBed.configureTestingModule({
      imports: [RouterTestingModule.withRoutes([
        { path: 'payment/shop', component: PaymentComponent }
      ]),
      TranslateModule.forRoot(),
      BrowserAnimationsModule,
      ReactiveFormsModule,
      MatInputModule,
      MatCardModule,
      MatTableModule,
      MatButtonModule,
      MatButtonToggleModule,
      MatIconModule,
      MatTooltipModule,
      MatRadioModule,
      MatExpansionModule,
      MatDividerModule,
      DeliveryMethodComponent, PaymentComponent, PaymentMethodComponent],
      providers: [
        { provide: AddressService, useValue: addressService },
        { provide: DeliveryService, useValue: deliveryService },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(DeliveryMethodComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should log errors from address service directly to browser console', fakeAsync(() => {
    addressService.getById.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.ngOnInit()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should log errors from delivery service directly to browser console', fakeAsync(() => {
    deliveryService.get.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.ngOnInit()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should hold address on ngOnInit', () => {
    addressService.getById.and.returnValue(of({ address: 'address' }))
    component.ngOnInit()
    expect(component.address).toEqual({ address: 'address' })
  })

  it('should hold delivery methods on ngOnInit', () => {
    deliveryService.get.and.returnValue(of([{ id: 1, name: '1', price: 1, eta: 1, icon: '1' }]))
    component.ngOnInit()
    expect(component.methods[0].id).toEqual(1)
    expect(component.methods[0].name).toEqual('1')
    expect(component.methods[0].price).toEqual(1)
    expect(component.methods[0].eta).toEqual(1)
    expect(component.methods[0].icon).toEqual('1')
  })

  it('should store delivery method id on selectMethod', () => {
    component.selectMethod(1)
    expect(component.deliveryMethodId).toBe(1)
  })

  it('should store address id in session storage', () => {
    component.deliveryMethodId = 1
    spyOn(sessionStorage, 'setItem')
    component.chooseDeliveryMethod()
    expect(sessionStorage.setItem).toHaveBeenCalledWith('deliveryMethodId', '1')
  })
})


/* ===== FILE: ./frontend/src/app/sidenav/sidenav.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<mat-toolbar class="mat-elevation-z6" color="primary">
  <mat-toolbar-row>
    <h2> {{applicationName}}</h2>
  </mat-toolbar-row>
</mat-toolbar>

<mat-nav-list>

  <button mat-button style="height: 0; position: absolute;">
    <!-- 'absorbs' the auto-focus behavior -->
  </button>
  <h3 mat-subheader class="side-subHeader" translate fxHide fxShow.lt-md>ACCOUNT</h3>

  <div fxHide fxShow.lt-md>
    <a mat-list-item *ngIf="!isLoggedIn()" routerLink="/login" (click)="onToggleSidenav();"
       aria-label="Go to login page">
      <mat-icon>
        exit_to_app
      </mat-icon>
      <span class="menu-text truncate">
        {{"TITLE_LOGIN" | translate }}
      </span>
    </a>
    <a mat-list-item *ngIf="isLoggedIn()" (click)="onToggleSidenav(); goToProfilePage();"
       aria-label="Go to user profile">
      <mat-icon>
        account_circle
      </mat-icon>
      <span class="menu-text truncate">
        {{ userEmail }}
      </span>
    </a>
    <a mat-list-item *ngIf="isLoggedIn() && isAccounting()" routerLink="/accounting" (click)="onToggleSidenav();" aria-label="Go to accounting page">
      <mat-icon>
        account_balance
      </mat-icon>
      <span class="menu-text truncate">
        {{"ACCOUNTING" | translate }}
      </span>
    </a>

    <mat-list-item *ngIf="isLoggedIn()" (click)="showOrdersSubmenu = !showOrdersSubmenu" class="parent"
                   aria-label="Show Orders and Payment Menu">
      <mat-icon>
        check_circle_outline
      </mat-icon>
      <span class="menu-text truncate">
        {{ "ORDERS_AND_PAYMENT" | translate }}
      </span>
      <mat-icon class="menu-button" [ngClass]="{'rotated' : showOrdersSubmenu}">
        expand_more
      </mat-icon>
    </mat-list-item>
    <div class="submenu" [ngClass]="{'expanded' : showOrdersSubmenu}" *ngIf="showOrdersSubmenu">
      <a mat-list-item *ngIf="isLoggedIn()" routerLink="/order-history"
         (click)="onToggleSidenav(); showOrdersSubmenu = !showOrdersSubmenu" aria-label="Go to order history page">
        <mat-icon>
          archive
        </mat-icon>
        <span class="menu-text truncate">
        {{"LABEL_ORDER_HISTORY" | translate}}
      </span>
      </a>
      <a mat-list-item *ngIf="isLoggedIn()" routerLink="/recycle"
         (click)="onToggleSidenav(); showOrdersSubmenu = !showOrdersSubmenu" aria-label="Go to recycling page">
        <mat-icon>
          autorenew
        </mat-icon>
        <span class="menu-text truncate">
        {{"NAV_RECYCLE" | translate}}
      </span>
      </a>
      <mat-divider></mat-divider>
      <a mat-list-item *ngIf="isLoggedIn()" routerLink="/address/saved"
         (click)="onToggleSidenav(); showOrdersSubmenu = !showOrdersSubmenu" aria-label="Go to saved address page">
        <mat-icon>
          my_location
        </mat-icon>
        <span class="menu-text truncate">
        {{"MY_SAVED_ADRESSES" | translate}}
      </span>
      </a>
      <a mat-list-item *ngIf="isLoggedIn()" routerLink="/saved-payment-methods"
         (click)="onToggleSidenav(); showOrdersSubmenu = !showOrdersSubmenu" aria-label="Go to saved payment methods page">
        <mat-icon>
          credit_card
        </mat-icon>
        <span class="menu-text truncate">
        {{"MY_PAYMENT_OPTIONS" | translate}}
      </span>
      </a>
      <a mat-list-item *ngIf="isLoggedIn()" routerLink="/wallet"
         (click)="onToggleSidenav(); showOrdersSubmenu = !showOrdersSubmenu" aria-label="Go to wallet page">
        <mat-icon>
          account_balance_wallet
        </mat-icon>
        <span class="menu-text truncate">
        {{"DIGITAL_WALLET" | translate}}
      </span>
      </a>
    </div>

    <mat-list-item *ngIf="isLoggedIn()" (click)="showPrivacySubmenu = !showPrivacySubmenu" class="parent"
                   aria-label="Show Privacy and Security Menu">
      <mat-icon>
        security
      </mat-icon>
      <span class="menu-text truncate">
        {{ "PRIVACY_AND_SECURITY" | translate }}
      </span>
      <mat-icon class="menu-button" [ngClass]="{'rotated' : showPrivacySubmenu}">
        expand_more
      </mat-icon>
    </mat-list-item>
    <div class="submenu" [ngClass]="{'expanded' : showPrivacySubmenu}" *ngIf="showPrivacySubmenu">
      <a mat-list-item *ngIf="isLoggedIn()" routerLink="privacy-security/privacy-policy"
         (click)="onToggleSidenav(); showPrivacySubmenu = !showPrivacySubmenu" aria-label="Go to privacy policy page">
        <mat-icon>
          assignment
        </mat-icon>
        <span class="menu-text truncate" translate>TITLE_PRIVACY_POLICY</span>
      </a>
      <a mat-list-item *ngIf="isLoggedIn()" routerLink="privacy-security/data-export"
         (click)="onToggleSidenav(); showPrivacySubmenu = !showPrivacySubmenu" aria-label="Go to data export page">
        <mat-icon>
          get_app
        </mat-icon>
        <span class="menu-text truncate" translate>TITLE_REQUEST_DATA_EXPORT</span>
      </a>
      <a mat-list-item *ngIf="isLoggedIn()" (click) = "goToDataErasurePage()"
         (click)="onToggleSidenav(); showPrivacySubmenu = !showPrivacySubmenu" aria-label="Go to data subject page">
        <mat-icon>
          delete_forever
        </mat-icon>
        <span class="menu-text truncate" translate>DATA_SUBJECT_TITLE</span>
      </a>
      <mat-divider></mat-divider>
      <a mat-list-item *ngIf="isLoggedIn()" routerLink="privacy-security/change-password"
         (click)="onToggleSidenav(); showPrivacySubmenu = !showPrivacySubmenu" aria-label="Go to change password page">
        <mat-icon>
          edit
        </mat-icon>
        <span class="menu-text truncate" translate>TITLE_CHANGE_PASSWORD</span>
      </a>
      <a mat-list-item *ngIf="isLoggedIn()" routerLink="privacy-security/two-factor-authentication"
         (click)="onToggleSidenav(); showPrivacySubmenu = !showPrivacySubmenu" aria-label="Go to two factor authentication page">
        <mat-icon>
          exposure_plus_2
        </mat-icon>
        <span class="menu-text truncate" translate>TITLE_TWO_FACTOR_AUTH_CONFIG</span>
      </a>
      <a mat-list-item *ngIf="isLoggedIn()" routerLink="privacy-security/last-login-ip"
         (click)="onToggleSidenav(); showPrivacySubmenu = !showPrivacySubmenu" aria-label="Go to last login ip page">
        <mat-icon>
          place
        </mat-icon>
        <span class="menu-text truncate" translate>LAST_LOGIN_IP</span>
      </a>
    </div>

    <a mat-list-item *ngIf="isLoggedIn()" (click)="onToggleSidenav(); logout()" aria-label="Logout">
      <mat-icon>
        power_settings_new
      </mat-icon>
      <span class="menu-text truncate">
        {{"TITLE_LOGOUT" | translate }}
      </span>
    </a>
  </div>

  <mat-divider fxHide fxShow.lt-md></mat-divider>

  <h3 mat-subheader class="side-subHeader" translate>TITLE_CONTACT</h3>
  <a mat-list-item routerLink="/contact" (click)="onToggleSidenav();" aria-label="Go to contact us page">
    <mat-icon>feedback</mat-icon>
    <span class="menu-text truncate">
      {{"SECTION_CUSTOMER_FEEDBACK" | translate}}
    </span>
  </a>
  <a mat-list-item *ngIf="isLoggedIn()" routerLink="/complain" (click)="onToggleSidenav();"
     aria-label="Go to complain page">
    <mat-icon>sentiment_dissatisfied</mat-icon>
    <span class="menu-text truncate">
      {{"NAV_COMPLAIN" | translate}}
    </span>
  </a>
  <a mat-list-item *ngIf="isLoggedIn()" routerLink="/chatbot" (click)="onToggleSidenav();"
     aria-label="Go to chatbot page">
     <mat-icon>chat</mat-icon>
    <span class="menu-text truncate">
      {{"SECTION_SUPPORT_CHAT" | translate}}
    </span>
  </a>

  <mat-divider></mat-divider>

  <h3 mat-subheader class="side-subHeader" translate>COMPANY</h3>
  <a mat-list-item routerLink="/about" (click)="onToggleSidenav()" aria-label="Go to about us page">
    <mat-icon>business_center</mat-icon>
    <span class="menu-text truncate">
      {{"TITLE_ABOUT" | translate}}
    </span>
  </a>
  <a mat-list-item routerLink="/photo-wall" (click)="onToggleSidenav()" aria-label="Go to photo wall">
    <mat-icon>camera</mat-icon>
    <span class="menu-text truncate">
      {{"LABEL_PHOTO_WALL" | translate}}
    </span>
  </a>
  <a mat-list-item *ngIf="isLoggedIn()" routerLink="/deluxe-membership" (click)="onToggleSidenav()" aria-label="Go to deluxe membership page">
    <mat-icon>card_membership</mat-icon>
    <span class="menu-text truncate">
      {{"LABEL_DELUXE_MEMBERSHIP" | translate}}
    </span>
  </a>

  <mat-divider *ngIf="scoreBoardVisible || showGitHubLink" style="margin-bottom: 10px;"></mat-divider>

  <a *ngIf="scoreBoardVisible" mat-list-item routerLink="/score-board" (click)="onToggleSidenav()"
     aria-label="Open score-board">
    <mat-icon matListIcon class="fas fa-trophy fa-lg"></mat-icon>
    <span class="menu-text truncate">
      {{"TITLE_SCORE_BOARD" | translate}}
    </span>
  </a>
  <a *ngIf="!scoreBoardVisible && offerScoreBoardTutorial" mat-list-item (click)="startHackingInstructor()"
     aria-label="Launch beginners tutorial">
    <mat-icon>school</mat-icon>
    <span class="menu-text truncate">
      {{"BTN_GETTING_STARTED" | translate}}
    </span>
  </a>

  <a *ngIf="showGitHubLink" mat-list-item href="./redirect?to=https://github.com/juice-shop/juice-shop"
     aria-label="Go to OWASP Juice Shop GitHub page">
    <mat-icon matListIcon class="fab fa-github fa-lg"></mat-icon>
    <span class="menu-text truncate">
      GitHub
    </span>
  </a>
</mat-nav-list>

<div class="appVersion">
    <span>
      <span style="font-size: 13px;">{{applicationName}}</span>
      <br>
      <span style="font-size: 12px;">{{version}}</span>
      <br>
      <div style="margin-top: 10px;">
        <i class="icon-angular"></i>&nbsp;
        <i class="icon-html5"></i>&nbsp;
        <i class="icon-sass"></i>&nbsp;
        <i class="icon-css3"></i>&nbsp;
        <i class="icon-javascript-alt"></i>&nbsp;
        <i class="icon-nodejs"></i>&nbsp;
        <i class="icon-database-alt2"></i>&nbsp;
        <i class="icon-mongodb"></i>
      </div>
    </span>
</div>


/* ===== FILE: ./frontend/src/app/sidenav/sidenav.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { ChallengeService } from '../Services/challenge.service'
import { type ComponentFixture, fakeAsync, TestBed, tick, waitForAsync } from '@angular/core/testing'
import { SocketIoService } from '../Services/socket-io.service'
import { ConfigurationService } from '../Services/configuration.service'
import { TranslateModule, TranslateService } from '@ngx-translate/core'
import { RouterTestingModule } from '@angular/router/testing'
import { of } from 'rxjs'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'
import { CookieModule, CookieService } from 'ngy-cookie'
import { LoginGuard } from '../app.guard'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'
import { SidenavComponent } from './sidenav.component'
import { MatToolbarModule } from '@angular/material/toolbar'
import { MatIconModule } from '@angular/material/icon'
import { MatButtonModule } from '@angular/material/button'
import { MatMenuModule } from '@angular/material/menu'
import { MatListModule } from '@angular/material/list'
import { roles } from '../roles'
import { AdministrationService } from '../Services/administration.service'
import { UserService } from '../Services/user.service'
import { Location } from '@angular/common'

class MockSocket {
  on (str: string, callback: any) {
    callback(str)
  }
}

describe('SidenavComponent', () => {
  let component: SidenavComponent
  let fixture: ComponentFixture<SidenavComponent>
  let challengeService: any
  let cookieService: any
  let configurationService: any
  let userService: any
  let administractionService: any
  let mockSocket: any
  let socketIoService: any
  let loginGuard
  let location: Location

  beforeEach(waitForAsync(() => {
    configurationService = jasmine.createSpyObj('ConfigurationService', ['getApplicationConfiguration'])
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { welcomeBanner: {} }, hackingInstructor: {} }))
    challengeService = jasmine.createSpyObj('ChallengeService', ['find'])
    challengeService.find.and.returnValue(of([{ solved: false }]))
    userService = jasmine.createSpyObj('UserService', ['whoAmI', 'getLoggedInState', 'saveLastLoginIp'])
    userService.whoAmI.and.returnValue(of({}))
    userService.getLoggedInState.and.returnValue(of(true))
    userService.saveLastLoginIp.and.returnValue(of({}))
    userService.isLoggedIn = jasmine.createSpyObj('userService.isLoggedIn', ['next'])
    userService.isLoggedIn.next.and.returnValue({})
    administractionService = jasmine.createSpyObj('AdministrationService', ['getApplicationVersion'])
    administractionService.getApplicationVersion.and.returnValue(of(null))
    cookieService = jasmine.createSpyObj('CookieService', ['remove', 'get', 'put'])
    mockSocket = new MockSocket()
    socketIoService = jasmine.createSpyObj('SocketIoService', ['socket'])
    socketIoService.socket.and.returnValue(mockSocket)
    loginGuard = jasmine.createSpyObj('LoginGuard', ['tokenDecode'])
    loginGuard.tokenDecode.and.returnValue({})

    TestBed.configureTestingModule({
      imports: [TranslateModule.forRoot(),
        BrowserAnimationsModule,
        MatToolbarModule,
        MatIconModule,
        MatButtonModule,
        MatMenuModule,
        MatListModule,
        CookieModule.forRoot(),
        RouterTestingModule,
        SidenavComponent],
      providers: [
        { provide: ConfigurationService, useValue: configurationService },
        { provide: ChallengeService, useValue: challengeService },
        { provide: UserService, useValue: userService },
        { provide: AdministrationService, useValue: administractionService },
        { provide: CookieService, useValue: cookieService },
        { provide: SocketIoService, useValue: socketIoService },
        { provide: LoginGuard, useValue: loginGuard },
        TranslateService,
        provideHttpClient(withInterceptorsFromDi())
      ]
    })
      .compileComponents()
    location = TestBed.inject(Location)
    TestBed.inject(TranslateService)
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(SidenavComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should show accounting functionality when user has according role', () => {
    loginGuard.tokenDecode.and.returnValue({ data: { role: roles.accounting } })

    expect(component.isAccounting()).toBe(true)
  })

  it('should set version number as retrieved with "v" prefix', () => {
    loginGuard.tokenDecode.and.returnValue({ data: { role: roles.accounting } })

    expect(component.isAccounting()).toBe(true)
  })

  it('should not show accounting functionality when user lacks according role', () => {
    administractionService.getApplicationVersion.and.returnValue(of('1.2.3'))
    component.ngOnInit()

    expect(component.version).toBe('v1.2.3')
  })

  it('should hide Score Board link when Score Board was not discovered yet', () => {
    challengeService.find.and.returnValue(of([{ name: 'Score Board', solved: false }]))
    component.getScoreBoardStatus()

    expect(component.scoreBoardVisible).toBe(false)
  })

  it('should show Score Board link when Score Board was already discovered', () => {
    challengeService.find.and.returnValue(of([{ name: 'Score Board', solved: true }]))
    component.getScoreBoardStatus()

    expect(component.scoreBoardVisible).toBe(true)
  })

  it('should remove authentication token from localStorage', () => {
    spyOn(localStorage, 'removeItem')
    component.logout()
    expect(localStorage.removeItem).toHaveBeenCalledWith('token')
  })

  it('should remove authentication token from cookies', () => {
    component.logout()
    expect(cookieService.remove).toHaveBeenCalledWith('token')
  })

  it('should remove basket id from session storage', () => {
    spyOn(sessionStorage, 'removeItem')
    component.logout()
    expect(sessionStorage.removeItem).toHaveBeenCalledWith('bid')
  })

  it('should remove basket item total from session storage', () => {
    spyOn(sessionStorage, 'removeItem')
    component.logout()
    expect(sessionStorage.removeItem).toHaveBeenCalledWith('itemTotal')
  })

  it('should set the login status to be false via UserService', () => {
    component.logout()
    expect(userService.isLoggedIn.next).toHaveBeenCalledWith(false)
  })

  it('should save the last login IP address', () => {
    component.logout()
    expect(userService.saveLastLoginIp).toHaveBeenCalled()
  })

  it('should forward to main page', fakeAsync(() => {
    component.logout()
    tick()
    expect(location.path()).toBe('/')
  }))
})


/* ===== FILE: ./frontend/src/app/sidenav/sidenav.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { environment } from '../../environments/environment'
import { ChallengeService } from '../Services/challenge.service'
import { Component, EventEmitter, NgZone, type OnInit, Output } from '@angular/core'
import { SocketIoService } from '../Services/socket-io.service'
import { AdministrationService } from '../Services/administration.service'
import { Router, RouterLink } from '@angular/router'
import { UserService } from '../Services/user.service'
import { CookieService } from 'ngy-cookie'
import { ConfigurationService } from '../Services/configuration.service'
import { LoginGuard } from '../app.guard'
import { roles } from '../roles'
import { MatDivider } from '@angular/material/divider'
import { MatIconModule } from '@angular/material/icon'
import { NgIf, NgClass } from '@angular/common'
import { ExtendedModule } from '@angular/flex-layout/extended'
import { TranslateModule } from '@ngx-translate/core'
import { MatButtonModule } from '@angular/material/button'
import { MatNavList, MatListSubheaderCssMatStyler, MatListItem } from '@angular/material/list'
import { MatToolbar, MatToolbarRow } from '@angular/material/toolbar'

@Component({
  selector: 'sidenav',
  templateUrl: './sidenav.component.html',
  styleUrls: ['./sidenav.component.scss'],
  imports: [MatToolbar, MatToolbarRow, MatNavList, MatButtonModule, MatListSubheaderCssMatStyler, TranslateModule, ExtendedModule, NgIf, MatListItem, RouterLink, MatIconModule, NgClass, MatDivider]
})
export class SidenavComponent implements OnInit {
  public applicationName = 'OWASP Juice Shop'
  public showGitHubLink = true
  public userEmail = ''
  public scoreBoardVisible: boolean = false
  public version: string = ''
  public showPrivacySubmenu: boolean = false
  public showOrdersSubmenu: boolean = false
  public isShowing = false
  public offerScoreBoardTutorial: boolean = false
  @Output() public sidenavToggle = new EventEmitter()

  constructor (private readonly administrationService: AdministrationService, private readonly challengeService: ChallengeService,
    private readonly ngZone: NgZone, private readonly io: SocketIoService, private readonly userService: UserService, private readonly cookieService: CookieService,
    private readonly router: Router, private readonly configurationService: ConfigurationService, private readonly loginGuard: LoginGuard) { }

  ngOnInit (): void {
    this.administrationService.getApplicationVersion().subscribe((version: any) => {
      if (version) {
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        this.version = `v${version}`
      }
    }, (err) => { console.log(err) })
    this.getApplicationDetails()
    this.getScoreBoardStatus()

    if (localStorage.getItem('token')) {
      this.getUserDetails()
    } else {
      this.userEmail = ''
    }

    this.userService.getLoggedInState().subscribe((isLoggedIn) => {
      if (isLoggedIn) {
        this.getUserDetails()
      } else {
        this.userEmail = ''
      }
    })
    this.ngZone.runOutsideAngular(() => {
      this.io.socket().on('challenge solved', (challenge) => {
        if (challenge.key === 'scoreBoardChallenge') {
          this.scoreBoardVisible = true
        }
      })
    })
  }

  isLoggedIn () {
    return localStorage.getItem('token')
  }

  logout () {
    this.userService.saveLastLoginIp().subscribe((user: any) => { this.noop() }, (err) => { console.log(err) })
    localStorage.removeItem('token')
    this.cookieService.remove('token')
    sessionStorage.removeItem('bid')
    sessionStorage.removeItem('itemTotal')
    this.userService.isLoggedIn.next(false)
    this.ngZone.run(async () => await this.router.navigate(['/']))
  }

  goToProfilePage () {
    window.location.replace(environment.hostServer + '/profile')
  }

  goToDataErasurePage () {
    window.location.replace(environment.hostServer + '/dataerasure')
  }

  // eslint-disable-next-line no-empty,@typescript-eslint/no-empty-function
  noop () { }

  getScoreBoardStatus () {
    this.challengeService.find({ name: 'Score Board' }).subscribe((challenges: any) => {
      this.ngZone.run(() => {
        this.scoreBoardVisible = challenges[0].solved
      })
    }, (err) => { console.log(err) })
  }

  getUserDetails () {
    this.userService.whoAmI().subscribe((user: any) => {
      this.userEmail = user.email
    }, (err) => { console.log(err) })
  }

  onToggleSidenav = () => {
    this.sidenavToggle.emit()
  }

  getApplicationDetails () {
    this.configurationService.getApplicationConfiguration().subscribe((config: any) => {
      if (config?.application?.name) {
        this.applicationName = config.application.name
      }
      if (config?.application) {
        this.showGitHubLink = config.application.showGitHubLinks
      }
      if (config?.application.welcomeBanner.showOnFirstStart && config.hackingInstructor.isEnabled) {
        this.offerScoreBoardTutorial = config.application.welcomeBanner.showOnFirstStart && config.hackingInstructor.isEnabled
      }
    }, (err) => { console.log(err) })
  }

  isAccounting () {
    const payload = this.loginGuard.tokenDecode()
    return payload?.data?.role === roles.accounting
  }

  startHackingInstructor () {
    this.onToggleSidenav()
    console.log('Starting instructions for challenge "Score Board"')
    import(/* webpackChunkName: "tutorial" */ '../../hacking-instructor').then(module => {
      module.startHackingInstructorFor('Score Board')
    })
  }
}


/* ===== FILE: ./frontend/src/app/contact/contact.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateModule, TranslateService } from '@ngx-translate/core'
import { CaptchaService } from '../Services/captcha.service'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { UserService } from '../Services/user.service'
import { MatCardModule } from '@angular/material/card'
import { MatFormFieldModule } from '@angular/material/form-field'
import { type ComponentFixture, fakeAsync, TestBed, waitForAsync } from '@angular/core/testing'
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar'
import { EventEmitter } from '@angular/core'
import { ContactComponent } from './contact.component'
import { MatInputModule } from '@angular/material/input'
import { ReactiveFormsModule } from '@angular/forms'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'
import { FeedbackService } from '../Services/feedback.service'
import { MatSliderModule } from '@angular/material/slider'
import { of, throwError } from 'rxjs'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('ContactComponent', () => {
  let component: ContactComponent
  let fixture: ComponentFixture<ContactComponent>
  let userService: any
  let feedbackService: any
  let captchaService: any
  let snackBar: any
  let translateService

  beforeEach(waitForAsync(() => {
    translateService = jasmine.createSpyObj('TranslateService', ['get'])
    translateService.get.and.returnValue(of({}))
    translateService.onLangChange = new EventEmitter()
    translateService.onTranslationChange = new EventEmitter()
    translateService.onDefaultLangChange = new EventEmitter()
    userService = jasmine.createSpyObj('UserService', ['whoAmI'])
    userService.whoAmI.and.returnValue(of({}))
    snackBar = jasmine.createSpyObj('MatSnackBar', ['open'])
    feedbackService = jasmine.createSpyObj('FeedbackService', ['save'])
    feedbackService.save.and.returnValue(of({}))
    captchaService = jasmine.createSpyObj('CaptchaService', ['getCaptcha'])
    captchaService.getCaptcha.and.returnValue(of({}))

    TestBed.configureTestingModule({
      imports: [TranslateModule.forRoot(),
        ReactiveFormsModule,
        MatSliderModule,
        BrowserAnimationsModule,
        MatCardModule,
        MatFormFieldModule,
        MatInputModule,
        MatSnackBarModule,
        ContactComponent],
      providers: [
        { provide: UserService, useValue: userService },
        { provide: MatSnackBar, useValue: snackBar },
        { provide: FeedbackService, useValue: feedbackService },
        { provide: CaptchaService, useValue: captchaService },
        { provide: TranslateService, useValue: translateService },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(ContactComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should reinitizalise forms by calling resetForm', () => {
    component.feedbackControl.setValue('feedback')
    component.captchaControl.setValue('captcha')
    component.authorControl.setValue('author')
    component.resetForm()
    expect(component.feedbackControl.value).toBe('')
    expect(component.feedbackControl.pristine).toBe(true)
    expect(component.feedbackControl.untouched).toBe(true)
    expect(component.captchaControl.value).toBe('')
    expect(component.captchaControl.pristine).toBe(true)
    expect(component.captchaControl.untouched).toBe(true)
    expect(component.authorControl.value).toBe('')
    expect(component.authorControl.pristine).toBe(true)
    expect(component.authorControl.untouched).toBe(true)
  })

  it('author formControl should be disabled', () => {
    expect(component.authorControl.disabled).toBe(true)
  })

  it('should be compulsory to provide feedback', () => {
    component.feedbackControl.setValue('')
    expect(component.feedbackControl.valid).toBeFalsy()
  })

  it('feedback should not be more than 160 characters', () => {
    let str: string = ''
    for (let i = 0; i < 161; ++i) {
      str += 'a'
    }
    component.feedbackControl.setValue(str)
    expect(component.feedbackControl.valid).toBeFalsy()
    str = str.slice(1)
    component.feedbackControl.setValue(str)
    expect(component.feedbackControl.valid).toBe(true)
  })

  it('should be compulsory to answer the captcha', () => {
    component.captchaControl.setValue('')
    expect(component.captchaControl.valid).toBeFalsy()
    component.captchaControl.setValue('1')
    expect(component.captchaControl.valid).toBe(true)
  })

  it('should store the captcha and the captchaId on getting new captcha', () => {
    captchaService.getCaptcha.and.returnValue(of({ captcha: 'captcha', captchaId: 2 }))
    component.getNewCaptcha()
    expect(component.captcha).toBe('captcha')
    expect(component.captchaId).toBe(2)
  })

  it('should hold the user id of the currently logged in user', () => {
    userService.whoAmI.and.returnValue(of({ id: 42 }))
    component.ngOnInit()
    expect(component.userIdControl.value).toBe(42)
  })

  it('should hold no user id if current user is not logged in', fakeAsync(() => {
    userService.whoAmI.and.returnValue(throwError('Error'))
    component.ngOnInit()
    expect(component.userIdControl.value).toBeUndefined()
  }))

  it('should miss feedback object if retrieving currently logged in user fails', fakeAsync(() => {
    userService.whoAmI.and.returnValue(throwError('Error'))
    component.ngOnInit()
    expect(component.feedback).toBeUndefined()
  }))

  it('should log the error if retrieving currently logged in user fails', fakeAsync(() => {
    userService.whoAmI.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.ngOnInit()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should hold the anonymized email of the currently logged in user', () => {
    userService.whoAmI.and.returnValue(of({ email: 'xxxx@x.xx' }))
    component.ngOnInit()
    expect(component.authorControl.value).toBe('***x@x.xx')
  })

  it('should hold anonymous placeholder for email if current user is not logged in', () => {
    userService.whoAmI.and.returnValue(of({ user: {} }))
    component.ngOnInit()
    expect(component.authorControl.value).toBe('anonymous')
  })

  it('should populate the feedback object and send it via the feedback service on saving', () => {
    component.captchaId = 2
    component.captchaControl.setValue('2')
    component.feedbackControl.setValue('feedback')
    component.rating = 5
    component.userIdControl.setValue('2')
    component.save()
    expect(feedbackService.save).toHaveBeenCalledWith({ captchaId: 2, captcha: '2', comment: 'feedback (anonymous)', rating: 5, UserId: '2' })
  })

  it('should display thank-you message and reset feedback form on saving feedback', () => {
    feedbackService.save.and.returnValue(of({ rating: 4 }))
    spyOn(component, 'resetForm')
    spyOn(component, 'ngOnInit')
    component.save()
    expect(snackBar.open).toHaveBeenCalled()
    expect(component.ngOnInit).toHaveBeenCalled()
    expect(component.resetForm).toHaveBeenCalled()
  })

  it('should display 5-star thank-you message and reset feedback form on saving 5-star feedback', () => {
    feedbackService.save.and.returnValue(of({ rating: 5 }))
    spyOn(component, 'resetForm')
    spyOn(component, 'ngOnInit')
    component.save()
    expect(snackBar.open).toHaveBeenCalled()
    expect(component.ngOnInit).toHaveBeenCalled()
    expect(component.resetForm).toHaveBeenCalled()
  })

  it('should clear the form display error if saving feedback fails', fakeAsync(() => {
    feedbackService.save.and.returnValue(throwError({ error: 'Error' }))
    spyOn(component, 'resetCaptcha')
    component.save()
    expect(snackBar.open).toHaveBeenCalled()
    expect(component.resetCaptcha).toHaveBeenCalled()
  }))

  it('should clear the feedback object if saving feedback fails', fakeAsync(() => {
    feedbackService.save.and.returnValue(throwError({ error: 'Error' }))
    component.save()
    expect(component.feedback).toEqual({})
  }))
})


/* ===== FILE: ./frontend/src/app/contact/contact.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<div fxLayoutAlign="center">
  <mat-card appearance="outlined" class="mat-elevation-z6">
    <div class="mdc-card">
      <h1 translate>SECTION_CUSTOMER_FEEDBACK</h1>

      <div class="form-container" id="feedback-form">

        <input hidden type="text" id="userId" ngDefaultControl [formControl]="userIdControl"/>

        <mat-form-field appearance="outline" color="accent">
          <mat-label translate>LABEL_AUTHOR</mat-label>
          <input ngDefaultControl [formControl]="authorControl" matInput type="text" aria-label="Field with the name of the author">
        </mat-form-field>

        <mat-form-field appearance="outline" color="accent">
          <mat-label translate>LABEL_COMMENT</mat-label>
          <mat-hint translate>
            <i class="fas fa-exclamation-circle"></i>
            <em style="margin-left:5px;" translate>{{ 'MAX_TEXTAREA_LENGTH' | translate: {length: '160'} }}</em>
          </mat-hint>
          <textarea #comment id="comment" ngDefaultControl [formControl]="feedbackControl" matInput
                    matAutosizeMinRows="4" matAutosizeMaxRows="4" matTextareaAutosize cols="50" maxlength="160"
                    placeholder="{{ 'WRITE_REVIEW_PLACEHOLDER' | translate}}"
                    aria-label="Field for entering the comment or the feedback"></textarea>
          <mat-hint align="end">{{comment.value?.length || 0}}/160</mat-hint>
          <mat-error *ngIf="feedbackControl.invalid && feedbackControl.errors.required" translate>MANDATORY_COMMENT
          </mat-error>
        </mat-form-field>

        <div class="rating-container">
          <label style="font-weight:500; margin-right: 8px; float:left;" translate>LABEL_RATING</label>
          <mat-slider id="rating" min="1" max="5" step="1" showTickMarks discrete [displayWith]="formatRating" aria-label="Slider for selecting the star rating">
            <input matSliderThumb [(ngModel)]="rating" />
          </mat-slider>
        </div>

        <div style="margin-bottom: 10px; margin-top: 10px; ">
          <label style="font-weight:500;">CAPTCHA:</label>&nbsp;&nbsp;<span style="font-size:small;"
                                                                            translate>LABEL_WHAT_IS</span>&nbsp;
          <code id="captcha" aria-label="CAPTCHA code which must be solved">{{captcha}}</code>&nbsp;<label
          style="font-size:small;">?</label>
        </div>
        <mat-form-field appearance="outline" color="accent">
          <mat-label translate>LABEL_RESULT</mat-label>
          <input id="captchaControl" ngDefaultControl [formControl]="captchaControl" matInput type="text"
                placeholder="{{ 'MANDATORY_CAPTCHA' | translate}}"
                aria-label="Field for the result of the CAPTCHA code" pattern="-?[\d]*">
          <mat-error *ngIf="captchaControl.invalid && captchaControl.errors.required" translate>MANDATORY_CAPTCHA
          </mat-error>
          <mat-error *ngIf="captchaControl.invalid && captchaControl.errors.pattern" translate>INVALID_CAPTCHA
          </mat-error>
        </mat-form-field>

      </div>

      <button type="submit" id="submitButton" mat-raised-button color="primary"
              [disabled]="authorControl.invalid || feedbackControl.invalid || captchaControl.invalid || !rating"
              (click)="save()" aria-label="Button to send the review">
        <mat-icon>send</mat-icon>
        {{'BTN_SUBMIT' | translate}}
      </button>
    </div>
  </mat-card>
</div>


/* ===== FILE: ./frontend/src/app/contact/contact.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { FeedbackService } from '../Services/feedback.service'
import { CaptchaService } from '../Services/captcha.service'
import { UserService } from '../Services/user.service'
import { UntypedFormControl, Validators, FormsModule, ReactiveFormsModule } from '@angular/forms'
import { Component, type OnInit } from '@angular/core'
import { library } from '@fortawesome/fontawesome-svg-core'
import { faPaperPlane, faStar } from '@fortawesome/free-solid-svg-icons'
import { FormSubmitService } from '../Services/form-submit.service'
import { TranslateService, TranslateModule } from '@ngx-translate/core'
import { SnackBarHelperService } from '../Services/snack-bar-helper.service'
import { MatButtonModule } from '@angular/material/button'
import { MatSliderModule } from '@angular/material/slider'
import { NgIf } from '@angular/common'
import { MatInputModule } from '@angular/material/input'
import { MatFormFieldModule, MatLabel, MatHint, MatError } from '@angular/material/form-field'
import { MatCardModule } from '@angular/material/card'
import { FlexModule } from '@angular/flex-layout/flex'
import { MatIconModule } from '@angular/material/icon'

library.add(faStar, faPaperPlane)

@Component({
  selector: 'app-contact',
  templateUrl: './contact.component.html',
  styleUrls: ['./contact.component.scss'],
  imports: [FlexModule, MatCardModule, TranslateModule, FormsModule, ReactiveFormsModule, MatFormFieldModule, MatLabel, MatInputModule, MatHint, NgIf, MatError, MatSliderModule, MatButtonModule, MatIconModule]
})
export class ContactComponent implements OnInit {
  public authorControl: UntypedFormControl = new UntypedFormControl({ value: '', disabled: true }, [])
  public feedbackControl: UntypedFormControl = new UntypedFormControl('', [Validators.required, Validators.maxLength(160)])
  public captchaControl: UntypedFormControl = new UntypedFormControl('', [Validators.required, Validators.pattern('-?[\\d]*')])
  public userIdControl: UntypedFormControl = new UntypedFormControl('', [])
  public rating: number = 0
  public feedback: any = undefined
  public captcha: any
  public captchaId: any
  public confirmation: any
  public error: any

  constructor (private readonly userService: UserService, private readonly captchaService: CaptchaService, private readonly feedbackService: FeedbackService,
    private readonly formSubmitService: FormSubmitService, private readonly translate: TranslateService, private readonly snackBarHelperService: SnackBarHelperService) { }

  ngOnInit (): void {
    this.userService.whoAmI().subscribe((data: any) => {
      this.feedback = {}
      this.userIdControl.setValue(data.id)
      this.feedback.UserId = data.id
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      this.authorControl.setValue(data.email ? `***${data.email.slice(3)}` : 'anonymous')
    }, (err) => {
      this.feedback = undefined
      console.log(err)
    })
    this.getNewCaptcha()

    this.formSubmitService.attachEnterKeyHandler('feedback-form', 'submitButton', () => { this.save() })
  }

  getNewCaptcha () {
    this.captchaService.getCaptcha().subscribe((data: any) => {
      this.captcha = data.captcha
      this.captchaId = data.captchaId
    }, (err) => err)
  }

  save () {
    this.feedback.captchaId = this.captchaId
    this.feedback.captcha = this.captchaControl.value
    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
    this.feedback.comment = `${this.feedbackControl.value} (${this.authorControl.value})`
    this.feedback.rating = this.rating
    this.feedback.UserId = this.userIdControl.value
    this.feedbackService.save(this.feedback).subscribe((savedFeedback) => {
      if (savedFeedback.rating === 5) {
        this.translate.get('FEEDBACK_FIVE_STAR_THANK_YOU').subscribe((feedbackThankYou) => {
          this.snackBarHelperService.open(feedbackThankYou)
        }, (translationId) => {
          this.snackBarHelperService.open(translationId)
        })
      } else {
        this.translate.get('FEEDBACK_THANK_YOU').subscribe((feedbackThankYou) => {
          this.snackBarHelperService.open(feedbackThankYou)
        }, (translationId) => {
          this.snackBarHelperService.open(translationId)
        })
      }
      this.feedback = {}
      this.ngOnInit()
      this.resetForm()
    }, (err) => {
      console.log(err)
      this.snackBarHelperService.open(err.error, 'errorBar')
      this.feedback = {}
      this.resetCaptcha()
    })
  }

  resetForm () {
    this.authorControl.markAsUntouched()
    this.authorControl.markAsPristine()
    this.authorControl.setValue('')
    this.feedbackControl.markAsUntouched()
    this.feedbackControl.markAsPristine()
    this.feedbackControl.setValue('')
    this.rating = 0
    this.captchaControl.markAsUntouched()
    this.captchaControl.markAsPristine()
    this.captchaControl.setValue('')
  }

  resetCaptcha () {
    this.captchaControl.markAsUntouched()
    this.captchaControl.markAsPristine()
    this.captchaControl.setValue('')
  }

  formatRating (value: number) {
    return `${value}★`
  }
}


/* ===== FILE: ./frontend/src/app/oauth/oauth.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type ComponentFixture, fakeAsync, TestBed, waitForAsync } from '@angular/core/testing'
import { TranslateModule } from '@ngx-translate/core'
import { MatIconModule } from '@angular/material/icon'
import { MatCheckboxModule } from '@angular/material/checkbox'
import { MatFormFieldModule } from '@angular/material/form-field'
import { MatCardModule } from '@angular/material/card'
import { MatInputModule } from '@angular/material/input'

import { provideHttpClientTesting } from '@angular/common/http/testing'
import { RouterTestingModule } from '@angular/router/testing'

import { OAuthComponent } from './oauth.component'
import { LoginComponent } from '../login/login.component'
import { ReactiveFormsModule } from '@angular/forms'
import { ActivatedRoute } from '@angular/router'
import { MatTooltipModule } from '@angular/material/tooltip'
import { of, throwError } from 'rxjs'
import { UserService } from '../Services/user.service'
import { CookieModule } from 'ngy-cookie'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('OAuthComponent', () => {
  let component: OAuthComponent
  let fixture: ComponentFixture<OAuthComponent>
  let userService: any

  beforeEach(waitForAsync(() => {
    userService = jasmine.createSpyObj('UserService', ['oauthLogin', 'login', 'save'])
    userService.oauthLogin.and.returnValue(of({ email: '' }))
    userService.login.and.returnValue(of({}))
    userService.save.and.returnValue(of({}))
    userService.isLoggedIn = jasmine.createSpyObj('userService.isLoggedIn', ['next'])
    userService.isLoggedIn.next.and.returnValue({})

    TestBed.configureTestingModule({
      imports: [RouterTestingModule.withRoutes([
        { path: 'login', component: LoginComponent }
      ]),
      ReactiveFormsModule,
      CookieModule.forRoot(),
      TranslateModule.forRoot(),
      MatInputModule,
      MatIconModule,
      MatCardModule,
      MatFormFieldModule,
      MatCheckboxModule,
      MatTooltipModule,
      OAuthComponent, LoginComponent],
      providers: [
        { provide: ActivatedRoute, useValue: { snapshot: { data: { params: '?alt=json&access_token=TEST' } } } },
        { provide: UserService, useValue: userService },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(OAuthComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('removes authentication token and basket id on failed OAuth login attempt', fakeAsync(() => {
    userService.oauthLogin.and.returnValue(throwError({ error: 'Error' }))
    component.ngOnInit()
    expect(localStorage.getItem('token')).toBeNull()
    expect(sessionStorage.getItem('bid')).toBeNull()
  }))

  it('will create regular user account with base64 encoded reversed email as password', fakeAsync(() => {
    userService.oauthLogin.and.returnValue(of({ email: 'test@test.com' }))
    component.ngOnInit()
    expect(userService.save).toHaveBeenCalledWith({ email: 'test@test.com', password: 'bW9jLnRzZXRAdHNldA==', passwordRepeat: 'bW9jLnRzZXRAdHNldA==' })
  }))

  it('logs in user even after failed account creation as account might already have existed from previous OAuth login', fakeAsync(() => {
    userService.oauthLogin.and.returnValue(of({ email: 'test@test.com' }))
    userService.save.and.returnValue(throwError({ error: 'Account already exists' }))
    component.ngOnInit()
    expect(userService.login).toHaveBeenCalledWith({ email: 'test@test.com', password: 'bW9jLnRzZXRAdHNldA==', oauth: true })
  }))

  it('removes authentication token and basket id on failed subsequent regular login attempt', fakeAsync(() => {
    userService.login.and.returnValue(throwError({ error: 'Error' }))
    component.login({ email: '' })
    expect(localStorage.getItem('token')).toBeNull()
    expect(sessionStorage.getItem('bid')).toBeNull()
  }))
})


/* ===== FILE: ./frontend/src/app/oauth/oauth.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<div fxLayoutAlign="center">
  <mat-card appearance="outlined" class="primary-notification">
    <div class="mdc-card">
      <h3>{{"TITLE_LOGIN" | translate}}</h3>
      <div>{{"CONFIRM_LOGGED_IN_VIA_OAUTH2" | translate}}</div>
    </div>
  </mat-card>
</div>


/* ===== FILE: ./frontend/src/app/oauth/oauth.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { ActivatedRoute, Router } from '@angular/router'
import { UserService } from '../Services/user.service'
import { CookieService } from 'ngy-cookie'
import { Component, NgZone, type OnInit } from '@angular/core'
import { TranslateModule } from '@ngx-translate/core'
import { MatCardModule } from '@angular/material/card'
import { FlexModule } from '@angular/flex-layout/flex'

@Component({
  selector: 'app-oauth',
  templateUrl: './oauth.component.html',
  styleUrls: ['./oauth.component.scss'],
  imports: [FlexModule, MatCardModule, TranslateModule]
})
export class OAuthComponent implements OnInit {
  constructor (private readonly cookieService: CookieService, private readonly userService: UserService, private readonly router: Router, private readonly route: ActivatedRoute, private readonly ngZone: NgZone) { }

  ngOnInit (): void {
    this.userService.oauthLogin(this.parseRedirectUrlParams().access_token).subscribe((profile: any) => {
      const password = btoa(profile.email.split('').reverse().join(''))
      this.userService.save({ email: profile.email, password, passwordRepeat: password }).subscribe(() => {
        this.login(profile)
      }, () => { this.login(profile) })
    }, (error) => {
      this.invalidateSession(error)
      this.ngZone.run(async () => await this.router.navigate(['/login']))
    })
  }

  login (profile: any) {
    this.userService.login({ email: profile.email, password: btoa(profile.email.split('').reverse().join('')), oauth: true }).subscribe((authentication) => {
      const expires = new Date()
      expires.setHours(expires.getHours() + 8)
      this.cookieService.put('token', authentication.token, { expires })
      localStorage.setItem('token', authentication.token)
      sessionStorage.setItem('bid', authentication.bid)
      this.userService.isLoggedIn.next(true)
      this.ngZone.run(async () => await this.router.navigate(['/']))
    }, (error) => {
      this.invalidateSession(error)
      this.ngZone.run(async () => await this.router.navigate(['/login']))
    })
  }

  invalidateSession (error: Error) {
    console.log(error)
    this.cookieService.remove('token')
    localStorage.removeItem('token')
    sessionStorage.removeItem('bid')
  }

  parseRedirectUrlParams () {
    const hash = this.route.snapshot.data.params.substr(1)
    const splitted = hash.split('&')
    const params: any = {}
    for (let i = 0; i < splitted.length; i++) {
      const param: string = splitted[i].split('=')
      const key: string = param[0]
      params[key] = param[1]
    }
    return params
  }
}


/* ===== FILE: ./frontend/src/app/address-create/address-create.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateModule, TranslateService } from '@ngx-translate/core'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { MatCardModule } from '@angular/material/card'
import { MatFormFieldModule } from '@angular/material/form-field'
import { type ComponentFixture, fakeAsync, TestBed, waitForAsync } from '@angular/core/testing'
import { AddressCreateComponent } from './address-create.component'
import { MatInputModule } from '@angular/material/input'
import { ReactiveFormsModule } from '@angular/forms'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'

import { of, throwError } from 'rxjs'
import { RouterTestingModule } from '@angular/router/testing'
import { AddressService } from '../Services/address.service'
import { MatGridListModule } from '@angular/material/grid-list'
import { EventEmitter } from '@angular/core'
import { MatIconModule } from '@angular/material/icon'
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('AddressCreateComponent', () => {
  let component: AddressCreateComponent
  let fixture: ComponentFixture<AddressCreateComponent>
  let addressService
  let translateService
  let snackBar: any

  beforeEach(waitForAsync(() => {
    addressService = jasmine.createSpyObj('AddressService', ['getById', 'put', 'save'])
    addressService.save.and.returnValue(of({}))
    addressService.getById.and.returnValue(of({}))
    addressService.put.and.returnValue(of({}))
    translateService = jasmine.createSpyObj('TranslateService', ['get'])
    translateService.get.and.returnValue(of({}))
    translateService.onLangChange = new EventEmitter()
    translateService.onTranslationChange = new EventEmitter()
    translateService.onDefaultLangChange = new EventEmitter()
    snackBar = jasmine.createSpyObj('MatSnackBar', ['open'])
    snackBar.open.and.returnValue(null)

    TestBed.configureTestingModule({
      imports: [RouterTestingModule,
        TranslateModule.forRoot(),
        ReactiveFormsModule,
        BrowserAnimationsModule,
        MatCardModule,
        MatFormFieldModule,
        MatInputModule,
        MatGridListModule,
        MatIconModule,
        MatSnackBarModule,
        AddressCreateComponent],
      providers: [
        { provide: AddressService, useValue: addressService },
        { provide: TranslateService, useValue: translateService },
        { provide: MatSnackBar, useValue: snackBar },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(AddressCreateComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should reinitizalise forms by calling resetForm', () => {
    component.countryControl.setValue('US')
    component.nameControl.setValue('jim')
    component.numberControl.setValue(9800000000)
    component.pinControl.setValue('NX 101')
    component.addressControl.setValue('Bakers Street')
    component.cityControl.setValue('NYC')
    component.stateControl.setValue('NY')
    component.resetForm()
    expect(component.countryControl.value).toBe('')
    expect(component.countryControl.pristine).toBe(true)
    expect(component.countryControl.untouched).toBe(true)
    expect(component.nameControl.value).toBe('')
    expect(component.nameControl.pristine).toBe(true)
    expect(component.nameControl.untouched).toBe(true)
    expect(component.numberControl.value).toBe('')
    expect(component.numberControl.pristine).toBe(true)
    expect(component.numberControl.untouched).toBe(true)
    expect(component.pinControl.value).toBe('')
    expect(component.pinControl.pristine).toBe(true)
    expect(component.pinControl.untouched).toBe(true)
    expect(component.addressControl.value).toBe('')
    expect(component.addressControl.pristine).toBe(true)
    expect(component.addressControl.untouched).toBe(true)
    expect(component.cityControl.value).toBe('')
    expect(component.cityControl.pristine).toBe(true)
    expect(component.cityControl.untouched).toBe(true)
    expect(component.stateControl.value).toBe('')
    expect(component.stateControl.pristine).toBe(true)
    expect(component.stateControl.untouched).toBe(true)
  })

  it('should be compulsory to provide country', () => {
    component.countryControl.setValue('')
    expect(component.countryControl.valid).toBeFalsy()
  })

  it('should be compulsory to provide name', () => {
    component.nameControl.setValue('')
    expect(component.nameControl.valid).toBeFalsy()
  })

  it('should be compulsory to provide number', () => {
    component.numberControl.setValue('')
    expect(component.numberControl.valid).toBeFalsy()
  })

  it('should be compulsory to provide pin', () => {
    component.pinControl.setValue('')
    expect(component.pinControl.valid).toBeFalsy()
  })

  it('should be compulsory to provide address', () => {
    component.addressControl.setValue('')
    expect(component.addressControl.valid).toBeFalsy()
  })

  it('should be compulsory to provide city', () => {
    component.cityControl.setValue('')
    expect(component.cityControl.valid).toBeFalsy()
  })

  it('should not be compulsory to provide state', () => {
    component.stateControl.setValue('')
    expect(component.stateControl.valid).toBe(true)
  })

  it('pin code should not be more than 8 characters', () => {
    let str: string = ''
    for (let i = 0; i < 9; ++i) {
      str += 'a'
    }
    component.pinControl.setValue(str)
    expect(component.pinControl.valid).toBeFalsy()
    str = str.slice(1)
    component.pinControl.setValue(str)
    expect(component.pinControl.valid).toBe(true)
  })

  it('address should not be more than 160 characters', () => {
    let str: string = ''
    for (let i = 0; i < 161; ++i) {
      str += 'a'
    }
    component.addressControl.setValue(str)
    expect(component.addressControl.valid).toBeFalsy()
    str = str.slice(1)
    component.addressControl.setValue(str)
    expect(component.addressControl.valid).toBe(true)
  })

  it('number should be in the range [1111111, 9999999999]', () => {
    component.numberControl.setValue(1111110)
    expect(component.numberControl.valid).toBeFalsy()
    component.numberControl.setValue(10000000000)
    expect(component.numberControl.valid).toBeFalsy()
    component.numberControl.setValue(9999999999)
    expect(component.numberControl.valid).toBe(true)
    component.numberControl.setValue(1111111)
    expect(component.numberControl.valid).toBe(true)
  })

  it('should reset the form on updating address and show confirmation', () => {
    addressService.put.and.returnValue(of({ city: 'NY' }))
    translateService.get.and.returnValue(of('ADDRESS_UPDATED'))
    component.mode = 'edit'
    spyOn(component, 'resetForm')
    spyOn(component, 'ngOnInit')
    component.save()
    expect(translateService.get).toHaveBeenCalledWith('ADDRESS_UPDATED', { city: 'NY' })
    expect(component.ngOnInit).toHaveBeenCalled()
    expect(component.resetForm).toHaveBeenCalled()
  })

  it('should reset the form on adding address and show confirmation', () => {
    addressService.save.and.returnValue(of({ city: 'NY' }))
    translateService.get.and.returnValue(of('ADDRESS_ADDED'))
    spyOn(component, 'resetForm')
    spyOn(component, 'ngOnInit')
    component.save()
    expect(translateService.get).toHaveBeenCalledWith('ADDRESS_ADDED', { city: 'NY' })
    expect(component.ngOnInit).toHaveBeenCalled()
    expect(component.resetForm).toHaveBeenCalled()
  })

  it('should clear the form and display error if saving address fails', fakeAsync(() => {
    addressService.save.and.returnValue(throwError({ error: 'Error' }))
    spyOn(component, 'resetForm')
    component.save()
    expect(component.resetForm).toHaveBeenCalled()
    expect(snackBar.open).toHaveBeenCalled()
  }))

  it('should clear the form and display error if updating address fails', fakeAsync(() => {
    addressService.put.and.returnValue(throwError({ error: 'Error' }))
    component.mode = 'edit'
    spyOn(component, 'resetForm')
    component.save()
    expect(component.resetForm).toHaveBeenCalled()
    expect(snackBar.open).toHaveBeenCalled()
  }))

  it('should populate the form on calling initializeForm', () => {
    component.initializeForm({ country: 'US', fullName: 'jim', mobileNum: 9800000000, zipCode: 'NX 101', streetAddress: 'Bakers Street', city: 'NYC', state: 'NY' })
    expect(component.countryControl.value).toBe('US')
    expect(component.nameControl.value).toBe('jim')
    expect(component.numberControl.value).toBe(9800000000)
    expect(component.pinControl.value).toBe('NX 101')
    expect(component.addressControl.value).toBe('Bakers Street')
    expect(component.cityControl.value).toBe('NYC')
    expect(component.stateControl.value).toBe('NY')
  })
})


/* ===== FILE: ./frontend/src/app/address-create/address-create.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<div fxLayoutAlign="center">
  <mat-card appearance="outlined" class="mat-elevation-z6">
    <div class="mdc-card">
      <h1>{{"ADD_NEW_ADDRESS" | translate}}</h1>
      <div class="form-container" id="address-form">
        <mat-form-field appearance="outline" color="accent">
          <mat-label>{{"LABEL_COUNTRY" | translate}}</mat-label>
          <input [formControl]="countryControl" type="text" [placeholder]="'MANDATORY_COUNTRY' | translate"
          matInput>
          <mat-error *ngIf="countryControl.invalid && countryControl.errors.required" >
            {{"MANDATORY_COUNTRY" | translate}}
          </mat-error>
        </mat-form-field>
        <mat-form-field appearance="outline" color="accent">
          <mat-label >{{"LABEL_NAME" | translate}}</mat-label>
          <input [formControl]="nameControl" type="text" [placeholder]="'MANDATORY_NAME' | translate"
          matInput>
          <mat-error *ngIf="nameControl.invalid && nameControl.errors.required">
            {{"MANDATORY_NAME" | translate}}
          </mat-error>
        </mat-form-field>
        <mat-form-field appearance="outline" color="accent">
          <mat-label >{{"LABEL_MOBILE_NUMBER" | translate}}</mat-label>
          <input [formControl]="numberControl" type="number" [placeholder]="'MANDATORY_NUMBER' | translate"
          matInput>
          <mat-error *ngIf="numberControl.invalid && numberControl.errors.required">
            {{"MANDATORY_NUMBER" | translate}}
          </mat-error>
          <mat-error
          *ngIf="numberControl.invalid && (numberControl.errors.min || numberControl.errors.max)"
           [translateParams]="{range: '1000000-9999999999'}">{{"INVALID_MOBILE_NUMBER" | translate}}
          </mat-error>
        </mat-form-field>
        <mat-form-field appearance="outline" color="accent">
          <mat-label>{{"LABEL_ZIP_CODE" | translate }}</mat-label>
          <input #pin [formControl]="pinControl" type="text" [placeholder]="'MANDATORY_ZIP' | translate"
          matInput>
          <mat-hint align="end">{{pin.value?.length || 0}}/8</mat-hint>
          <mat-error *ngIf="pinControl.invalid && pinControl.errors.required">
            {{"MANDATORY_ZIP" | translate}}
          </mat-error>
        </mat-form-field>
        <mat-form-field appearance="outline" color="accent">
          <mat-label >{{"LABEL_ADDRESS" | translate}}</mat-label>
          <textarea #adress id="address" [formControl]="addressControl" matInput [placeholder]="'MANDATORY_ADDRESS' | translate"
                    matAutosizeMinRows="4" matAutosizeMaxRows="4" matTextareaAutosize cols="50" maxlength="160"></textarea>
          <mat-hint>
            <i class="fas fa-exclamation-circle"></i>
            <em style="margin-left:5px;">{{ 'MAX_TEXTAREA_LENGTH' | translate: {length: '160'} }}</em>
          </mat-hint>
          <mat-hint align="end">{{adress.value?.length || 0}}/160</mat-hint>
          <mat-error *ngIf="addressControl.invalid && addressControl.errors.required" >{{"MANDATORY_ADDRESS" | translate}}</mat-error>
        </mat-form-field>
        <mat-form-field appearance="outline" color="accent">
          <mat-label >{{"LABEL_CITY" | translate}}</mat-label>
          <input [formControl]="cityControl" type="text" [placeholder]="'MANDATORY_CITY' | translate"
          matInput>
          <mat-error *ngIf="cityControl.invalid && cityControl.errors.required" >
            {{"MANDATORY_CITY" | translate}}
          </mat-error>
        </mat-form-field>
        <mat-form-field appearance="outline" color="accent">
          <mat-label>{{"LABEL_STATE" | translate}}</mat-label>
          <input [formControl]="stateControl" type="text" [placeholder]="'STATE_PLACEHOLDER' | translate"
          matInput>
        </mat-form-field>
      </div>
      <div>
        <button mat-stroked-button class="btn-return" (click)="routeToPreviousUrl()">
          <mat-icon>
            navigate_before
          </mat-icon>
          {{'LABEL_BACK' | translate}}
        </button>
        <button type="submit" id="submitButton" mat-raised-button color="primary"
        [disabled]="countryControl.invalid || nameControl.invalid || numberControl.invalid || pinControl.invalid || addressControl.invalid || cityControl.invalid"
        (click)="save()">
          <mat-icon>
            send
          </mat-icon>
          {{'BTN_SUBMIT' | translate}}
        </button>
      </div>
    </div>
  </mat-card>
</div>


/* ===== FILE: ./frontend/src/app/address-create/address-create.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { UntypedFormControl, Validators, FormsModule, ReactiveFormsModule } from '@angular/forms'
import { Component, type OnInit } from '@angular/core'
import { FormSubmitService } from '../Services/form-submit.service'
import { AddressService } from '../Services/address.service'
import { ActivatedRoute, type ParamMap, Router } from '@angular/router'
import { Location, NgIf } from '@angular/common'
import { TranslateService, TranslateModule } from '@ngx-translate/core'
import { SnackBarHelperService } from '../Services/snack-bar-helper.service'
import { MatIconModule } from '@angular/material/icon'
import { MatButtonModule } from '@angular/material/button'
import { MatInputModule } from '@angular/material/input'
import { MatFormFieldModule, MatLabel, MatError, MatHint } from '@angular/material/form-field'
import { MatCardModule } from '@angular/material/card'
import { FlexModule } from '@angular/flex-layout/flex'

@Component({
  selector: 'app-address-create',
  templateUrl: './address-create.component.html',
  styleUrls: ['./address-create.component.scss'],
  imports: [FlexModule, MatCardModule, TranslateModule, MatFormFieldModule, MatLabel, MatInputModule, FormsModule, ReactiveFormsModule, NgIf, MatError, MatHint, MatButtonModule, MatIconModule]
})
export class AddressCreateComponent implements OnInit {
  public countryControl: UntypedFormControl = new UntypedFormControl('', [Validators.required])
  public nameControl: UntypedFormControl = new UntypedFormControl('', [Validators.required])
  public numberControl: UntypedFormControl = new UntypedFormControl('', [Validators.required, Validators.min(1111111), Validators.max(9999999999)])
  public pinControl: UntypedFormControl = new UntypedFormControl('', [Validators.required, Validators.maxLength(8)])
  public addressControl: UntypedFormControl = new UntypedFormControl('', [Validators.required, Validators.maxLength(160)])
  public cityControl: UntypedFormControl = new UntypedFormControl('', [Validators.required])
  public stateControl: UntypedFormControl = new UntypedFormControl()
  public address: any = undefined
  public mode = 'create'
  private addressId: string = undefined

  constructor (private readonly location: Location, private readonly formSubmitService: FormSubmitService,
    private readonly addressService: AddressService, private readonly router: Router, public activatedRoute: ActivatedRoute,
    private readonly translate: TranslateService, private readonly snackBarHelperService: SnackBarHelperService) { }

  ngOnInit (): void {
    this.address = {}
    this.activatedRoute.paramMap.subscribe((paramMap: ParamMap) => {
      if (paramMap.has('addressId')) {
        this.mode = 'edit'
        this.addressId = paramMap.get('addressId')
        this.addressService.getById(this.addressId).subscribe((address) => {
          this.initializeForm(address)
        })
      } else {
        this.mode = 'create'
        this.addressId = null
      }
    })
    this.formSubmitService.attachEnterKeyHandler('address-form', 'submitButton', () => { this.save() })
  }

  save () {
    this.address.country = this.countryControl.value
    this.address.fullName = this.nameControl.value
    this.address.mobileNum = this.numberControl.value
    this.address.zipCode = this.pinControl.value
    this.address.streetAddress = this.addressControl.value
    this.address.city = this.cityControl.value
    this.address.state = this.stateControl.value
    if (this.mode === 'edit') {
      this.addressService.put(this.addressId, this.address).subscribe((savedAddress) => {
        this.address = {}
        this.ngOnInit()
        this.resetForm()
        this.routeToPreviousUrl()
        this.translate.get('ADDRESS_UPDATED', { city: savedAddress.city }).subscribe((addressUpdated) => {
          this.snackBarHelperService.open(addressUpdated, 'confirmBar')
        }, (translationId) => {
          this.snackBarHelperService.open(translationId, 'confirmBar')
        })
      }, (err) => {
        this.snackBarHelperService.open(err.error?.error, 'errorBar')
        this.address = {}
        this.resetForm()
      })
    } else {
      this.addressService.save(this.address).subscribe((savedAddress) => {
        this.address = {}
        this.ngOnInit()
        this.resetForm()
        this.routeToPreviousUrl()
        this.translate.get('ADDRESS_ADDED', { city: savedAddress.city }).subscribe((addressAdded) => {
          this.snackBarHelperService.open(addressAdded, 'confirmBar')
        }, (translationId) => {
          this.snackBarHelperService.open(translationId, 'confirmBar')
        })
      }, (err) => {
        this.snackBarHelperService.open(err.error?.error, 'errorBar')
        this.address = {}
        this.resetForm()
      })
    }
  }

  initializeForm (address) {
    this.countryControl.setValue(address.country)
    this.nameControl.setValue(address.fullName)
    this.numberControl.setValue(address.mobileNum)
    this.pinControl.setValue(address.zipCode)
    this.addressControl.setValue(address.streetAddress)
    this.cityControl.setValue(address.city)
    this.stateControl.setValue(address.state)
  }

  routeToPreviousUrl () {
    this.location.back()
  }

  resetForm () {
    this.countryControl.markAsUntouched()
    this.countryControl.markAsPristine()
    this.countryControl.setValue('')
    this.nameControl.markAsUntouched()
    this.nameControl.markAsPristine()
    this.nameControl.setValue('')
    this.numberControl.markAsUntouched()
    this.numberControl.markAsPristine()
    this.numberControl.setValue('')
    this.pinControl.markAsUntouched()
    this.pinControl.markAsPristine()
    this.pinControl.setValue('')
    this.addressControl.markAsUntouched()
    this.addressControl.markAsPristine()
    this.addressControl.setValue('')
    this.cityControl.markAsUntouched()
    this.cityControl.markAsPristine()
    this.cityControl.setValue('')
    this.stateControl.markAsUntouched()
    this.stateControl.markAsPristine()
    this.stateControl.setValue('')
  }
}


/* ===== FILE: ./frontend/src/app/last-login-ip/last-login-ip.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateModule, TranslateService } from '@ngx-translate/core'
import { EventEmitter } from '@angular/core'
import { of } from 'rxjs'
import { type ComponentFixture, TestBed, waitForAsync } from '@angular/core/testing'
import { LastLoginIpComponent } from './last-login-ip.component'
import { MatCardModule } from '@angular/material/card'
import { DomSanitizer } from '@angular/platform-browser'

describe('LastLoginIpComponent', () => {
  let component: LastLoginIpComponent
  let fixture: ComponentFixture<LastLoginIpComponent>
  let sanitizer
  let translateService

  beforeEach(waitForAsync(() => {
    sanitizer = jasmine.createSpyObj('DomSanitizer', ['bypassSecurityTrustHtml', 'sanitize'])
    sanitizer.bypassSecurityTrustHtml.and.callFake((args: any) => args)
    sanitizer.sanitize.and.returnValue({})
    translateService = jasmine.createSpyObj('TranslateService', ['get'])
    translateService.get.and.returnValue(of({}))
    translateService.onLangChange = new EventEmitter()
    translateService.onTranslationChange = new EventEmitter()
    translateService.onDefaultLangChange = new EventEmitter()

    TestBed.configureTestingModule({
      providers: [
        { provide: DomSanitizer, useValue: sanitizer },
        { provide: TranslateService, useValue: translateService }
      ],
      imports: [
        MatCardModule,
        LastLoginIpComponent,
        TranslateModule.forRoot()
      ]
    }).compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(LastLoginIpComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should compile', () => {
    expect(component).toBeTruthy()
  })

  it('should log JWT parsing error to console', () => {
    console.log = jasmine.createSpy('log')
    localStorage.setItem('token', 'definitelyInvalidJWT')
    component.ngOnInit()
    expect(console.log).toHaveBeenCalled()
  })

  xit('should set Last-Login IP from JWT as trusted HTML', () => { // FIXME Expected state seems to leak over from previous test case occasionally
    localStorage.setItem('token', 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjp7Imxhc3RMb2dpbklwIjoiMS4yLjMuNCJ9fQ.RAkmdqwNypuOxv3SDjPO4xMKvd1CddKvDFYDBfUt3bg')
    component.ngOnInit()
    expect(sanitizer.bypassSecurityTrustHtml).toHaveBeenCalledWith('<small>1.2.3.4</small>')
  })

  xit('should not set Last-Login IP if none is present in JWT', () => { // FIXME Expected state seems to leak over from previous test case occasionally
    localStorage.setItem('token', 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjp7fX0.bVBhvll6IaeR3aUdoOeyR8YZe2S2DfhGAxTGfd9enLw')
    component.ngOnInit()
    expect(sanitizer.bypassSecurityTrustHtml).not.toHaveBeenCalled()
  })
})


/* ===== FILE: ./frontend/src/app/last-login-ip/last-login-ip.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<mat-card appearance="outlined" class="ipCard mat-elevation-z6" >
  <div class="mdc-card">
    <h1 translate>LAST_LOGIN_IP</h1>
    <p style="margin-bottom: 15px;"><span translate>IP_ADDRESS</span>&nbsp;&nbsp;<span [innerHTML]="lastLoginIp"></span></p>
  </div>
</mat-card>


/* ===== FILE: ./frontend/src/app/last-login-ip/last-login-ip.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Component } from '@angular/core'
import { DomSanitizer } from '@angular/platform-browser'
import * as jwtDecode from 'jwt-decode'
import { TranslateModule } from '@ngx-translate/core'
import { MatCardModule } from '@angular/material/card'

@Component({
  selector: 'app-last-login-ip',
  templateUrl: './last-login-ip.component.html',
  styleUrls: ['./last-login-ip.component.scss'],
  imports: [MatCardModule, TranslateModule]
})

export class LastLoginIpComponent {
  lastLoginIp: any = '?'
  constructor (private readonly sanitizer: DomSanitizer) {}

  ngOnInit (): void {
    try {
      this.parseAuthToken()
    } catch (err) {
      console.log(err)
    }
  }

  parseAuthToken () {
    let payload = {} as any
    const token = localStorage.getItem('token')
    if (token) {
      payload = jwtDecode(token)
      if (payload.data.lastLoginIp) {
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        this.lastLoginIp = this.sanitizer.bypassSecurityTrustHtml(`<small>${payload.data.lastLoginIp}</small>`)
      }
    }
  }
}


/* ===== FILE: ./frontend/src/app/order-completion/order-completion.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
-->

<mat-card appearance="outlined" class="mat-elevation-z6 mat-own-card">
  <div class="mdc-card">
    <div class="order-completion-header">
      <div>
        <h1 class="confirmation" translate>THANKS_FOR_PURCHASE</h1>
        <div translate>PURCHASE_COMMENT_PREFIX <a routerLink="/track-result/new" [queryParams]="{ id: this.orderId }" translate>TITLE_TRACK_ORDERS</a> PURCHASE_COMMENT_SUFFIX</div>
      </div>
      <div *ngIf="address">
        <span *ngIf="orderDetails.eta !== '?' && orderDetails.eta !== undefined"><div class="confirmation" translate [translateParams]="{'numberdays': orderDetails.eta}">ESTIMATED_TIME_OF_DELIVERY</div></span>
        <div><b translate>LABEL_DELIVERY_ADDRESS</b></div>
        <div>{{address?.fullName}}</div>
        <div>{{address?.streetAddress}}, {{address?.city}}, {{address?.state}}, {{address?.zipCode}}</div>
        <div>{{address?.country}}</div>
        <div><span translate>PHONE_NUMBER</span> {{address?.mobileNum}}</div>
      </div>
    </div>
    <div class="heading-banner">
      <span class="heading-text">{{"ORDER_SUMMARY" | translate}}</span>
      <div class="order-links">
        <a href="https://twitter.com/intent/tweet?text={{ tweetText }}&hashtags=security" mat-icon-button aria-label="Tweet">
          <i class="fab fa-twitter fa-lg tweet-logo"></i>
        </a>
        <button mat-icon-button aria-label="Print order confirmation" [matTooltip]="'PRINT_ORDER_CONFIRMATION' | translate" matTooltipPosition="below"
        (click)= "openConfirmationPDF()">
          <mat-icon>note</mat-icon>
        </button>
      </div>
    </div>
    <div class="table-container">
      <mat-table [dataSource]="dataSource">
        <ng-container matColumnDef="product">
          <mat-header-cell *matHeaderCellDef translate>LABEL_PRODUCT</mat-header-cell>
          <mat-cell *matCellDef="let element">{{element.name}} </mat-cell>
          <mat-footer-cell *matFooterCellDef></mat-footer-cell>
        </ng-container>
        <ng-container matColumnDef="price">
          <mat-header-cell *matHeaderCellDef translate>LABEL_PRICE</mat-header-cell>
          <mat-cell *matCellDef="let element">{{element.price}}&curren;</mat-cell>
          <mat-footer-cell *matFooterCellDef></mat-footer-cell>
        </ng-container>
        <ng-container matColumnDef="quantity">
          <mat-header-cell *matHeaderCellDef translate>LABEL_QUANTITY</mat-header-cell>
          <mat-cell *matCellDef="let element">
            <span>{{element.quantity}}</span>
          </mat-cell>
          <mat-footer-cell *matFooterCellDef>
            <table class="mat-table">
              <tr class="mat-row">
                <td translate>ITEMS</td>
              </tr>
              <tr class="mat-row">
                <td translate>DELIVERY</td>
              </tr>
              <tr class="mat-row">
                <td translate>PROMOTION</td>
              </tr>
              <tr class="mat-row" style="font-weight: bold;">
                <td translate>LABEL_TOTAL_PRICE</td>
              </tr>
            </table>
          </mat-footer-cell>
        </ng-container>
        <ng-container matColumnDef="total price">
          <mat-header-cell *matHeaderCellDef translate>LABEL_TOTAL_PRICE</mat-header-cell>
          <mat-cell *matCellDef="let element" class="price-align">{{ (element.total).toFixed(2) }}&curren;</mat-cell>
          <mat-footer-cell *matFooterCellDef>
            <table class="price-align">
              <tr class="mat-row">
                <td>{{ orderDetails.itemTotal?.toFixed(2) }}&curren;</td>
              </tr>
              <tr class="mat-row">
                <td>{{ deliveryPrice.toFixed(2) }}&curren;</td>
              </tr>
              <tr class="mat-row">
                <td>{{ promotionalDiscount.toFixed(2) }}&curren;</td>
              </tr>
              <tr class="mat-row" style="font-weight: bold;">
                <td>{{ orderDetails.totalPrice?.toFixed(2) }}&curren;</td>
              </tr>
            </table>
          </mat-footer-cell>
        </ng-container>
        <mat-header-row *matHeaderRowDef="tableColumns"></mat-header-row>
        <mat-row *matRowDef="let row; columns: tableColumns;"></mat-row>
        <mat-footer-row mat-footer-row *matFooterRowDef="tableColumns"></mat-footer-row>
      </mat-table>
    </div>

    <div class="bonus-point-container">
      <span translate [translateParams]="{'bonus': orderDetails.bonus}">BONUS_POINTS_COUNT</span>
    </div>
  </div>
</mat-card>


/* ===== FILE: ./frontend/src/app/order-completion/order-completion.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Component, type OnInit } from '@angular/core'
import { TrackOrderService } from '../Services/track-order.service'
import { ActivatedRoute, type ParamMap, RouterLink } from '@angular/router'
import { MatTableDataSource, MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, MatFooterCellDef, MatFooterCell, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow, MatFooterRowDef, MatFooterRow } from '@angular/material/table'
import { BasketService } from '../Services/basket.service'
import { AddressService } from '../Services/address.service'
import { ConfigurationService } from '../Services/configuration.service'
import { library } from '@fortawesome/fontawesome-svg-core'
import { faTwitter } from '@fortawesome/free-brands-svg-icons'
import { MatIconModule } from '@angular/material/icon'
import { MatTooltip } from '@angular/material/tooltip'
import { MatIconButton } from '@angular/material/button'
import { NgIf } from '@angular/common'
import { TranslateModule } from '@ngx-translate/core'
import { FlexModule } from '@angular/flex-layout/flex'
import { MatCardModule } from '@angular/material/card'

library.add(faTwitter)

@Component({
  selector: 'app-order-completion',
  templateUrl: './order-completion.component.html',
  styleUrls: ['./order-completion.component.scss'],
  imports: [MatCardModule, FlexModule, TranslateModule, RouterLink, NgIf, MatIconButton, MatTooltip, MatIconModule, MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, MatFooterCellDef, MatFooterCell, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow, MatFooterRowDef, MatFooterRow]
})
export class OrderCompletionComponent implements OnInit {
  public tableColumns = ['product', 'price', 'quantity', 'total price']
  public dataSource
  public orderId: string
  public orderDetails: any = { totalPrice: 0 }
  public deliveryPrice = 0
  public promotionalDiscount = 0
  public address: any
  public tweetText: string = 'I just purchased'

  constructor (private readonly configurationService: ConfigurationService, private readonly addressService: AddressService, private readonly trackOrderService: TrackOrderService, public activatedRoute: ActivatedRoute, private readonly basketService: BasketService) { }

  ngOnInit (): void {
    this.activatedRoute.paramMap.subscribe((paramMap: ParamMap) => {
      this.orderId = paramMap.get('id')
      this.trackOrderService.find(this.orderId).subscribe((results) => {
        this.promotionalDiscount = results.data[0].promotionalAmount ? parseFloat(results.data[0].promotionalAmount) : 0
        this.deliveryPrice = results.data[0].deliveryPrice ? parseFloat(results.data[0].deliveryPrice) : 0
        this.orderDetails.addressId = results.data[0].addressId
        this.orderDetails.paymentId = results.data[0].paymentId
        this.orderDetails.totalPrice = results.data[0].totalPrice
        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
        this.orderDetails.itemTotal = results.data[0].totalPrice + this.promotionalDiscount - this.deliveryPrice
        this.orderDetails.eta = results.data[0].eta || '?'
        this.orderDetails.products = results.data[0].products
        this.orderDetails.bonus = results.data[0].bonus
        this.dataSource = new MatTableDataSource<Element>(this.orderDetails.products)
        for (const product of this.orderDetails.products) {
          // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
          this.tweetText += `%0a- ${product.name}`
        }
        this.tweetText = this.truncateTweet(this.tweetText)
        this.configurationService.getApplicationConfiguration().subscribe((config) => {
          if (config?.application?.social) {
            this.tweetText += '%0afrom '
            if (config.application.social.twitterUrl) {
              this.tweetText += config.application.social.twitterUrl.replace('https://twitter.com/', '@')
            } else {
              this.tweetText += config.application.name
            }
          }
        }, (err) => { console.log(err) })
        this.addressService.getById(this.orderDetails.addressId).subscribe((address) => {
          this.address = address
        }, (error) => { console.log(error) })
      }, (err) => { console.log(err) })
    }, (err) => { console.log(err) })
  }

  openConfirmationPDF () {
    const redirectUrl = `${this.basketService.hostServer}/ftp/order_${this.orderId}.pdf`
    window.open(redirectUrl, '_blank')
  }

  truncateTweet = (tweet: string, maxLength = 140) => {
    if (!tweet) return null
    const showDots = tweet.length > maxLength
    return `${tweet.substring(0, maxLength)}${showDots ? '...' : ''}`
  }
}


/* ===== FILE: ./frontend/src/app/order-completion/order-completion.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateModule } from '@ngx-translate/core'
import { MatDividerModule } from '@angular/material/divider'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { type ComponentFixture, fakeAsync, TestBed, waitForAsync } from '@angular/core/testing'
import { RouterTestingModule } from '@angular/router/testing'
import { MatGridListModule } from '@angular/material/grid-list'
import { MatCardModule } from '@angular/material/card'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'
import { MatTableModule } from '@angular/material/table'
import { MatPaginatorModule } from '@angular/material/paginator'
import { MatDialogModule } from '@angular/material/dialog'
import { of, throwError } from 'rxjs'
import { OrderCompletionComponent } from './order-completion.component'
import { TrackOrderService } from '../Services/track-order.service'
import { ActivatedRoute, convertToParamMap } from '@angular/router'
import { MatIconModule } from '@angular/material/icon'
import { BasketService } from '../Services/basket.service'
import { MatTooltipModule } from '@angular/material/tooltip'
import { AddressService } from '../Services/address.service'
import { ConfigurationService } from '../Services/configuration.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

export class MockActivatedRoute {
  public paramMap = of(convertToParamMap({
    id: 'ad9b-96017e7cb1ae7bf9'
  }))
}

describe('OrderCompletionComponent', () => {
  let component: OrderCompletionComponent
  let fixture: ComponentFixture<OrderCompletionComponent>
  let trackOrderService: any
  let activatedRoute: any
  let basketService: any
  let addressService: any
  let configurationService: any

  beforeEach(waitForAsync(() => {
    configurationService = jasmine.createSpyObj('ConfigurationService', ['getApplicationConfiguration'])
    configurationService.getApplicationConfiguration.and.returnValue(of({}))
    trackOrderService = jasmine.createSpyObj('TrackOrderService', ['find'])
    trackOrderService.find.and.returnValue(of({ data: [{ products: [] }] }))
    activatedRoute = new MockActivatedRoute()
    addressService = jasmine.createSpyObj('AddressService', ['getById'])
    addressService.getById.and.returnValue(of([]))

    TestBed.configureTestingModule({
      imports: [RouterTestingModule,
        TranslateModule.forRoot(),
        BrowserAnimationsModule,
        MatTableModule,
        MatPaginatorModule,
        MatDialogModule,
        MatDividerModule,
        MatGridListModule,
        MatCardModule,
        MatIconModule,
        MatTooltipModule,
        OrderCompletionComponent],
      providers: [
        { provide: TrackOrderService, useValue: trackOrderService },
        { provide: ActivatedRoute, useValue: activatedRoute },
        { provide: BasketService, useValue: basketService },
        { provide: ConfigurationService, useValue: configurationService },
        { provide: AddressService, useValue: addressService },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(OrderCompletionComponent)
    component = fixture.componentInstance
    component.ngOnInit()
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should hold order details returned by backend API', () => {
    trackOrderService.find.and.returnValue(of({ data: [{ totalPrice: 2.88, promotionalAmount: 10, deliveryPrice: 2, addressId: 1, paymentId: 1, products: [{ quantity: 1, name: 'Apple Juice (1000ml)', price: 1.99, total: 1.99, bonus: 0 }, { quantity: 1, name: 'Apple Pomace', price: 0.89, total: 0.89, bonus: 0 }], bonus: 0, eta: '5' }] }))
    component.ngOnInit()
    fixture.detectChanges()
    expect(component.promotionalDiscount).toBe(10)
    expect(component.deliveryPrice).toBe(2)
    expect(component.orderDetails.addressId).toBe(1)
    expect(component.orderDetails.paymentId).toBe(1)
    expect(parseFloat((component.orderDetails.totalPrice).toFixed(2))).toBe(2.88)
    expect(parseFloat((component.orderDetails.itemTotal).toFixed(2))).toBe(10.88)
    expect(component.orderDetails.eta).toBe('5')
    expect(component.orderDetails.bonus).toBe(0)
    expect(component.orderDetails.products.length).toBe(2)
    expect(component.orderDetails.products[0].name).toBe('Apple Juice (1000ml)')
    expect(component.orderDetails.products[1].name).toBe('Apple Pomace')
  })

  it('should have bullet point list of products in tweet', () => {
    trackOrderService.find.and.returnValue(of({ data: [{ products: [{ name: 'A' }, { name: 'B' }] }] }))
    configurationService.getApplicationConfiguration.and.returnValue(of({ }))
    component.ngOnInit()
    expect(component.tweetText).toBe('I just purchased%0a- A%0a- B')
  })

  it('should truncate tweet text if it exceeds 140 characters', () => {
    trackOrderService.find.and.returnValue(of({ data: [{ products: [{ name: 'AAAAAAAAAAAAAAAAAAAA' }, { name: 'BBBBBBBBBBBBBBBBBBBB' }, { name: 'CCCCCCCCCCCCCCCCCCCC' }, { name: 'DDDDDDDDDDDDDDDDDDDD' }, { name: 'EEEEEEEEEEEEEEEEEEEE' }, { name: 'FFFFFFFFFFFFFFFFFFFF' }] }] }))
    configurationService.getApplicationConfiguration.and.returnValue(of({ }))
    component.ngOnInit()
    expect(component.tweetText).toBe('I just purchased%0a- AAAAAAAAAAAAAAAAAAAA%0a- BBBBBBBBBBBBBBBBBBBB%0a- CCCCCCCCCCCCCCCCCCCC%0a- DDDDDDDDDDDDDDDDDDDD%0a- EEEEEEEEEEEEEEEEEEE...')
  })

  it('should derive twitter handle from twitter URL if configured', () => {
    trackOrderService.find.and.returnValue(of({ data: [{ products: [] }] }))
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { social: { twitterUrl: 'https://twitter.com/bkimminich' } } }))
    component.ngOnInit()
    expect(component.tweetText).toBe('I just purchased%0afrom @bkimminich')
  })

  it('should append twitter handle to truncated tweet text', () => {
    trackOrderService.find.and.returnValue(of({ data: [{ products: [{ name: 'AAAAAAAAAAAAAAAAAAAA' }, { name: 'BBBBBBBBBBBBBBBBBBBB' }, { name: 'CCCCCCCCCCCCCCCCCCCC' }, { name: 'DDDDDDDDDDDDDDDDDDDD' }, { name: 'EEEEEEEEEEEEEEEEEEEE' }, { name: 'FFFFFFFFFFFFFFFFFFFF' }] }] }))
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { social: { twitterUrl: 'https://twitter.com/owasp_juiceshop' } } }))
    component.ngOnInit()
    expect(component.tweetText).toBe('I just purchased%0a- AAAAAAAAAAAAAAAAAAAA%0a- BBBBBBBBBBBBBBBBBBBB%0a- CCCCCCCCCCCCCCCCCCCC%0a- DDDDDDDDDDDDDDDDDDDD%0a- EEEEEEEEEEEEEEEEEEE...%0afrom @owasp_juiceshop')
  })

  it('should use configured URL as is if it is not a twitter URL', () => {
    trackOrderService.find.and.returnValue(of({ data: [{ products: [] }] }))
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { social: { twitterUrl: 'http://localhorst:42' } } }))
    component.ngOnInit()
    expect(component.tweetText).toBe('I just purchased%0afrom http://localhorst:42')
  })

  it('should use configured application name as a fallback for missing twitter URL', () => {
    trackOrderService.find.and.returnValue(of({ data: [{ products: [] }] }))
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { name: 'OWASP Juice Shop', social: { twitterUrl: null } } }))
    component.ngOnInit()
    expect(component.tweetText).toBe('I just purchased%0afrom OWASP Juice Shop')
  })

  it('should log error while getting application configuration from backend API directly to browser console', fakeAsync(() => {
    trackOrderService.find.and.returnValue(of({ data: [{ products: [] }] }))
    configurationService.getApplicationConfiguration.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.ngOnInit()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should log error while getting order details from backend API directly to browser console', fakeAsync(() => {
    trackOrderService.find.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.ngOnInit()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))
})


/* ===== FILE: ./frontend/src/app/chatbot/chatbot.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { ChatbotService } from '../Services/chatbot.service'
import { UserService } from '../Services/user.service'
import { Component, type OnDestroy, type OnInit } from '@angular/core'
import { UntypedFormControl, FormsModule, ReactiveFormsModule } from '@angular/forms'
import { library } from '@fortawesome/fontawesome-svg-core'
import { faBomb } from '@fortawesome/free-solid-svg-icons'
import { FormSubmitService } from '../Services/form-submit.service'
import { TranslateService, TranslateModule } from '@ngx-translate/core'
import { CookieService } from 'ngy-cookie'
import { MatInputModule } from '@angular/material/input'
import { MatFormFieldModule, MatLabel } from '@angular/material/form-field'
import { NgFor, NgIf } from '@angular/common'
import { MatCardModule } from '@angular/material/card'
import { FlexModule } from '@angular/flex-layout/flex'

library.add(faBomb)

enum MessageSources {
  user = 'user',
  bot = 'bot'
}

interface ChatMessage {
  author: MessageSources.user | MessageSources.bot
  body: string
}

interface MessageActions {
  response: string
  namequery: string
}

@Component({
  selector: 'app-chatbot',
  templateUrl: './chatbot.component.html',
  styleUrls: ['./chatbot.component.scss'],
  imports: [FlexModule, MatCardModule, NgFor, NgIf, MatFormFieldModule, MatLabel, TranslateModule, MatInputModule, FormsModule, ReactiveFormsModule]
})
export class ChatbotComponent implements OnInit, OnDestroy {
  public messageControl: UntypedFormControl = new UntypedFormControl()
  public messages: ChatMessage[] = []
  public juicyImageSrc: string = 'assets/public/images/ChatbotAvatar.png'
  public profileImageSrc: string = 'assets/public/images/uploads/default.svg'
  public messageActions: MessageActions = {
    response: 'query',
    namequery: 'setname'
  }

  public currentAction: string = this.messageActions.response

  private chatScrollDownTimeoutId: ReturnType<typeof setTimeout> | null = null

  constructor (private readonly userService: UserService, private readonly chatbotService: ChatbotService, private readonly cookieService: CookieService, private readonly formSubmitService: FormSubmitService, private readonly translate: TranslateService) { }

  ngOnDestroy (): void {
    if (this.chatScrollDownTimeoutId) {
      clearTimeout(this.chatScrollDownTimeoutId)
    }
  }

  ngOnInit (): void {
    this.chatbotService.getChatbotStatus().subscribe((response) => {
      this.messages.push({
        author: MessageSources.bot,
        body: response.body
      })
      if (response.action) {
        this.currentAction = this.messageActions[response.action]
      }
    })

    this.userService.whoAmI().subscribe((user: any) => {
      this.profileImageSrc = user.profileImage
    }, (err) => {
      console.log(err)
    })
  }

  handleResponse (response) {
    this.messages.push({
      author: MessageSources.bot,
      body: response.body
    })
    this.currentAction = this.messageActions[response.action]
    if (response.token) {
      localStorage.setItem('token', response.token)
      const expires = new Date()
      expires.setHours(expires.getHours() + 8)
      this.cookieService.put('token', response.token, { expires })
    }
  }

  sendMessage () {
    const messageBody = this.messageControl.value
    if (messageBody) {
      this.messages.push({
        author: MessageSources.user,
        body: messageBody
      })
      this.messageControl.setValue('')
      this.chatbotService.getChatbotStatus().subscribe((response) => {
        if (!response.status && !response.action) {
          this.messages.push({
            author: MessageSources.bot,
            body: response.body
          })
        } else {
          this.chatbotService.getResponse(this.currentAction, messageBody).subscribe((response) => {
            this.handleResponse(response)
          })
        }
        this.chatScrollDownTimeoutId = setTimeout(() => {
          const chat = document.getElementById('chat-window')
          chat.scrollTop = chat.scrollHeight
          this.chatScrollDownTimeoutId = null
        }, 250)
      })
    }
  }
}


/* ===== FILE: ./frontend/src/app/chatbot/chatbot.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<div fxLayoutAlign="center">
  <mat-card appearance="outlined" class="mat-elevation-z6">
    <div class="mdc-card chat-wrapper">
      <h1>{{"SECTION_SUPPORT_CHAT" | translate}} <span class="powered-by">({{"LABEL_POWERED_BY_CHATBOT" | translate: { chatbot: 'juicy-chat-bot' } }})</span></h1>
      <mat-card appearance="outlined" id="chat-container">
        <div class="mdc-card">
          <mat-card appearance="outlined" id="chat-box">
            <div class="mdc-card chat-content">
              <div id="chat-window">
                <div *ngFor="let message of messages; index as index" class="message-container">
                  <img *ngIf="message.author == 'bot'" src="{{juicyImageSrc}}" class="juicy-chat-bot-image"/>
                  <img *ngIf="message.author == 'user'" src="{{profileImageSrc}}" class="profile-image"/>
                  <div class="{{message.author == 'user' ? 'speech-bubble-right' : 'speech-bubble-left'}}">
                    {{message.body}}
                  </div>
                </div>
              </div>

              <div class="message-box-container">
                <div class="form-wrapper">
                  <mat-form-field color="accent" appearance="outline">
                    <mat-label translate>LABEL_MESSAGE</mat-label>
                    <input id="message-input" #message name="message" [formControl]="messageControl"
                            matInput placeholder="{{ 'ASK_ME_ANYTHING_PLACEHOLDER' | translate}}"
                            aria-label="Text field for a chat message" (keyup.enter)="sendMessage()">
                  </mat-form-field>
                </div>
              </div>
            </div>
          </mat-card>
        </div>
      </mat-card>
    </div>
  </mat-card>
</div>

/* ===== FILE: ./frontend/src/app/chatbot/chatbot.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { ChatbotService } from '../Services/chatbot.service'
import { ReactiveFormsModule } from '@angular/forms'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'
import { MatCardModule } from '@angular/material/card'
import { MatFormFieldModule } from '@angular/material/form-field'
import { TranslateModule, TranslateService } from '@ngx-translate/core'
import { MatInputModule } from '@angular/material/input'
import { MatButtonModule } from '@angular/material/button'

import { type ComponentFixture, TestBed, waitForAsync } from '@angular/core/testing'
import { ChatbotComponent } from './chatbot.component'
import { of } from 'rxjs'

import { provideHttpClientTesting } from '@angular/common/http/testing'
import { EventEmitter } from '@angular/core'
import { CookieModule } from 'ngy-cookie'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

enum MessageSources {
  user = 'user',
  bot = 'bot'
}

describe('ComplaintComponent', () => {
  let component: ChatbotComponent
  let fixture: ComponentFixture<ChatbotComponent>
  let chatbotService: any
  let translateService

  beforeEach(waitForAsync(() => {
    chatbotService = jasmine.createSpyObj('ChatbotService', ['getChatbotStatus', 'getResponse'])
    chatbotService.getChatbotStatus.and.returnValue(of({
      status: true,
      body: 'hello there'
    }))
    chatbotService.getResponse.and.returnValue(of({
      action: 'response',
      body: 'hello there'
    }))
    translateService = jasmine.createSpyObj('TranslateService', ['get'])
    translateService.get.and.returnValue(of({}))
    translateService.onLangChange = new EventEmitter()
    translateService.onTranslationChange = new EventEmitter()
    translateService.onDefaultLangChange = new EventEmitter()

    TestBed.configureTestingModule({
      imports: [ReactiveFormsModule,
        CookieModule.forRoot(),
        TranslateModule.forRoot(),
        BrowserAnimationsModule,
        MatCardModule,
        MatFormFieldModule,
        MatInputModule,
        MatButtonModule,
        ChatbotComponent],
      providers: [
        { provide: ChatbotService, useValue: chatbotService },
        { provide: TranslateService, useValue: translateService },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(ChatbotComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should initially have 1 message intially', () => {
    expect(component.messages.length).toEqual(1)
    expect(component.messages[0]).toEqual({
      author: MessageSources.bot,
      body: 'hello there'
    })
  })

  it('should record and display user messages', () => {
    component.messageControl.setValue('Message')
    component.sendMessage()
    expect(component.messages[1]).toEqual({
      author: MessageSources.user,
      body: 'Message'
    })
  })

  it('Responds to user messages', () => {
    component.messageControl.setValue('Message')
    component.sendMessage()
    expect(component.messages.length).toEqual(3)
    expect(component.messages[2]).toEqual({
      author: MessageSources.bot,
      body: 'hello there'
    })
  })
})


/* ===== FILE: ./frontend/src/app/privacy-policy/privacy-policy.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<mat-card appearance="outlined" class="mat-elevation-z6">
  <div class="mdc-card">
    <section class="privacy-policy">
      <h1>{{"TITLE_PRIVACY_POLICY" | translate}}</h1>


      <p>Effective date: March 15, 2019</p>


      <p>{{applicationName}} ("us", "we", or "our") operates the <span class="hot">{{applicationUrl}}</span> website (the
        "Service").</p>

      <p>This page informs you of our policies regarding the collection, use, and disclosure of personal data when you use
        our Service and the choices you have associated with that data. Our Privacy Policy for {{applicationName}} is
        created with the help of the <a href="https://www.freeprivacypolicy.com/"
                                        aria-label="Link to the page where the privacy policy was created">Free Privacy
          Policy website</a>.</p>

      <p>We use your data to provide and improve the Service. By using the Service, you agree to the collection and use of
        information in accordance with this policy. Unless otherwise defined in this Privacy Policy, terms used in this
        Privacy Policy have the same meanings as in our Terms and Conditions, accessible from {{applicationUrl}} .</p>

      <mat-divider class="divider"></mat-divider>
      <h2>A. Information Collection And Use</h2>

      <p>We collect several different types of information for various purposes to provide and improve our Service to
        you.</p>

      <h3>A1. Types of Data Collected</h3>

      <h4>A1.1 Personal Data</h4>

      <p>While using our Service, we may ask you to provide us with certain personally identifiable information that can
        be
        used to contact or identify you ("Personal Data"). Personally identifiable information may include, but is not
        limited to:</p>

      <ul>
        <li>Email address</li>
        <li>Address, State, Province, ZIP/Postal code, City</li>
        <li>Cookies and Usage Data</li>
      </ul>

      <h4>A1.2 Usage Data</h4>

      <p><span class="hot">We may also</span> collect information how the Service is accessed and used ("Usage Data").
        This Usage Data may include
        information such as your computer's Internet Protocol address (e.g. IP address), browser type, browser version,
        the
        pages of our Service that you visit, the time and date of your visit, the time spent on those pages, unique device
        identifiers and other diagnostic data.</p>

      <h4>A1.3 Tracking & Cookies Data</h4>
      <p>We use cookies and similar tracking technologies to track the activity on our Service and hold certain
        information.</p>
      <p>Cookies are files with small amount of data which may include an anonymous unique identifier. Cookies are sent to
        your browser from a website and stored on your device. Tracking technologies also used are beacons, tags, and
        scripts to collect and track information and to improve and analyze our Service.</p>
      <p>You can <span class="hot">instruct you</span>r browser <span class="hot">to refuse all</span> cookies or to
        indicate when a cookie is being sent. However, if you do
        not accept cookies, you may not be able to use some portions of our Service.</p>
      <p>Examples of Cookies we use:</p>
      <ul>
        <li><strong>Session Cookies:</strong> &nbsp;We use Session Cookies to operate our Service.</li>
        <li><strong>Preference Cookies:</strong>&nbsp;We use Preference Cookies to remember your preferences and various
          settings.
        </li>
        <li><strong>Security Cookies:</strong>&nbsp;We use Security Cookies for security purposes.</li>
      </ul>

      <h3>A2. Use of Data</h3>

      <p>{{applicationName}} uses the collected data for various purposes:</p>
      <ul>
        <li>To provide and maintain the Service</li>
        <li>To notify you about changes to our Service</li>
        <li>To allow you to participate in interactive features of our Service when you choose to do so</li>
        <li>To provide customer care and support</li>
        <li>To provide analysis or valuable information so that we can improve the Service</li>
        <li>To monitor the usage of the Service</li>
        <li>To detect, prevent and address technical issues</li>
      </ul>

      <mat-divider class="divider"></mat-divider>
      <h2>B. Transfer Of Data</h2>
      <p>Your information, including Personal Data, may be transferred to — and maintained on — computers located outside
        of
        your state, province, country or other governmental jurisdiction where the data protection laws may differ than
        those from your jurisdiction.</p>
      <p>If you are located outside Germany and choose to provide information to us, please note that we transfer the
        data,
        including Personal Data, to Germany and process it there.</p>
      <p>Your consent to this Privacy Policy followed by your submission of such information represents your agreement to
        that transfer.</p>
      <p>{{applicationName}} will take all steps <span class="hot">reasonably necessary</span> to ensure that your data is
        treated securely and in
        accordance with this Privacy Policy and no transfer of your Personal Data will take place to an organization or a
        country unless there are adequate controls in place including the security of your data and other personal
        information.</p>

      <mat-divider class="divider"></mat-divider>
      <h2>C. Disclosure Of Data</h2>

      <h3>C1. Legal Requirements</h3>
      <p>{{applicationName}} may disclose your Personal Data in the good faith belief that such action is necessary
        to:</p>
      <ul>
        <li>To comply with a legal obligation</li>
        <li>To protect and defend the rights or property of {{applicationName}}</li>
        <li>To prevent or investigate possible wrongdoing in connection with the Service</li>
        <li>To protect the personal safety of users of the Service or the public</li>
        <li>To protect against legal liability</li>
      </ul>

      <mat-divider class="divider"></mat-divider>
      <h2>D. Security Of Data</h2>
      <p>The security of your data is important to us, but remember that no method of transmission over the Internet, or
        method of electronic storage is 100% secure. While we strive to use commercially acceptable means to protect your
        Personal Data, we cannot guarantee its absolute security.</p>

      <mat-divider class="divider"></mat-divider>
      <h2>E. Service Providers</h2>
      <p>We may employ third party companies and individuals to facilitate our Service ("Service Providers"), to provide
        the
        Service on our behalf, to perform Service-related services or to assist us in analyzing how our Service is
        used.</p>
      <p>These third parties have access to your Personal Data only to perform these tasks on our behalf and are obligated
        not to disclose or use it for any other purpose.</p>

      <mat-divider class="divider"></mat-divider>
      <h2>F. Links To Other Sites</h2>
      <p>Our Service may contain links to other sites that are not operated by us. If you click on a third party link, you
        will be directed to that third party's site. We strongly advise you to review the Privacy Policy of every site you
        visit.</p>
      <p>We have no control over and assume no <span class="hot">responsibility</span> for the content, privacy policies
        or practices of any third
        party sites or services.</p>

      <mat-divider class="divider"></mat-divider>
      <h2>G. Children's Privacy</h2>
      <p>Our Service does not address anyone under the age of 18 ("Children").</p>
      <p>We do not knowingly collect personally identifiable information from anyone under the age of 18. If you are a
        parent or guardian and you are aware that your Children has provided us with Personal Data, please contact us. If
        we
        become aware that we have collected Personal Data from children without verification of parental consent, we take
        steps to remove that information from our servers.</p>

      <mat-divider class="divider"></mat-divider>
      <h2>H. Changes To This Privacy Policy</h2>
      <p>We may update our Privacy Policy from time to time. We will notify you of any changes by posting the new Privacy
        Policy on this page.</p>
      <p>We will let you know via email and/or a prominent notice on our Service, prior to the change becoming effective
        and
        update the "effective date" at the top of this Privacy Policy.</p>
      <p>You are advised to review this Privacy Policy periodically for any changes. Changes to this Privacy Policy are
        effective when they are posted on this page.</p>

      <mat-divider class="divider"></mat-divider>
      <h2>Contact Us</h2>
      <p>If you have any questions about this Privacy Policy, please contact us:</p>
      <ul>
        <li>By email: {{privacyContactEmail}}</li>

      </ul>
    </section>

    <img src="assets/public/images/padding/81px.png"/>
  </div>
</mat-card>


/* ===== FILE: ./frontend/src/app/privacy-policy/privacy-policy.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateModule, TranslateService } from '@ngx-translate/core'
import { EventEmitter } from '@angular/core'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { type ComponentFixture, TestBed, waitForAsync } from '@angular/core/testing'
import { ConfigurationService } from '../Services/configuration.service'
import { MatCardModule } from '@angular/material/card'
import { MatDividerModule } from '@angular/material/divider'

import { PrivacyPolicyComponent } from './privacy-policy.component'
import { of } from 'rxjs'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('PrivacyPolicyComponent', () => {
  let component: PrivacyPolicyComponent
  let fixture: ComponentFixture<PrivacyPolicyComponent>
  let configurationService: any
  let translateService

  beforeEach(waitForAsync(() => {
    configurationService = jasmine.createSpyObj('ConfigurationService', ['getApplicationConfiguration'])
    configurationService.getApplicationConfiguration.and.returnValue(of({}))
    translateService = jasmine.createSpyObj('TranslateService', ['get'])
    translateService.get.and.returnValue(of({}))
    translateService.onLangChange = new EventEmitter()
    translateService.onTranslationChange = new EventEmitter()
    translateService.onDefaultLangChange = new EventEmitter()

    TestBed.configureTestingModule({
      imports: [MatCardModule,
        MatDividerModule,
        PrivacyPolicyComponent,
        TranslateModule.forRoot()],
      providers: [
        { provide: ConfigurationService, useValue: configurationService },
        { provide: TranslateService, useValue: translateService },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    }).compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(PrivacyPolicyComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should compile', () => {
    expect(component).toBeTruthy()
  })
})


/* ===== FILE: ./frontend/src/app/privacy-policy/privacy-policy.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Component, Inject, type OnInit } from '@angular/core'
import { DOCUMENT } from '@angular/common'
import { ConfigurationService } from '../Services/configuration.service'
import { MatDivider } from '@angular/material/divider'
import { TranslateModule } from '@ngx-translate/core'
import { MatCardModule } from '@angular/material/card'

@Component({
  selector: 'app-privacy-policy',
  templateUrl: './privacy-policy.component.html',
  styleUrls: ['./privacy-policy.component.scss'],
  imports: [MatCardModule, TranslateModule, MatDivider]
})
export class PrivacyPolicyComponent implements OnInit {
  public applicationName: string = 'OWASP Juice Shop'
  public privacyContactEmail!: string
  public applicationUrl!: string

  constructor (@Inject(DOCUMENT) private readonly _document: HTMLDocument, private readonly configurationService: ConfigurationService) { }

  ngOnInit (): void {
    this.applicationUrl = this._document.location.protocol + '//' + this._document.location.hostname
    this.configurationService.getApplicationConfiguration().subscribe((config: any) => {
      if (config?.application?.name) {
        this.applicationName = config.application.name
      }
      if (config?.application?.privacyContactEmail) {
        this.privacyContactEmail = config.application.privacyContactEmail
      } else {
        this.privacyContactEmail = `donotreply@${this._document.location.hostname}`
      }
    }, (err) => { console.log(err) })
  }
}


/* ===== FILE: ./frontend/src/app/password-strength/password-strength.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2024 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type ComponentFixture, TestBed } from '@angular/core/testing'

import { PasswordStrengthComponent } from './password-strength.component'

describe('PasswordStrengthComponent', () => {
  let component: PasswordStrengthComponent
  let fixture: ComponentFixture<PasswordStrengthComponent>

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [PasswordStrengthComponent]
    })
      .compileComponents()

    fixture = TestBed.createComponent(PasswordStrengthComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should render mat-progress-bar', () => {
    const progressBar = fixture.nativeElement.querySelector('mat-progress-bar')
    expect(progressBar).toBeTruthy()
  })

  it('should bind progress input to mat-progress-bar value', () => {
    component.passwordStrength = 50
    fixture.detectChanges()
    const progressBar = fixture.nativeElement.querySelector('mat-progress-bar')
    expect(progressBar.getAttribute('ng-reflect-value')).toBe('50')
  })

  it('should apply correct class based on progress value', () => {
    const progressBar = fixture.nativeElement.querySelector('mat-progress-bar')

    component.passwordStrength = 0
    fixture.detectChanges()
    expect(progressBar.classList).toContain('low')

    component.passwordStrength = 20
    fixture.detectChanges()
    expect(progressBar.classList).toContain('low')

    component.passwordStrength = 40
    fixture.detectChanges()
    expect(progressBar.classList).toContain('low-medium')

    component.passwordStrength = 60
    fixture.detectChanges()
    expect(progressBar.classList).toContain('medium')

    component.passwordStrength = 80
    fixture.detectChanges()
    expect(progressBar.classList).toContain('high-medium')

    component.passwordStrength = 100
    fixture.detectChanges()
    expect(progressBar.classList).toContain('high')
  })

  it('should have correct ARIA attributes for accessibility', () => {
    const progressBar = fixture.nativeElement.querySelector('mat-progress-bar')
    expect(progressBar.getAttribute('role')).toBe('progressbar')
    expect(progressBar.getAttribute('aria-valuemin')).toBe('0')
    expect(progressBar.getAttribute('aria-valuemax')).toBe('100')
  })

  it('should update aria-valuenow based on progress value', () => {
    component.passwordStrength = 45
    fixture.detectChanges()
    const progressBar = fixture.nativeElement.querySelector('mat-progress-bar')
    expect(progressBar.getAttribute('aria-valuenow')).toBe('45')
  })
})


/* ===== FILE: ./frontend/src/app/password-strength/password-strength.component.ts ===== */

/*
 * Copyright (c) 2014-2024 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { NgClass } from '@angular/common'
import { Component, Input, OnChanges, SimpleChanges } from '@angular/core'
import { MatProgressBarModule } from '@angular/material/progress-bar'

@Component({
  selector: 'app-password-strength',
  imports: [MatProgressBarModule, NgClass],
  templateUrl: './password-strength.component.html',
  styleUrl: './password-strength.component.scss'
})

export class PasswordStrengthComponent implements OnChanges {
  @Input() password: string = ''
  passwordStrength: number = 0
  minLength: number = 8

  private readonly ranges = ['low', 'low-medium', 'medium', 'high-medium', 'high']

  ngOnChanges (changes: SimpleChanges): void {
    if (changes.password) {
      this.passwordStrength = this.calculatePasswordStrength(this.password)
    }
  }

  private calculatePasswordStrength (password: string): number {
    const checks = [
      this.containAtLeastMinChars,
      this.containAtLeastOneLowerCaseLetter,
      this.containAtLeastOneUpperCaseLetter,
      this.containAtLeastOneDigit,
      this.containAtLeastOneSpecialChar
    ]

    return checks.filter(x => x).length / checks.length * 100 // calculate percentage of checks passed
  }

  get progressColor (): string {
    return this.ranges[Math.max(Math.floor(this.passwordStrength / (100 / this.ranges.length)) - 1, 0)] // map passwordStrength to value within ranges.length
  }

  get containAtLeastMinChars (): boolean {
    return this.password.length >= 8
  }

  get containAtLeastOneLowerCaseLetter (): boolean {
    return /^(?=.*?[a-z])/.test(this.password)
  }

  get containAtLeastOneUpperCaseLetter (): boolean {
    return /^(?=.*?[A-Z])/.test(this.password)
  }

  get containAtLeastOneDigit (): boolean {
    return /^(?=.*?[0-9])/.test(this.password)
  }

  get containAtLeastOneSpecialChar (): boolean {
    return /^(?=.*?[" !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~"])/.test(this.password)
  }
}


/* ===== FILE: ./frontend/src/app/password-strength/password-strength.component.html ===== */

<!--
  ~ Copyright (c) 2014-2024 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<mat-progress-bar
  [hidden]="password.length===0"
  mode="determinate"
  [value]="passwordStrength"
  [ngClass]="progressColor">
</mat-progress-bar>


/* ===== FILE: ./frontend/src/app/challenge-solved-notification/challenge-solved-notification.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateService, TranslateModule } from '@ngx-translate/core'
import { ChallengeService } from '../Services/challenge.service'
import { ConfigurationService } from '../Services/configuration.service'
import { ChangeDetectorRef, Component, NgZone, type OnInit } from '@angular/core'
import { CookieService } from 'ngy-cookie'
import { CountryMappingService } from '../Services/country-mapping.service'
import { SocketIoService } from '../Services/socket-io.service'
import { ClipboardModule } from 'ngx-clipboard'
import { MatIconModule } from '@angular/material/icon'
import { MatButtonModule } from '@angular/material/button'
import { MatCardModule } from '@angular/material/card'
import { NgIf, LowerCasePipe } from '@angular/common'

interface ChallengeSolvedMessage {
  challenge: string
  hidden?: any
  isRestore?: any
  flag: any
  key?: any
}

interface ChallengeSolvedNotification {
  key: string
  message: string
  flag: string
  country?: { code: string, name: string }
  copied: boolean
}

@Component({
  selector: 'app-challenge-solved-notification',
  templateUrl: './challenge-solved-notification.component.html',
  styleUrls: ['./challenge-solved-notification.component.scss'],
  imports: [MatCardModule, MatButtonModule, MatIconModule, ClipboardModule, NgIf, LowerCasePipe, TranslateModule]
})
export class ChallengeSolvedNotificationComponent implements OnInit {
  public notifications: ChallengeSolvedNotification[] = []
  public showCtfFlagsInNotifications: boolean = false
  public showCtfCountryDetailsInNotifications: string = 'none'
  public countryMap?: any

  constructor (private readonly ngZone: NgZone, private readonly configurationService: ConfigurationService, private readonly challengeService: ChallengeService, private readonly countryMappingService: CountryMappingService, private readonly translate: TranslateService, private readonly cookieService: CookieService, private readonly ref: ChangeDetectorRef, private readonly io: SocketIoService) {
  }

  ngOnInit (): void {
    this.ngZone.runOutsideAngular(() => {
      this.io.socket().on('challenge solved', (data: ChallengeSolvedMessage) => {
        if (data?.challenge) {
          if (!data.hidden) {
            this.showNotification(data)
          }
          if (!data.isRestore) {
            this.saveProgress()
            if (!data.hidden) {
              import('../../confetti').then(module => {
                module.shootConfetti()
              })
            }
          }
          this.io.socket().emit('notification received', data.flag)
        }
      })
    })

    this.configurationService.getApplicationConfiguration().subscribe((config) => {
      if (config?.ctf) {
        if (config.ctf.showFlagsInNotifications) {
          this.showCtfFlagsInNotifications = config.ctf.showFlagsInNotifications
        } else {
          this.showCtfFlagsInNotifications = false
        }

        if (config.ctf.showCountryDetailsInNotifications) {
          this.showCtfCountryDetailsInNotifications = config.ctf.showCountryDetailsInNotifications

          if (config.ctf.showCountryDetailsInNotifications !== 'none') {
            this.countryMappingService.getCountryMapping().subscribe((countryMap: any) => {
              this.countryMap = countryMap
            }, (err) => { console.log(err) })
          }
        } else {
          this.showCtfCountryDetailsInNotifications = 'none'
        }
      }
    })
  }

  closeNotification (index: number, shiftKey: boolean = false) {
    if (shiftKey) {
      this.ngZone.runOutsideAngular(() => {
        this.io.socket().emit('verifyCloseNotificationsChallenge', this.notifications)
      })
      this.notifications = []
    } else {
      this.notifications.splice(index, 1)
    }
    this.ref.detectChanges()
  }

  showNotification (challenge: ChallengeSolvedMessage) {
    this.translate.get('CHALLENGE_SOLVED', { challenge: challenge.challenge }).toPromise().then((challengeSolved) => challengeSolved,
      (translationId) => translationId).then((message) => {
      let country
      if (this.showCtfCountryDetailsInNotifications && this.showCtfCountryDetailsInNotifications !== 'none') {
        country = this.countryMap[challenge.key]
      }
      this.notifications.push({
        message,
        key: challenge.key,
        flag: challenge.flag,
        country,
        copied: false
      })
      this.ref.detectChanges()
    })
  }

  saveProgress () {
    this.challengeService.continueCode().subscribe((continueCode) => {
      if (!continueCode) {
        throw (new Error('Received invalid continue code from the server!'))
      }
      const expires = new Date()
      expires.setFullYear(expires.getFullYear() + 1)
      this.cookieService.put('continueCode', continueCode, { expires })
    }, (err) => { console.log(err) })
  }
}


/* ===== FILE: ./frontend/src/app/challenge-solved-notification/challenge-solved-notification.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<div class="container challenge-solved-toast mat-elevation-z4">
  @for (notification of notifications; track notification.key) {
    <mat-card appearance="outlined" class="accent-notification">
      <div class="mdc-card">
        <div class="notificationMessage">{{notification.message}}<button id="closeButton" mat-button (click)="closeNotification($index, $event.shiftKey)">X</button></div>
        @if (showCtfFlagsInNotifications) {
          <br/>
          <div>
            <span class="icon-box"><mat-icon>outlined_flag</mat-icon> {{notification.flag}}</span>&nbsp;
            <button ngxClipboard mat-stroked-button [cbContent]="notification.flag" (cbOnSuccess)="notification.copied = true" [disabled]="notification.copied">
              <mat-icon>content_copy</mat-icon>
              <span [hidden]="!notification.copied">{{"COPY_SUCCESS" | translate}}</span>
              <span [hidden]="notification.copied">{{"COPY_TO_CLIPBOARD" | translate}}</span>
            </button>
            <br/>
            <span *ngIf="showCtfCountryDetailsInNotifications !== 'none'" class="icon-box">
              <span
                class="fi fi-{{notification.country.code | lowercase}}"
                *ngIf="showCtfCountryDetailsInNotifications === 'flag' || showCtfCountryDetailsInNotifications === 'both'">
              </span>
              <mat-icon *ngIf="showCtfCountryDetailsInNotifications === 'name'">my_location</mat-icon>&nbsp;
              <span *ngIf="showCtfCountryDetailsInNotifications === 'name' || showCtfCountryDetailsInNotifications === 'both'">{{notification.country.name}}</span>
            </span>
          </div>
        }
      </div>
    </mat-card>
  }
</div>


/* ===== FILE: ./frontend/src/app/challenge-solved-notification/challenge-solved-notification.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { ClipboardModule } from 'ngx-clipboard'
import { MatButtonModule } from '@angular/material/button'
import { MatCardModule } from '@angular/material/card'
import { CountryMappingService } from '../Services/country-mapping.service'
import { CookieModule, CookieService } from 'ngy-cookie'
import { TranslateModule, TranslateService } from '@ngx-translate/core'
import { ChallengeService } from '../Services/challenge.service'
import { ConfigurationService } from '../Services/configuration.service'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { type ComponentFixture, fakeAsync, TestBed, tick, waitForAsync } from '@angular/core/testing'
import { SocketIoService } from '../Services/socket-io.service'

import { ChallengeSolvedNotificationComponent } from './challenge-solved-notification.component'
import { of, throwError } from 'rxjs'
import { EventEmitter } from '@angular/core'
import { MatIconModule } from '@angular/material/icon'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

class MockSocket {
  on (str: string, callback: any) {
    callback()
  }

  emit (a: any, b: any) {
    return null
  }
}

describe('ChallengeSolvedNotificationComponent', () => {
  let component: ChallengeSolvedNotificationComponent
  let fixture: ComponentFixture<ChallengeSolvedNotificationComponent>
  let socketIoService: any
  let translateService: any
  let cookieService: any
  let challengeService: any
  let configurationService: any
  let mockSocket: any

  beforeEach(waitForAsync(() => {
    mockSocket = new MockSocket()
    socketIoService = jasmine.createSpyObj('SocketIoService', ['socket'])
    socketIoService.socket.and.returnValue(mockSocket)
    translateService = jasmine.createSpyObj('TranslateService', ['get'])
    translateService.get.and.returnValue(of({}))
    translateService.onLangChange = new EventEmitter()
    translateService.onTranslationChange = new EventEmitter()
    translateService.onDefaultLangChange = new EventEmitter()
    cookieService = jasmine.createSpyObj('CookieService', ['put'])
    challengeService = jasmine.createSpyObj('ChallengeService', ['continueCode'])
    configurationService = jasmine.createSpyObj('ConfigurationService', ['getApplicationConfiguration'])
    configurationService.getApplicationConfiguration.and.returnValue(of({}))

    TestBed.configureTestingModule({
      imports: [TranslateModule.forRoot(),
        CookieModule.forRoot(),
        ClipboardModule,
        MatCardModule,
        MatButtonModule,
        MatIconModule,
        ChallengeSolvedNotificationComponent],
      providers: [
        { provide: SocketIoService, useValue: socketIoService },
        { provide: TranslateService, useValue: translateService },
        { provide: CookieService, useValue: cookieService },
        { provide: ChallengeService, useValue: challengeService },
        { provide: ConfigurationService, useValue: configurationService },
        CountryMappingService,
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(ChallengeSolvedNotificationComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should delete notifictions', () => {
    component.notifications = [
      { key: 'foo', message: 'foo', flag: '1234', copied: false },
      { key: 'bar', message: 'bar', flag: '5678', copied: false }
    ]
    component.closeNotification(0)

    expect(component.notifications).toEqual([{ key: 'bar', message: 'bar', flag: '5678', copied: false }])
  })

  it('should delete all notifications if the shiftKey was pressed', () => {
    component.notifications = [
      { key: 'foo', message: 'foo', flag: '1234', copied: false },
      { key: 'bar', message: 'bar', flag: '5678', copied: false }
    ]
    component.closeNotification(0, true)

    expect(component.notifications).toEqual([])
  })

  it('should add new notification', fakeAsync(() => {
    translateService.get.and.returnValue(of('CHALLENGE_SOLVED'))
    component.notifications = []
    component.showNotification({ key: 'test', challenge: 'Test', flag: '1234' })
    tick()

    expect(translateService.get).toHaveBeenCalledWith('CHALLENGE_SOLVED', { challenge: 'Test' })
    expect(component.notifications).toEqual([{ key: 'test', message: 'CHALLENGE_SOLVED', flag: '1234', copied: false, country: undefined }])
  }))

  it('should store retrieved continue code as cookie for 1 year', () => {
    challengeService.continueCode.and.returnValue(of('12345'))

    const expires = new Date()
    component.saveProgress()
    expires.setFullYear(expires.getFullYear() + 1)

    expect(cookieService.put).toHaveBeenCalledWith('continueCode', '12345', { expires })
  })

  it('should throw error when not supplied with a valid continue code', () => {
    challengeService.continueCode.and.returnValue(of(undefined))
    console.log = jasmine.createSpy('log')

    expect(component.saveProgress).toThrow()
  })

  it('should log error from continue code API call directly to browser console', fakeAsync(() => {
    challengeService.continueCode.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.saveProgress()
    fixture.detectChanges()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should show CTF flag codes if configured accordingly', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({ ctf: { showFlagsInNotifications: true } }))
    component.ngOnInit()

    expect(component.showCtfFlagsInNotifications).toBeTrue()
  })

  it('should hide CTF flag codes if configured accordingly', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({ ctf: { showFlagsInNotifications: false } }))
    component.ngOnInit()

    expect(component.showCtfFlagsInNotifications).toBeFalse()
  })

  it('should hide CTF flag codes by default', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({ ctf: { } }))
    component.ngOnInit()

    expect(component.showCtfFlagsInNotifications).toBeFalse()
  })

  it('should hide FBCTF-specific country details by default', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({ ctf: { } }))
    component.ngOnInit()

    expect(component.showCtfCountryDetailsInNotifications).toBe('none')
  })

  it('should not load countries for FBCTF when configured to hide country details', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({ ctf: { showCountryDetailsInNotifications: 'none' } }))
    component.ngOnInit()

    expect(component.showCtfCountryDetailsInNotifications).toBe('none')
    expect(component.countryMap).toBeUndefined()
  })
})


/* ===== FILE: ./frontend/src/app/score-board/types/EnrichedChallenge.ts ===== */

import { type Challenge } from '../../Models/challenge.model'

export interface EnrichedChallenge extends Challenge {
  originalDescription: string
  tagList: string[]
}


/* ===== FILE: ./frontend/src/app/score-board/filter-settings/query-params-converters.ts ===== */

import type { Params } from '@angular/router'

import { DEFAULT_FILTER_SETTING, type FilterSetting } from './FilterSetting'

export function fromQueryParams (queryParams: Readonly<Params>): FilterSetting {
  const filterSetting: FilterSetting = { ...structuredClone(DEFAULT_FILTER_SETTING) }
  if (queryParams.searchQuery) {
    filterSetting.searchQuery = queryParams.searchQuery
  }
  if (queryParams.difficulties) {
    filterSetting.difficulties = queryParams.difficulties
      .split(',')
      .map((difficulty) => parseInt(difficulty, 10))
      .filter((difficulty) => !isNaN(difficulty))
  }
  if (queryParams.tags) {
    filterSetting.tags = queryParams.tags.split(',')
  }
  if (queryParams.status) {
    filterSetting.status = queryParams.status
  }
  if (queryParams.categories) {
    filterSetting.categories = queryParams.categories.split(',')
  }
  if (queryParams.showDisabledChallenges !== undefined) {
    filterSetting.showDisabledChallenges = queryParams.showDisabledChallenges === 'true'
  }

  return filterSetting
}

export function toQueryParams (filterSetting: Readonly<FilterSetting>): Params {
  return {
    searchQuery: filterSetting.searchQuery ?? undefined,
    difficulties: filterSetting.difficulties.join(',') || undefined,
    status: filterSetting.status ?? undefined,
    tags: filterSetting.tags.join(',') || undefined,
    categories: filterSetting.categories.join(',') || undefined,
    showDisabledChallenges: !filterSetting.showDisabledChallenges ? 'false' : undefined
  }
}


/* ===== FILE: ./frontend/src/app/score-board/filter-settings/query-params-coverter.spec.ts ===== */

import { DEFAULT_FILTER_SETTING } from './FilterSetting'
import { fromQueryParams, toQueryParams } from './query-params-converters'

describe('fromQueryParams', () => {
  it('should convert empty settings to default filters', () => {
    expect(fromQueryParams({})).toEqual(DEFAULT_FILTER_SETTING)
  })
  it('should somewhat filled query params properly', () => {
    expect(
      fromQueryParams({
        searchQuery: 'jwt token',
        difficulties: '1',
        status: 'solved',
        categories: 'Improper Input Validation'
      })
    ).toEqual({
      ...DEFAULT_FILTER_SETTING,
      searchQuery: 'jwt token',
      difficulties: [1],
      status: 'solved',
      categories: ['Improper Input Validation']
    })
  })
  it('should fully filled query params properly', () => {
    expect(
      fromQueryParams({
        searchQuery: 'jwt token',
        difficulties: '1,3,5,6',
        status: 'partially-solved',
        tags: 'Danger Zone,Good for Demos,Prerequisite',
        categories: 'Improper Input Validation,Broken Anti Automation',
        showDisabledChallenges: 'false'
      })
    ).toEqual({
      ...DEFAULT_FILTER_SETTING,
      searchQuery: 'jwt token',
      difficulties: [1, 3, 5, 6],
      status: 'partially-solved',
      tags: ['Danger Zone', 'Good for Demos', 'Prerequisite'],
      categories: [
        'Improper Input Validation',
        'Broken Anti Automation'
      ],
      showDisabledChallenges: false
    })
  })
})

describe('toQueryParams', () => {
  it('should convert default filterSettings to empty params', () => {
    expect(
      toQueryParams(DEFAULT_FILTER_SETTING)
    ).toEqual({
      searchQuery: undefined,
      difficulties: undefined,
      status: undefined,
      tags: undefined,
      categories: undefined,
      showDisabledChallenges: undefined
    })
  })
  it('should convert somewhat filled filterSettings correctly', () => {
    expect(
      toQueryParams({
        ...DEFAULT_FILTER_SETTING,
        searchQuery: 'jwt token',
        difficulties: [1],
        status: 'solved',
        categories: ['Improper Input Validation'],
        showDisabledChallenges: false
      })
    ).toEqual({
      searchQuery: 'jwt token',
      difficulties: '1',
      status: 'solved',
      tags: undefined,
      categories: 'Improper Input Validation',
      showDisabledChallenges: 'false'
    })
  })
  it('should convert fully filled filterSettings correctly', () => {
    expect(
      toQueryParams({
        ...DEFAULT_FILTER_SETTING,
        searchQuery: 'jwt token',
        difficulties: [1, 3, 5, 6],
        status: 'partially-solved',
        tags: ['Danger Zone', 'Good for Demos', 'Prerequisite'],
        categories: ['Improper Input Validation', 'Broken Anti Automation'],
        showDisabledChallenges: false
      })
    ).toEqual({
      searchQuery: 'jwt token',
      difficulties: '1,3,5,6',
      status: 'partially-solved',
      tags: 'Danger Zone,Good for Demos,Prerequisite',
      categories: 'Improper Input Validation,Broken Anti Automation',
      showDisabledChallenges: 'false'
    })
  })
})


/* ===== FILE: ./frontend/src/app/score-board/filter-settings/FilterSetting.ts ===== */

export interface FilterSetting {
  // categories to display. if empty, all categories are displayed
  categories: string[]

  // difficulties to display. if empty, all difficulties are displayed
  difficulties: Array<1 | 2 | 3 | 4 | 5 | 6>

  // tags to display. if empty, all tags are displayed
  tags: string[]

  // status to display. if null, all status are displayed
  status: SolvedStatus | null

  // search query to search challenge names & descriptions for. if null, all challenges are displayed
  searchQuery: string | null

  // whether to show disabled challenges
  showDisabledChallenges: boolean

  // if true only challenges belonging to a tutorial are displayed until the user has solved all tutorial challenges
  restrictToTutorialChallengesFirst: boolean
}

export type SolvedStatus = 'solved' | 'unsolved' | 'partially-solved'

export const DEFAULT_FILTER_SETTING: Readonly<FilterSetting> = Object.freeze({
  categories: [],
  difficulties: [],
  tags: [],
  status: null,
  searchQuery: null,
  showDisabledChallenges: true,
  restrictToTutorialChallengesFirst: false
})


/* ===== FILE: ./frontend/src/app/score-board/score-board.component.spec.ts ===== */

import { MatProgressSpinnerModule } from '@angular/material/progress-spinner'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { type ComponentFixture, TestBed } from '@angular/core/testing'
import { RouterTestingModule } from '@angular/router/testing'
import { MatDialogModule } from '@angular/material/dialog'
import { MatIconModule } from '@angular/material/icon'
import { TranslateModule } from '@ngx-translate/core'
import { of } from 'rxjs'

import { HackingChallengeProgressScoreCardComponent } from './components/hacking-challenge-progress-score-card/hacking-challenge-progress-score-card.component'
import { CodingChallengeProgressScoreCardComponent } from './components/coding-challenge-progress-score-card/coding-challenge-progress-score-card.component'
import { ChallengesUnavailableWarningComponent } from './components/challenges-unavailable-warning/challenges-unavailable-warning.component'
import { DifficultyOverviewScoreCardComponent } from './components/difficulty-overview-score-card/difficulty-overview-score-card.component'
import { TutorialModeWarningComponent } from './components/tutorial-mode-warning/tutorial-mode-warning.component'
import { WarningCardComponent } from './components/warning-card/warning-card.component'
import { ScoreCardComponent } from './components/score-card/score-card.component'
import { ScoreBoardComponent } from './score-board.component'
import { ConfigurationService } from '../Services/configuration.service'
import { CodeSnippetService } from '../Services/code-snippet.service'
import { ChallengeService } from '../Services/challenge.service'
import { type Challenge } from '../Models/challenge.model'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

// allows to easily create a challenge with some overwrites
function createChallenge (challengeOverwrites: Partial<Challenge>): Challenge {
  return {
    name: 'foobar',
    key: 'challenge-1',
    category: 'category-blue',
    difficulty: 3,
    description: '',
    hint: '',
    tags: '',
    hintUrl: '',
    disabledEnv: null,
    solved: false,
    tutorialOrder: null,
    hasTutorial: false,
    hasSnippet: false,
    codingChallengeStatus: 0,
    mitigationUrl: '',
    hasCodingChallenge: false,
    ...challengeOverwrites
  }
}

describe('ScoreBoardComponent', () => {
  let component: ScoreBoardComponent
  let fixture: ComponentFixture<ScoreBoardComponent>
  let challengeService
  let codeSnippetService
  let configService

  beforeEach(async () => {
    challengeService = jasmine.createSpyObj('ChallengeService', ['find'])
    codeSnippetService = jasmine.createSpyObj('CodeSnippetService', [
      'challenges'
    ])
    configService = jasmine.createSpyObj('ConfigurationService', [
      'getApplicationConfiguration'
    ])
    await TestBed.configureTestingModule({
      imports: [TranslateModule.forRoot(),
        RouterTestingModule,
        MatProgressSpinnerModule,
        MatDialogModule,
        MatIconModule,
        ScoreBoardComponent,
        HackingChallengeProgressScoreCardComponent,
        CodingChallengeProgressScoreCardComponent,
        DifficultyOverviewScoreCardComponent,
        WarningCardComponent,
        ChallengesUnavailableWarningComponent,
        TutorialModeWarningComponent,
        ScoreCardComponent,
        BrowserAnimationsModule],
      providers: [
        { provide: ChallengeService, useValue: challengeService },
        { provide: CodeSnippetService, useValue: codeSnippetService },
        { provide: ConfigurationService, useValue: configService },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    }).compileComponents()

    challengeService.find.and.returnValue(
      of([
        createChallenge({
          name: 'Challenge 1',
          key: 'challenge-1',
          category: 'category-blue',
          difficulty: 1,
          solved: true
        }),
        createChallenge({
          name: 'Challenge 2',
          key: 'challenge-2',
          category: 'category-blue',
          difficulty: 5,
          solved: false,
          hasSnippet: true,
          codingChallengeStatus: 1
        }),
        createChallenge({
          name: 'Challenge 3',
          key: 'challenge-3',
          category: 'category-red',
          difficulty: 3,
          hasSnippet: true,
          solved: false
        })
      ])
    )
    codeSnippetService.challenges.and.returnValue(of(['challenge-2']))
    configService.getApplicationConfiguration.and.returnValue(
      of({
        challenges: {
          restrictToTutorialsFirst: false,
          codingChallengesEnabled: 'solved',
          showHints: true,
          showMitigations: true
        },
        ctf: {
          showFlagsInNotifications: true
        },
        hackingInstructor: {
          isEnabled: true
        }
      })
    )

    fixture = TestBed.createComponent(ScoreBoardComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should not filter any challenges on default settings', (): void => {
    expect(component.filteredChallenges).toHaveSize(3)
  })

  it('should mark challenges as solved on "challenge solved" websocket', (): void => {
    expect(
      component.filteredChallenges.find(
        (challenge) => challenge.key === 'challenge-3'
      ).solved
    ).toBeFalse()

    component.onChallengeSolvedWebsocket({
      key: 'challenge-3',
      name: '',
      challenge: '',
      flag: '',
      hidden: false,
      isRestore: false
    })

    expect(
      component.filteredChallenges.find(
        (challenge) => challenge.key === 'challenge-3'
      ).solved
    ).toBeTrue()
  })

  it('should mark find it code challenges as solved on "code challenge solved" websocket', (): void => {
    expect(
      component.filteredChallenges.find(
        (challenge) => challenge.key === 'challenge-3'
      ).codingChallengeStatus
    ).toBe(0)

    component.onCodeChallengeSolvedWebsocket({
      key: 'challenge-3',
      codingChallengeStatus: 1
    })

    expect(
      component.filteredChallenges.find(
        (challenge) => challenge.key === 'challenge-3'
      ).codingChallengeStatus
    ).toBe(1)
  })

  it('should mark fix it code challenges as solved on "code challenge solved" websocket', (): void => {
    expect(
      component.filteredChallenges.find(
        (challenge) => challenge.key === 'challenge-2'
      ).codingChallengeStatus
    ).toBe(1)

    component.onCodeChallengeSolvedWebsocket({
      key: 'challenge-2',
      codingChallengeStatus: 2
    })

    expect(
      component.filteredChallenges.find(
        (challenge) => challenge.key === 'challenge-2'
      ).codingChallengeStatus
    ).toBe(2)
  })
})


/* ===== FILE: ./frontend/src/app/score-board/pipes/challenge-hint.pipe.ts ===== */

import { TranslateService } from '@ngx-translate/core'
import { Pipe, type PipeTransform } from '@angular/core'
import { type Observable, of } from 'rxjs'
import { map } from 'rxjs/operators'

interface ChallengeHintPipeArgs {
  hintUrl: string | null
}

@Pipe({
  name: 'challengeHint',
  pure: false,
  standalone: true
})
export class ChallengeHintPipe implements PipeTransform {
  constructor (private readonly translate: TranslateService) { }

  transform (hint: string, args: ChallengeHintPipeArgs = { hintUrl: null }): Observable<string> {
    if (args.hintUrl) {
      return this.translate.get('CLICK_FOR_MORE_HINTS').pipe(map((translation) => `${hint} ${translation as string}`))
    }
    return of(hint)
  }
}


/* ===== FILE: ./frontend/src/app/score-board/components/filter-settings/filter-settings.component.html ===== */

<div class="filter-row">
  <div class="search-form-field">
    <mat-form-field>
      <mat-icon matPrefix class="search-icon">search</mat-icon>
      <mat-label>{{ 'NAV_SEARCH' | translate }}</mat-label>
      <input type="search" matInput [value]="filterSetting.searchQuery" (input)="onSearchQueryFilterChange($event.target.value)">
    </mat-form-field>
  </div>
  <div class="options-group">
    <mat-form-field>
      <mat-label>{{ 'LABEL_DIFFICULTY' | translate }}</mat-label>
      <mat-select multiple [value]="filterSetting.difficulties" (selectionChange)="onDifficultyFilterChange($event.value)">
        <mat-select-trigger>
          <ng-container *ngIf="filterSetting.difficulties.length === 0">
            {{ 'LABEL_DIFFICULTY' | translate }}
          </ng-container>
          <span *ngIf="filterSetting.difficulties.length !== 0">
            {{ filterSetting.difficulties | difficultySelectionSummary }}
          </span>
        </mat-select-trigger>
        <mat-option [value]="1">
          <difficulty-stars [difficulty]="1"></difficulty-stars>
        </mat-option>
        <mat-option [value]="2">
          <difficulty-stars [difficulty]="2"></difficulty-stars>
        </mat-option>
        <mat-option [value]="3">
          <difficulty-stars [difficulty]="3"></difficulty-stars>
        </mat-option>
        <mat-option [value]="4">
          <difficulty-stars [difficulty]="4"></difficulty-stars>
        </mat-option>
        <mat-option [value]="5">
          <difficulty-stars [difficulty]="5"></difficulty-stars>
        </mat-option>
        <mat-option [value]="6">
          <difficulty-stars [difficulty]="6"></difficulty-stars>
        </mat-option>
      </mat-select>
    </mat-form-field>
    <mat-form-field>
      <mat-label translate>LABEL_STATUS</mat-label>
      <mat-select placeholder="All" [value]="filterSetting.status" (selectionChange)="onStatusFilterChange($event.value)">
        <mat-option [value]="null" class="mat-body">{{ 'STATUS_ALL' | translate }}</mat-option>
        <mat-option value="unsolved" class="mat-body">{{ 'STATUS_UNSOLVED' | translate }}</mat-option>
        <mat-option value="partially-solved" class="mat-body">{{ 'STATUS_PARTIALLY_SOLVED' | translate }}</mat-option>
        <mat-option value="solved" class="mat-body">{{ 'STATUS_SOLVED' | translate }}</mat-option>
      </mat-select>
    </mat-form-field>
    <mat-form-field>
      <mat-label>{{ 'LABEL_TAGS' | translate }}</mat-label>
      <mat-select multiple [value]="filterSetting.tags" (selectionChange)="onTagFilterChange($event.value)">
        <mat-option *ngFor="let tag of tags" [value]="tag" class="mat-body">{{ tag }}</mat-option>
      </mat-select>
    </mat-form-field>
    <div class="additional-settings-wrapper">
      <div class="reset-filters-wrapper">
        <button id="reset-filters" mat-icon-button aria-label="reset all filters" (click)="reset()" [matTooltip]="'LABEL_RESET_ALL_FILTERS' | translate">
          <!-- inlined svg icon as the "filter_alt_off" isn't included in our icons. -->
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" [style.color]="canBeReset() ? 'var(--theme-warn)' : 'var(--theme-text-dark)'">
            <path d="M12.2442 2.96672L9.56672 6.37922L10.6392 7.45172C11.4117 6.46922 14.3742 2.67422 14.3742 2.67422C14.7567 2.17922 14.4042 1.46672 13.7817 1.46672H4.65422L6.15422 2.96672H12.2442Z" fill="currentColor"/>
            <path d="M1.63922 0.574219L0.574219 1.63172L7.03172 8.21672V12.7167C7.03172 13.1292 7.36922 13.4667 7.78172 13.4667H9.28172C9.69422 13.4667 10.0317 13.1292 10.0317 12.7167V11.0892L14.3667 15.4242L15.4242 14.3667L1.63922 0.574219Z" fill="currentColor"/>
          </svg>
        </button>
        <label class="reset-filters-label" for="reset-filters">{{ 'LABEL_RESET_ALL_FILTERS' | translate }}</label>
      </div>
      <button class="additional-settings-button" mat-icon-button aria-label="Open additional settings dialog" (click)="openAdditionalSettingsDialog()" [matTooltip]="'Open additional settings dialog'">
        <mat-icon>settings</mat-icon>
      </button>
    </div>
  </div>
</div>

<category-filter
  [categories]="filterSetting.categories"
  (categoriesChange)="onCategoryFilterChange($event)"
  [allChallenges]="allChallenges"
></category-filter>


/* ===== FILE: ./frontend/src/app/score-board/components/filter-settings/filter-settings.component.spec.ts ===== */

import { type ComponentFixture, TestBed } from '@angular/core/testing'
import { FilterSettingsComponent } from './filter-settings.component'
import { CategoryFilterComponent } from './components/category-filter/category-filter.component'
import { DEFAULT_FILTER_SETTING } from '../../filter-settings/FilterSetting'
import { TranslateModule } from '@ngx-translate/core'
import { MatFormFieldModule } from '@angular/material/form-field'
import { MatInputModule } from '@angular/material/input'
import { MatSelectModule } from '@angular/material/select'
import { NoopAnimationsModule } from '@angular/platform-browser/animations'
import { MatTooltipModule } from '@angular/material/tooltip'
import { MatDialogModule, MatDialog } from '@angular/material/dialog'
import { DifficultySelectionSummaryPipe } from './pipes/difficulty-selection-summary.pipe'
import { LocalBackupService } from 'src/app/Services/local-backup.service'

describe('FilterSettingsComponent', () => {
  let component: FilterSettingsComponent
  let fixture: ComponentFixture<FilterSettingsComponent>
  let dialog: MatDialog

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [
        NoopAnimationsModule,
        TranslateModule.forRoot(),
        MatFormFieldModule,
        MatInputModule,
        MatSelectModule,
        MatTooltipModule,
        MatDialogModule,
        FilterSettingsComponent,
        CategoryFilterComponent,
        DifficultySelectionSummaryPipe
      ],
      providers: [
        {
          provide: LocalBackupService,
          useValue: {
            save: () => null,
            restore: () => null
          }
        }
      ]
    }).compileComponents()

    fixture = TestBed.createComponent(FilterSettingsComponent)
    component = fixture.componentInstance
    dialog = TestBed.inject(MatDialog)

    component.allChallenges = []
    component.filterSetting = { ...DEFAULT_FILTER_SETTING }

    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should not be possible to reset filter when default filters are set', () => {
    component.filterSetting = { ...DEFAULT_FILTER_SETTING }
    expect(component.canBeReset()).toBeFalse()
  })

  it('should be possible to reset difficulty filter', () => {
    component.filterSetting = { ...DEFAULT_FILTER_SETTING, difficulties: [1] }
    expect(component.canBeReset()).toBeTrue()
  })

  it('should be possible to reset status filter', () => {
    component.filterSetting = { ...DEFAULT_FILTER_SETTING, status: 'unsolved' }
    expect(component.canBeReset()).toBeTrue()
  })

  it('should be possible to reset tag filter', () => {
    component.filterSetting = { ...DEFAULT_FILTER_SETTING, tags: ['tag1'] }
    expect(component.canBeReset()).toBeTrue()
  })

  it('should be possible to reset category filter', () => {
    component.filterSetting = { ...DEFAULT_FILTER_SETTING, categories: ['category1'] }
    expect(component.canBeReset()).toBeTrue()
  })

  it('should be possible to reset search filter', () => {
    component.filterSetting = { ...DEFAULT_FILTER_SETTING, searchQuery: 'sqli' }
    expect(component.canBeReset()).toBeTrue()
  })

  it('should be possible to reset filter for disabled challenges', () => {
    component.filterSetting = { ...DEFAULT_FILTER_SETTING, showDisabledChallenges: false }
    expect(component.canBeReset()).toBeTrue()
  })

  it('should open additional settings dialog', () => {
    spyOn(dialog, 'open')
    component.openAdditionalSettingsDialog()
    expect(dialog.open).toHaveBeenCalled()
  })

  it('should emit difficulty filter change', () => {
    spyOn(component.filterSettingChange, 'emit')
    const difficulties = [1, 2, 3]
    component.onDifficultyFilterChange([1, 2, 3])
    expect(component.filterSettingChange.emit).toHaveBeenCalledWith(jasmine.objectContaining({ difficulties }))
  })

  it('should emit status filter change', () => {
    spyOn(component.filterSettingChange, 'emit')
    const status = 'unsolved'
    component.onStatusFilterChange(status)
    expect(component.filterSettingChange.emit).toHaveBeenCalledWith(jasmine.objectContaining({ status }))
  })

  it('should emit tag filter change', () => {
    spyOn(component.filterSettingChange, 'emit')
    const tags = ['tag1', 'tag2']
    component.onTagFilterChange(tags)
    expect(component.filterSettingChange.emit).toHaveBeenCalledWith(jasmine.objectContaining({ tags }))
  })

  it('should emit category filter change', () => {
    spyOn(component.filterSettingChange, 'emit')
    const categories = ['category1', 'category2']
    component.onCategoryFilterChange(categories)
    expect(component.filterSettingChange.emit).toHaveBeenCalledWith(jasmine.objectContaining({ categories }))
  })

  it('should emit search query filter change', () => {
    spyOn(component.filterSettingChange, 'emit')
    const searchQuery = 'query'
    component.onSearchQueryFilterChange(searchQuery)
    expect(component.filterSettingChange.emit).toHaveBeenCalledWith(jasmine.objectContaining({ searchQuery }))
  })
})


/* ===== FILE: ./frontend/src/app/score-board/components/filter-settings/pipes/difficulty-selection-summary.pipe.spec.ts ===== */

import { DifficultySelectionSummaryPipe } from './difficulty-selection-summary.pipe'

describe('DifficultySelectionSummaryPipe', () => {
  let pipe: DifficultySelectionSummaryPipe

  beforeEach(async () => {
    pipe = new DifficultySelectionSummaryPipe()
  })

  it('should properly summarize selected difficulties', () => {
    expect(pipe.transform([])).toBe('')
    expect(pipe.transform([1])).toBe('1')
    expect(pipe.transform([1, 3, 5])).toBe('1, 3, 5')
    expect(pipe.transform([1, 2, 3, 5])).toBe('1 - 3, 5')
    expect(pipe.transform([1, 3, 4, 5])).toBe('1, 3 - 5')
    expect(pipe.transform([1, 2, 4, 5, 6])).toBe('1 - 2, 4 - 6')
    expect(pipe.transform([1, 2, 3, 4, 5, 6])).toBe('1 - 6')
  })
})


/* ===== FILE: ./frontend/src/app/score-board/components/filter-settings/pipes/difficulty-selection-summary.pipe.ts ===== */

import { Pipe, type PipeTransform } from '@angular/core'

import sortBy from 'lodash-es/sortBy'

interface DifficultyGroup {
  start: number
  end: number
}

@Pipe({
  name: 'difficultySelectionSummary',
  pure: true,
  standalone: true
})
export class DifficultySelectionSummaryPipe implements PipeTransform {
  transform (selectedDifficulties: Array<1 | 2 | 3 | 4 | 5 | 6>): string {
    if (selectedDifficulties.length === 0) {
      return ''
    }

    const sortedDifficulties = sortBy(selectedDifficulties)
    const difficultyGroups = breakDifficultiesIntoNeighboringGroups(sortedDifficulties)
    return convertDifficultyGroupsToString(difficultyGroups)
  }
}

function breakDifficultiesIntoNeighboringGroups (difficulties: Array<1 | 2 | 3 | 4 | 5 | 6>): DifficultyGroup[] {
  const difficultyGroups: DifficultyGroup[] = []
  let currentGroup: DifficultyGroup = null
  for (const difficulty of difficulties) {
    if (currentGroup === null) {
      currentGroup = { start: difficulty, end: difficulty }
    } else {
      if (difficulty === currentGroup.end + 1) {
        currentGroup.end = difficulty
      } else {
        difficultyGroups.push(currentGroup)
        currentGroup = { start: difficulty, end: difficulty }
      }
    }
  }
  difficultyGroups.push(currentGroup)
  return difficultyGroups
}

function convertDifficultyGroupsToString (difficultyGroups: DifficultyGroup[]): string {
  return difficultyGroups.map(group => {
    if (group.start === group.end) {
      return group.start.toString()
    } else {
      return `${group.start} - ${group.end}`
    }
  }).join(', ')
}


/* ===== FILE: ./frontend/src/app/score-board/components/filter-settings/filter-settings.component.ts ===== */

import { Component, EventEmitter, Input, type OnChanges, Output } from '@angular/core'
import { FilterSetting } from '../../filter-settings/FilterSetting'
import { type EnrichedChallenge } from '../../types/EnrichedChallenge'
import { MatDialog } from '@angular/material/dialog'
import { ScoreBoardAdditionalSettingsDialogComponent } from './components/score-board-additional-settings-dialog/score-board-additional-settings-dialog.component'
import { DifficultySelectionSummaryPipe } from './pipes/difficulty-selection-summary.pipe'
import { CategoryFilterComponent } from './components/category-filter/category-filter.component'
import { MatTooltip } from '@angular/material/tooltip'
import { MatIconButton } from '@angular/material/button'
import { DifficultyStarsComponent } from '../difficulty-stars/difficulty-stars.component'
import { MatOption } from '@angular/material/core'
import { NgIf, NgFor } from '@angular/common'
import { MatSelect, MatSelectTrigger } from '@angular/material/select'
import { MatInputModule } from '@angular/material/input'
import { TranslateModule } from '@ngx-translate/core'
import { MatIconModule } from '@angular/material/icon'
import { MatFormFieldModule, MatPrefix, MatLabel } from '@angular/material/form-field'

@Component({
  selector: 'filter-settings',
  templateUrl: './filter-settings.component.html',
  styleUrls: ['./filter-settings.component.scss'],
  imports: [MatFormFieldModule, MatIconModule, MatPrefix, MatLabel, TranslateModule, MatInputModule, MatSelect, MatSelectTrigger, NgIf, MatOption, DifficultyStarsComponent, NgFor, MatIconButton, MatTooltip, CategoryFilterComponent, DifficultySelectionSummaryPipe]
})
export class FilterSettingsComponent implements OnChanges {
  @Input()
  public allChallenges: EnrichedChallenge[]

  @Input()
  public filterSetting: FilterSetting

  @Output()
  public filterSettingChange = new EventEmitter<FilterSetting>()

  @Input()
  public reset: () => void

  constructor (private readonly dialog: MatDialog) { }

  public tags = new Set<string>()
  ngOnChanges () {
    this.tags = new Set(this.allChallenges.flatMap((challenge) => challenge.tagList))
  }

  onDifficultyFilterChange (difficulties: Array<1 | 2 | 3 | 4 | 5 | 6>) {
    const filterSettingCopy = structuredClone(this.filterSetting)
    filterSettingCopy.difficulties = difficulties
    this.filterSettingChange.emit(filterSettingCopy)
  }

  onStatusFilterChange (status: 'solved' | 'unsolved' | null) {
    const filterSettingCopy = structuredClone(this.filterSetting)
    filterSettingCopy.status = status
    this.filterSettingChange.emit(filterSettingCopy)
  }

  onTagFilterChange (tags: string[]) {
    const filterSettingCopy = structuredClone(this.filterSetting)
    filterSettingCopy.tags = tags
    this.filterSettingChange.emit(filterSettingCopy)
  }

  onCategoryFilterChange (categories: string[]) {
    const filterSettingCopy = structuredClone(this.filterSetting)
    filterSettingCopy.categories = categories
    this.filterSettingChange.emit(filterSettingCopy)
  }

  onSearchQueryFilterChange (searchQuery: string) {
    const filterSettingCopy = structuredClone(this.filterSetting)
    filterSettingCopy.searchQuery = searchQuery
    this.filterSettingChange.emit(filterSettingCopy)
  }

  public canBeReset (): boolean {
    return this.filterSetting.difficulties.length > 0 ||
      this.filterSetting.status !== null ||
      this.filterSetting.tags.length > 0 ||
      this.filterSetting.categories.length > 0 ||
      !!this.filterSetting.searchQuery ||
      !this.filterSetting.showDisabledChallenges
  }

  public openAdditionalSettingsDialog () {
    this.dialog.open(ScoreBoardAdditionalSettingsDialogComponent)
  }
}


/* ===== FILE: ./frontend/src/app/score-board/components/filter-settings/components/category-filter/category-filter.component.html ===== */

<button
  class="pill selected"
  (click)="resetCategoryFilter()"
  [ngClass]="{ selected: isAllCategoriesSelected() }"
>
  All
</button>
<button
  *ngFor="let category of availableCategories"
  class="pill"
  [ngClass]="{ selected: isCategorySelected(category) }"
  (click)="toggleCategorySelected(category)"
  [matTooltip]="'CATEGORY_' + category.toUpperCase().split(' ').join('_') + '_DESCRIPTION' | translate"
>
  {{ category }}
</button>


/* ===== FILE: ./frontend/src/app/score-board/components/filter-settings/components/category-filter/category-filter.component.ts ===== */

import { Component, EventEmitter, Input, type OnChanges, type OnInit, Output } from '@angular/core'
import { type EnrichedChallenge } from '../../../../types/EnrichedChallenge'
import { DEFAULT_FILTER_SETTING } from '../../../../filter-settings/FilterSetting'
import { TranslateModule } from '@ngx-translate/core'
import { MatTooltip } from '@angular/material/tooltip'
import { NgClass, NgFor } from '@angular/common'

@Component({
  selector: 'category-filter',
  templateUrl: './category-filter.component.html',
  styleUrls: ['./category-filter.component.scss'],
  imports: [NgClass, NgFor, MatTooltip, TranslateModule]
})
export class CategoryFilterComponent implements OnInit, OnChanges {
  public availableCategories = new Set<string>()

  @Input()
    allChallenges: EnrichedChallenge[]

  @Input()
    categories: string[]

  @Output()
    categoriesChange = new EventEmitter<string[]>()

  ngOnInit (): void {
    this.availableCategories = CategoryFilterComponent.getAvailableCategories(this.allChallenges)
  }

  ngOnChanges () {
    this.availableCategories = CategoryFilterComponent.getAvailableCategories(this.allChallenges)
  }

  public static getAvailableCategories (allChallenges: EnrichedChallenge[]) {
    return new Set(allChallenges.map((challenge) => challenge.category))
  }

  public toggleCategorySelected (category: string) {
    if (this.isCategorySelected(category)) {
      this.categories = this.categories.filter((c) => c !== category)
    } else {
      this.categories.push(category)
    }
    this.categoriesChange.emit(this.categories)
  }

  public isCategorySelected (category: string) {
    return this.categories.includes(category)
  }

  public isAllCategoriesSelected () {
    return (this.categories.length === 0)
  }

  public resetCategoryFilter () {
    this.categories = DEFAULT_FILTER_SETTING.categories
    this.categoriesChange.emit(this.categories)
  }
}


/* ===== FILE: ./frontend/src/app/score-board/components/filter-settings/components/category-filter/category-filter.component.spec.ts ===== */

import { type ComponentFixture, TestBed } from '@angular/core/testing'

import { CategoryFilterComponent } from './category-filter.component'
import { type EnrichedChallenge } from 'src/app/score-board/types/EnrichedChallenge'
import { TranslateModule } from '@ngx-translate/core'
import { MatTooltipModule } from '@angular/material/tooltip'

describe('CategoryFilterComponent', () => {
  let component: CategoryFilterComponent
  let fixture: ComponentFixture<CategoryFilterComponent>

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [
        TranslateModule.forRoot(),
        MatTooltipModule,
        CategoryFilterComponent
      ]
    })
      .compileComponents()

    fixture = TestBed.createComponent(CategoryFilterComponent)
    component = fixture.componentInstance

    component.allChallenges = [
      { category: 'category-one' } as EnrichedChallenge,
      { category: 'category-one' } as EnrichedChallenge,
      { category: 'category-two' } as EnrichedChallenge,
      { category: 'category-three' } as EnrichedChallenge
    ]
    component.categories = []
    fixture.detectChanges()
  })

  it('should extract all categories from passed in challenges', () => {
    const availableCategories = CategoryFilterComponent.getAvailableCategories(component.allChallenges)
    expect(availableCategories).toContain('category-one')
    expect(availableCategories).toContain('category-two')
    expect(availableCategories).toContain('category-three')
  })

  it('toggle should add and remove selected categories', () => {
    component.toggleCategorySelected('category-one')
    expect(component.categories).toContain('category-one')
    expect(component.isCategorySelected('category-one')).toBe(true)
    component.toggleCategorySelected('category-one')
    expect(component.categories).not.toContain('category-one')
    expect(component.isCategorySelected('category-one')).toBe(false)
  })

  it('reset should clear categories', () => {
    component.toggleCategorySelected('category-one')
    component.toggleCategorySelected('category-two')
    expect(component.isAllCategoriesSelected()).toBe(false)
    component.resetCategoryFilter()
    expect(component.isAllCategoriesSelected()).toBe(true)
  })
})


/* ===== FILE: ./frontend/src/app/score-board/components/filter-settings/components/score-board-additional-settings-dialog/score-board-additional-settings-dialog.component.ts ===== */

import { Component } from '@angular/core'
import { LocalBackupService } from 'src/app/Services/local-backup.service'
import { MatIconModule } from '@angular/material/icon'
import { MatButtonModule } from '@angular/material/button'
import { TranslateModule } from '@ngx-translate/core'
import { MatDialogContent, MatDialogTitle, MatDialogActions, MatDialogClose } from '@angular/material/dialog'

@Component({
  selector: 'score-board-additional-settings-dialog',
  templateUrl: './score-board-additional-settings-dialog.component.html',
  styleUrls: ['./score-board-additional-settings-dialog.component.scss'],
  imports: [MatDialogContent, MatDialogTitle, TranslateModule, MatButtonModule, MatIconModule, MatDialogActions, MatDialogClose]
})
export class ScoreBoardAdditionalSettingsDialogComponent {
  constructor (
    public localBackupService: LocalBackupService
  ) {}
}


/* ===== FILE: ./frontend/src/app/score-board/components/filter-settings/components/score-board-additional-settings-dialog/score-board-additional-settings-dialog.component.html ===== */

<mat-dialog-content>
  <h1 mat-dialog-title translate>{{"SCOREBOARD_ADDITIONAL_SETTINGS" | translate}}</h1>

  <div class="settings">
    <div class="setting-group">
      <h2>{{"BACKUP_HEADLINE" | translate}}</h2>
      <div class="setting">
        <span>{{"SAVE_BACKUP_TOOLTIP" | translate }}</span>
        <button mat-flat-button color="primary" (click)="localBackupService.save()"><mat-icon>save_alt</mat-icon><span class="tooltip">{{"BTN_SAVE_BACKUP" | translate}}</span></button>
      </div>
      <div class="setting">
        <input type="file"
          #restoreBackupFile
          (change)="localBackupService.restore($event.target.files.item(0))"
          style="display:none;" />
        <span>{{"RESTORE_BACKUP_TOOLTIP" | translate }}</span>
        <button mat-flat-button color="primary" (click)="restoreBackupFile.click()"><mat-icon>settings_backup_restore</mat-icon><span class="tooltip">{{"BTN_RESTORE_BACKUP" | translate  }}</span></button>
      </div>
    </div>
  </div>

  <mat-dialog-actions>
    <button class="close-btn" mat-flat-button [mat-dialog-close]="null" cdkFocusInitial>
      {{ "BTN_CLOSE" | translate }}
    </button>
  </mat-dialog-actions>
</mat-dialog-content>


/* ===== FILE: ./frontend/src/app/score-board/components/filter-settings/components/score-board-additional-settings-dialog/score-board-additional-settings-dialog.component.spec.ts ===== */

import { type ComponentFixture, TestBed } from '@angular/core/testing'

import { ScoreBoardAdditionalSettingsDialogComponent } from './score-board-additional-settings-dialog.component'
import { TranslateModule } from '@ngx-translate/core'
import { MatDialogModule } from '@angular/material/dialog'
import { LocalBackupService } from 'src/app/Services/local-backup.service'

describe('ScoreBoardAdditionalSettingsDialogComponent', () => {
  let component: ScoreBoardAdditionalSettingsDialogComponent
  let fixture: ComponentFixture<ScoreBoardAdditionalSettingsDialogComponent>

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [TranslateModule.forRoot(), MatDialogModule, ScoreBoardAdditionalSettingsDialogComponent],
      providers: [
        {
          provide: LocalBackupService,
          useValue: {
            save: () => null,
            restore: () => null
          }
        }
      ]
    }).compileComponents()

    fixture = TestBed.createComponent(
      ScoreBoardAdditionalSettingsDialogComponent
    )
    component = fixture.componentInstance

    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })
})


/* ===== FILE: ./frontend/src/app/score-board/components/difficulty-overview-score-card/difficulty-overview-score-card.component.ts ===== */

import { Component, Input, type OnChanges, type OnInit, type SimpleChanges } from '@angular/core'

import { type EnrichedChallenge } from '../../types/EnrichedChallenge'
import { TranslateModule } from '@ngx-translate/core'
import { NgFor, NgIf } from '@angular/common'
import { ScoreCardComponent } from '../score-card/score-card.component'

interface DifficultySummary {
  difficulty: 0 | 1 | 2 | 3 | 4 | 5 | 6
  availableChallenges: number
  solvedChallenges: number
}

// interface doesn't work here
// eslint-disable-next-line @typescript-eslint/consistent-type-definitions
type DifficultySummaries = Record<number, DifficultySummary>

const INITIAL_SUMMARIES: Readonly<DifficultySummaries> = Object.freeze({
  1: { difficulty: 1, availableChallenges: 0, solvedChallenges: 0 },
  2: { difficulty: 2, availableChallenges: 0, solvedChallenges: 0 },
  3: { difficulty: 3, availableChallenges: 0, solvedChallenges: 0 },
  4: { difficulty: 4, availableChallenges: 0, solvedChallenges: 0 },
  5: { difficulty: 5, availableChallenges: 0, solvedChallenges: 0 },
  6: { difficulty: 6, availableChallenges: 0, solvedChallenges: 0 }
})

@Component({
  selector: 'difficulty-overview-score-card',
  templateUrl: './difficulty-overview-score-card.component.html',
  styleUrls: ['./difficulty-overview-score-card.component.scss'],
  imports: [ScoreCardComponent, NgFor, NgIf, TranslateModule]
})
export class DifficultyOverviewScoreCardComponent implements OnInit, OnChanges {
  @Input()
  public allChallenges: EnrichedChallenge[] = []

  // includes hacking and coding challenges (both find it and fix it)
  public totalChallenges: number
  public solvedChallenges: number

  public difficultySummaries: DifficultySummary[] = [
    { difficulty: 1, availableChallenges: 0, solvedChallenges: 0 },
    { difficulty: 2, availableChallenges: 0, solvedChallenges: 0 },
    { difficulty: 3, availableChallenges: 0, solvedChallenges: 0 },
    { difficulty: 4, availableChallenges: 0, solvedChallenges: 0 },
    { difficulty: 5, availableChallenges: 0, solvedChallenges: 0 },
    { difficulty: 6, availableChallenges: 0, solvedChallenges: 0 }
  ]

  ngOnInit (): void {
    this.updatedNumberOfSolvedChallenges()
  }

  ngOnChanges (changes: SimpleChanges): void {
    this.updatedNumberOfSolvedChallenges()
  }

  private updatedNumberOfSolvedChallenges (): void {
    const solvedHackingChallenges = this.allChallenges
      .filter((challenge) => challenge.solved).length
    const availableCodingChallenges = this.allChallenges
      .filter((challenge) => challenge.hasCodingChallenge)

    const codingScore = availableCodingChallenges
      .map((challenge) => challenge.codingChallengeStatus)
      .reduce((a, b) => a + b, 0) // sum up the scores

    this.difficultySummaries = DifficultyOverviewScoreCardComponent.calculateDifficultySummaries(this.allChallenges)

    this.totalChallenges = this.allChallenges.length + availableCodingChallenges.length * 2
    this.solvedChallenges = solvedHackingChallenges + codingScore
  }

  static calculateDifficultySummaries (challenges: EnrichedChallenge[]): DifficultySummary[] {
    const summariesLookup: DifficultySummaries = structuredClone(INITIAL_SUMMARIES)
    for (const challenge of challenges) {
      summariesLookup[challenge.difficulty].availableChallenges += challenge.hasCodingChallenge ? 3 : 1
      if (challenge.solved) {
        summariesLookup[challenge.difficulty].solvedChallenges++
        summariesLookup[challenge.difficulty].solvedChallenges += challenge.hasCodingChallenge ? challenge.codingChallengeStatus : 0
      }
    }
    return Object.values(summariesLookup)
      .sort((a, b) => a.difficulty - b.difficulty)
  }
}


/* ===== FILE: ./frontend/src/app/score-board/components/difficulty-overview-score-card/difficulty-overview-score-card.component.spec.ts ===== */

import { type ComponentFixture, TestBed } from '@angular/core/testing'

import { DifficultyOverviewScoreCardComponent } from './difficulty-overview-score-card.component'
import { ScoreCardComponent } from '../score-card/score-card.component'
import { TranslateModule } from '@ngx-translate/core'

describe('DifficultyOverviewScoreCardComponent', () => {
  let component: DifficultyOverviewScoreCardComponent
  let fixture: ComponentFixture<DifficultyOverviewScoreCardComponent>

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [TranslateModule.forRoot(), ScoreCardComponent,
        DifficultyOverviewScoreCardComponent]
    })
      .compileComponents()

    fixture = TestBed.createComponent(DifficultyOverviewScoreCardComponent)
    component = fixture.componentInstance
    component.allChallenges = []
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  describe('difficultySummaries', () => {
    it('should calculate difficulty summaries correctly for empty list of challenges', () => {
      expect(DifficultyOverviewScoreCardComponent.calculateDifficultySummaries([])).toEqual([
        { difficulty: 1, availableChallenges: 0, solvedChallenges: 0 },
        { difficulty: 2, availableChallenges: 0, solvedChallenges: 0 },
        { difficulty: 3, availableChallenges: 0, solvedChallenges: 0 },
        { difficulty: 4, availableChallenges: 0, solvedChallenges: 0 },
        { difficulty: 5, availableChallenges: 0, solvedChallenges: 0 },
        { difficulty: 6, availableChallenges: 0, solvedChallenges: 0 }
      ])
    })
    it('should calculate difficulty summaries', () => {
      expect(DifficultyOverviewScoreCardComponent.calculateDifficultySummaries([
        { difficulty: 1, solved: true, hasCodingChallenge: false } as any,
        { difficulty: 1, solved: true, hasCodingChallenge: true, codingChallengeStatus: 1 } as any
      ])).toEqual([
        { difficulty: 1, availableChallenges: 4, solvedChallenges: 3 },
        { difficulty: 2, availableChallenges: 0, solvedChallenges: 0 },
        { difficulty: 3, availableChallenges: 0, solvedChallenges: 0 },
        { difficulty: 4, availableChallenges: 0, solvedChallenges: 0 },
        { difficulty: 5, availableChallenges: 0, solvedChallenges: 0 },
        { difficulty: 6, availableChallenges: 0, solvedChallenges: 0 }
      ])
    })
    it('should calculate difficulty summaries for multiple difficulties', () => {
      expect(DifficultyOverviewScoreCardComponent.calculateDifficultySummaries([
        { difficulty: 1, solved: true, hasCodingChallenge: true, codingChallengeStatus: 0 } as any,
        { difficulty: 1, solved: true, hasCodingChallenge: true, codingChallengeStatus: 0 } as any,
        { difficulty: 1, solved: true, hasCodingChallenge: true, codingChallengeStatus: 1 } as any,
        { difficulty: 1, solved: true, hasCodingChallenge: true, codingChallengeStatus: 2 } as any,
        { difficulty: 1, solved: false, hasCodingChallenge: true, codingChallengeStatus: 0 } as any,
        { difficulty: 2, solved: true, hasCodingChallenge: true, codingChallengeStatus: 0 } as any,
        { difficulty: 3, solved: false, hasCodingChallenge: true, codingChallengeStatus: 0 } as any
      ])).toEqual([
        { difficulty: 1, availableChallenges: 15, solvedChallenges: 7 },
        { difficulty: 2, availableChallenges: 3, solvedChallenges: 1 },
        { difficulty: 3, availableChallenges: 3, solvedChallenges: 0 },
        { difficulty: 4, availableChallenges: 0, solvedChallenges: 0 },
        { difficulty: 5, availableChallenges: 0, solvedChallenges: 0 },
        { difficulty: 6, availableChallenges: 0, solvedChallenges: 0 }
      ])
    })
  })
})


/* ===== FILE: ./frontend/src/app/score-board/components/difficulty-overview-score-card/difficulty-overview-score-card.component.html ===== */

<score-card
  [description]="'TITLE_CHALLENGES_SOLVED' | translate"
  [total]="totalChallenges"
  [score]="solvedChallenges"
  [showAsPercentage]="false"
  [showProgressBar]="false"
>
  <div right-side class="difficulties-group">
    <div class="difficulty-container" *ngFor="let difficulty of difficultySummaries">
      <div class="star-container">
        <svg
          width="28"
          height="25"
          viewBox="0 0 28 25"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            [attr.fill]="'url(#solved-gradient-' + difficulty.difficulty + ')'"
            d="M12.6496 1.25874L9.57854 7.48541L2.70757 8.48713C1.4754 8.66584 0.981596 10.1849 1.87515 11.0549L6.84614 15.8989L5.67041 22.7417C5.45878 23.9786 6.76149 24.905 7.85257 24.3266L13.9993 21.0957L20.146 24.3266C21.2371 24.9003 22.5398 23.9786 22.3282 22.7417L21.1524 15.8989L26.1234 11.0549C27.017 10.1849 26.5232 8.66584 25.291 8.48713L18.42 7.48541L15.349 1.25874C14.7988 0.148847 13.2045 0.134738 12.6496 1.25874Z"
          />
          <defs>
            <linearGradient
              [attr.id]="'solved-gradient-' + difficulty.difficulty"
              x1="0" x2="0" y1="1" y2="0"
            >
            <stop stop-color="var(--theme-accent)" />
            <stop *ngIf="difficulty.availableChallenges === 0" offset="0%" stop-color="var(--theme-accent)" />
            <stop *ngIf="difficulty.availableChallenges !== 0" [attr.offset]="difficulty.solvedChallenges / difficulty.availableChallenges * 100 + '%'" stop-color="var(--theme-accent)" />
            <stop stop-color="var(--theme-accent)" />
            <!-- has to be duplicated here to stop the gradient directly instead of doing a "gradual" transition -->
            <stop stop-color="var(--theme-primary)" />
            </linearGradient>
          </defs>
        </svg>
        <span class="star-difficulty-label">{{ difficulty.difficulty }}</span>
      </div>
      <span>
        {{ difficulty.solvedChallenges }}/<span class="total-challenges">{{ difficulty.availableChallenges }}</span>
      </span>
    </div>
  </div>
</score-card>


/* ===== FILE: ./frontend/src/app/score-board/components/warning-card/warning-card.component.ts ===== */

import { Component } from '@angular/core'

@Component({
  selector: 'warning-card',
  templateUrl: './warning-card.component.html',
  styleUrls: ['./warning-card.component.scss'],
  standalone: true
})
export class WarningCardComponent {}


/* ===== FILE: ./frontend/src/app/score-board/components/warning-card/warning-card.component.html ===== */

<div
  class="warning-container"
>
  <div class="warning-text-icon-group">
    <ng-content select="[warning-icon]"></ng-content>
    <span class="warning-text">
      <ng-content select="[warning-text]"></ng-content>
    </span>
  </div>
  <div class="warning-action">
    <ng-content select="[warning-action]"></ng-content>
  </div>
</div>



/* ===== FILE: ./frontend/src/app/score-board/components/hacking-challenge-progress-score-card/hacking-challenge-progress-score-card.component.html ===== */

<score-card
  [description]="'TITLE_HACKING_CHALLENGES' | translate"
  [total]="allChallenges.length"
  [score]="solvedChallenges"
  [showAsPercentage]="true"
>
    <div right-side class="icon-group">
        <svg
          width="62"
          height="69"
          viewBox="0 0 62 69"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
        >
          <g clip-path="url(#clip0_2_621)">
            <path
              d="M51.875 72.6249H29.125M51.875 72.6249V40.7749C51.875 40.1715 51.6353 39.5929 51.2087 39.1662C50.782 38.7396 50.2034 38.4999 49.6 38.4999H31.4C30.7966 38.4999 30.218 38.7396 29.7913 39.1662C29.3647 39.5929 29.125 40.1715 29.125 40.7749V72.6249M51.875 72.6249H72.35C72.9534 72.6249 73.532 72.3852 73.9587 71.9586C74.3853 71.5319 74.625 70.9533 74.625 70.3499V61.6291C74.625 61.0257 74.3853 60.447 73.9587 60.0204C73.532 59.5937 72.9534 59.3541 72.35 59.3541H54.15C53.5466 59.3541 52.968 59.5937 52.5413 60.0204C52.1147 60.447 51.875 61.0257 51.875 61.6291V72.6249ZM29.125 72.6249V54.0457C29.125 53.4424 28.8853 52.8637 28.4587 52.4371C28.032 52.0104 27.4534 51.7707 26.85 51.7707H8.65C8.04663 51.7707 7.46798 52.0104 7.04133 52.4371C6.61469 52.8637 6.375 53.4424 6.375 54.0457V70.3499C6.375 70.9533 6.61469 71.5319 7.04133 71.9586C7.46798 72.3852 8.04663 72.6249 8.65 72.6249H29.125ZM35.9727 12.3867L39.4194 5.08015C39.5124 4.87128 39.664 4.69384 39.8558 4.56933C40.0476 4.44481 40.2713 4.37854 40.5 4.37854C40.7287 4.37854 40.9524 4.44481 41.1442 4.56933C41.336 4.69384 41.4876 4.87128 41.5806 5.08015L45.031 12.3867L52.7357 13.5659C53.7253 13.7176 54.1197 14.9916 53.403 15.7196L47.8293 21.4071L49.145 29.4378C49.3118 30.4691 48.2805 31.2578 47.3933 30.7687L40.5 26.977L33.6068 30.7687C32.7233 31.254 31.6882 30.4691 31.855 29.4378L33.1707 21.4071L27.597 15.7196C26.8765 14.9916 27.2747 13.7176 28.2605 13.5659L35.9727 12.3867Z"
              stroke="var(--theme-text)"
              stroke-opacity="0.12"
              stroke-width="5.6875"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
          </g>
          <defs>
            <clipPath id="clip0_2_621">
              <rect width="62" height="69" fill="var(--theme-text)" />
            </clipPath>
          </defs>
        </svg>
    </div>
</score-card>


/* ===== FILE: ./frontend/src/app/score-board/components/hacking-challenge-progress-score-card/hacking-challenge-progress-score-card.component.spec.ts ===== */

import { type ComponentFixture, TestBed } from '@angular/core/testing'

import { HackingChallengeProgressScoreCardComponent } from './hacking-challenge-progress-score-card.component'
import { TranslateModule } from '@ngx-translate/core'
import { ScoreCardComponent } from '../score-card/score-card.component'

describe('HackingChallengeProgressScoreCardComponent', () => {
  let component: HackingChallengeProgressScoreCardComponent
  let fixture: ComponentFixture<HackingChallengeProgressScoreCardComponent>

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [TranslateModule.forRoot(), ScoreCardComponent, HackingChallengeProgressScoreCardComponent]
    })
      .compileComponents()

    fixture = TestBed.createComponent(HackingChallengeProgressScoreCardComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })
})


/* ===== FILE: ./frontend/src/app/score-board/components/hacking-challenge-progress-score-card/hacking-challenge-progress-score-card.component.ts ===== */

import { Component, Input, type OnChanges, type OnInit, type SimpleChanges } from '@angular/core'
import { type EnrichedChallenge } from '../../types/EnrichedChallenge'
import { TranslateModule } from '@ngx-translate/core'
import { ScoreCardComponent } from '../score-card/score-card.component'

@Component({
  selector: 'hacking-challenge-progress-score-card',
  templateUrl: './hacking-challenge-progress-score-card.component.html',
  styleUrls: ['./hacking-challenge-progress-score-card.component.scss'],
  imports: [ScoreCardComponent, TranslateModule]
})
export class HackingChallengeProgressScoreCardComponent implements OnInit, OnChanges {
  @Input()
  public allChallenges: EnrichedChallenge[] = []

  public solvedChallenges: number

  ngOnInit (): void {
    this.updatedNumberOfSolvedChallenges()
  }

  ngOnChanges (changes: SimpleChanges): void {
    this.updatedNumberOfSolvedChallenges()
  }

  private updatedNumberOfSolvedChallenges (): void {
    this.solvedChallenges = this.allChallenges.filter((challenge) => challenge.solved).length
  }
}


/* ===== FILE: ./frontend/src/app/score-board/components/challenge-card/challenge-card.component.ts ===== */

import { Component, Input, type OnInit } from '@angular/core'
import { EnrichedChallenge } from '../../types/EnrichedChallenge'
import { Config } from 'src/app/Services/configuration.service'
import { ChallengeHintPipe } from '../../pipes/challenge-hint.pipe'
import { TranslateModule } from '@ngx-translate/core'
import { MatIconModule } from '@angular/material/icon'
import { MatTooltip } from '@angular/material/tooltip'
import { NgFor, NgIf, NgClass, AsyncPipe } from '@angular/common'
import { DifficultyStarsComponent } from '../difficulty-stars/difficulty-stars.component'

@Component({
  selector: 'challenge-card',
  templateUrl: './challenge-card.component.html',
  styleUrls: ['./challenge-card.component.scss'],
  imports: [DifficultyStarsComponent, NgFor, MatTooltip, NgIf, MatIconModule, NgClass, AsyncPipe, TranslateModule, ChallengeHintPipe]
})
export class ChallengeCardComponent implements OnInit {
  @Input()
  public challenge: EnrichedChallenge

  @Input()
  public openCodingChallengeDialog: (challengeKey: string) => void

  @Input()
  public repeatChallengeNotification: (challengeKey: string) => void

  @Input()
  public applicationConfiguration: Config

  public hasInstructions: (challengeName: string) => boolean = () => false
  public startHackingInstructorFor: (challengeName: string) => Promise<void> = async () => {}

  async ngOnInit () {
    const { hasInstructions, startHackingInstructorFor } = await import('../../../../hacking-instructor')
    this.hasInstructions = hasInstructions
    this.startHackingInstructorFor = startHackingInstructorFor
  }
}


/* ===== FILE: ./frontend/src/app/score-board/components/challenge-card/challenge-card.component.html ===== */

<span class="category-row">{{ challenge.category }}</span>

<div class="name-row">
  <div class="dot"></div>
  <span class="name">{{ challenge.name }}</span>
  <difficulty-stars
    [difficulty]="challenge.difficulty"
  ></difficulty-stars>
</div>
<div class="description-row" [innerHtml]="challenge.description"></div>
<div class="bottom-row">
  <div class="tags">
    <span *ngFor="let tag of challenge.tagList" class="tag" [matTooltip]="('TAG_' + tag?.toUpperCase().split(' ').join('_') + '_DESCRIPTION' | translate)">{{ tag }}</span>
  </div>
  <div class="badge-group">
    <!-- info text if the challenge is unavailable -->
    <button
      class="badge"
      *ngIf="challenge.disabledEnv !== null && challenge.disabledEnv !== 'safetyMode'"
      [matTooltip]="'CHALLENGE_UNAVAILABLE' | translate:{ env: challenge.disabledEnv }"
    >
      <mat-icon [style.color]="'var(--theme-warn)'">info_outline</mat-icon>
    </button>
    <button
      class="badge"
      *ngIf="challenge.disabledEnv === 'safetyMode'"
      [matTooltip]="'CHALLENGE_UNAVAILABLE_SAFETYMODE'| translate:{ env: challenge.disabledEnv}"
    >
      <mat-icon [style.color]="'var(--theme-warn)'">info_outline</mat-icon>
    </button>
    <!-- coding challenge badge -->
    <button
      class="badge"
      *ngIf="applicationConfiguration.challenges.codingChallengesEnabled !== 'never' && challenge.hasCodingChallenge"
      (click)="openCodingChallengeDialog(challenge.key)"
      [disabled]="challenge.solved === false && applicationConfiguration.challenges.codingChallengesEnabled !== 'always'"
      [ngClass]="{
        'partially-completed': challenge.codingChallengeStatus === 1,
        'completed': challenge.codingChallengeStatus === 2
      }"
      [matTooltip]="(challenge.solved ? 'LAUNCH_CODING_CHALLENGE' : 'SOLVE_HACKING_CHALLENGE') | translate"
    >
      <span class="badge-status" *ngIf="challenge.codingChallengeStatus !== 0">{{ challenge.codingChallengeStatus }}/2</span>
      <mat-icon>code</mat-icon>
    </button>
    <!-- cheat cheat link-->
    <a
      class="badge not-completable"
      *ngIf="challenge.mitigationUrl && challenge.solved"
      [href]="challenge.mitigationUrl"
      target="_blank"
      rel="noopener noreferrer"
      [matTooltip]="'INFO_VULNERABILITY_MITIGATION_LINK' | translate"
      aria-label="Vulnerability mitigation link"
    >
      <mat-icon>policy_outline</mat-icon>
    </a>
    <!-- ctf mode flag repeat-->
    <button
      class="badge"
      [ngClass]="{ 'completed': challenge.solved }"
      *ngIf="challenge.solved && applicationConfiguration.ctf.showFlagsInNotifications"
      (click)="repeatChallengeNotification(challenge.key)"
      [matTooltip]="'NOTIFICATION_RESEND_INSTRUCTIONS' | translate"
    >
      <mat-icon>flag_outline</mat-icon>
    </button>
    <!-- hacking instructor-->
    <button
      class="badge not-completable"
      *ngIf="applicationConfiguration.hackingInstructor.isEnabled && hasInstructions(challenge.name)"
      [matTooltip]="'INFO_HACKING_INSTRUCTOR' | translate"
      (click)="startHackingInstructorFor(challenge.name)"
    >
      <mat-icon>school_outline</mat-icon>
    </button>
    <!-- challenge hint -->
    <!-- with hintUrl -->
    <a
      *ngIf="challenge.hint && challenge.hintUrl"
      class="badge not-completable"
      [style.padding]="'0 6px 0 4px'"
      target="_blank"
      rel="noopener noreferrer"
      [href]="challenge.hintUrl"
      [matTooltip]="challenge.hint | challengeHint:{hintUrl: challenge.hintUrl} | async"
    >
      <mat-icon>lightbulb</mat-icon>
      Hint
    </a>
    <!-- challenge hint -->
    <!-- without hintUrl -->
    <span
      *ngIf="challenge.hint && !challenge.hintUrl"
      class="badge not-completable"
      [style.padding]="'0 6px 0 4px'"
      [matTooltip]="challenge.hint"
    >
      <mat-icon>lightbulb</mat-icon>
      Hint
    </span>
  </div>
</div>


/* ===== FILE: ./frontend/src/app/score-board/components/challenge-card/challenge-card.component.spec.ts ===== */

import { type ComponentFixture, TestBed } from '@angular/core/testing'

import { ChallengeCardComponent } from './challenge-card.component'
import { type Config } from 'src/app/Services/configuration.service'
import { TranslateModule } from '@ngx-translate/core'
import { MatIconModule } from '@angular/material/icon'
import { MatTooltipModule } from '@angular/material/tooltip'

describe('ChallengeCard', () => {
  let component: ChallengeCardComponent
  let fixture: ComponentFixture<ChallengeCardComponent>

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [TranslateModule.forRoot(), MatIconModule, MatTooltipModule, ChallengeCardComponent]
    })
      .compileComponents()

    fixture = TestBed.createComponent(ChallengeCardComponent)
    component = fixture.componentInstance

    component.challenge = {
      category: 'foobar',
      name: 'my name',
      mitigationUrl: 'https://owasp.example.com',
      hasCodingChallenge: true,
      description: 'lorem ipsum',
      tagList: ['Easy']
    } as any

    component.applicationConfiguration = {
      ctf: {
        showFlagsInNotifications: true
      },
      challenges: {
        codingChallengesEnabled: 'solved'
      },
      hackingInstructor: {
        isEnabled: true
      }
    } as Config

    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should not show a mitigation link when challenge has it but isnt solved', () => {
    component.challenge.solved = false
    component.challenge.mitigationUrl = 'https://owasp.example.com'
    fixture.detectChanges()
    expect(fixture.nativeElement.querySelector('[aria-label="Vulnerability mitigation link"]'))
      .toBeFalsy()
  })

  it('should show a mitigation link when challenge has it but isnt solved', () => {
    component.challenge.solved = true
    component.challenge.mitigationUrl = 'https://owasp.example.com'
    fixture.detectChanges()
    expect(fixture.nativeElement.querySelector('[aria-label="Vulnerability mitigation link"]'))
      .toBeTruthy()
  })
})


/* ===== FILE: ./frontend/src/app/score-board/components/difficulty-stars/difficulty-stars.component.ts ===== */

import { Component, Input } from '@angular/core'
import { NgFor } from '@angular/common'

@Component({
  selector: 'difficulty-stars',
  templateUrl: './difficulty-stars.component.html',
  styleUrls: ['./difficulty-stars.component.scss'],
  imports: [NgFor]
})
export class DifficultyStarsComponent {
  @Input()
    difficulty: 1 | 2 | 3 | 4 | 5 | 6
}


/* ===== FILE: ./frontend/src/app/score-board/components/difficulty-stars/difficulty-stars.component.html ===== */

<ng-container *ngFor="let _ of [].constructor(difficulty)">
  <svg
    width="18"
    height="18"
    viewBox="0 0 14 13"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <path
      d="M6.56386 0.511963L8.10332 5.24992H13.0851L9.05475 8.17813L10.5942 12.9161L6.56386 9.98787L2.53352 12.9161L4.07297 8.17813L0.0426283 5.24992H5.02441L6.56386 0.511963Z"
      fill="var(--theme-text)"
    />
  </svg>
</ng-container>


/* ===== FILE: ./frontend/src/app/score-board/components/tutorial-mode-warning/tutorial-mode-warning.component.html ===== */

<warning-card *ngIf="tutorialModeActive">
  <mat-icon warning-icon>school</mat-icon>
  <span warning-text class="tutorial-mode-warning-text">
    {{ 'INFO_FULL_CHALLENGE_MODE' | translate: {num: allChallenges.length} }}
  </span>
</warning-card>


/* ===== FILE: ./frontend/src/app/score-board/components/tutorial-mode-warning/tutorial-mode-warning.component.ts ===== */

import { Component, Input, type OnChanges } from '@angular/core'

import { type EnrichedChallenge } from '../../types/EnrichedChallenge'
import { type Config } from 'src/app/Services/configuration.service'
import { TranslateModule } from '@ngx-translate/core'
import { MatIconModule } from '@angular/material/icon'
import { WarningCardComponent } from '../warning-card/warning-card.component'
import { NgIf } from '@angular/common'

@Component({
  selector: 'tutorial-mode-warning',
  templateUrl: './tutorial-mode-warning.component.html',
  imports: [NgIf, WarningCardComponent, MatIconModule, TranslateModule]
})
export class TutorialModeWarningComponent implements OnChanges {
  @Input()
  public allChallenges: EnrichedChallenge[]

  @Input()
  public applicationConfig: Config | null = null

  public tutorialModeActive: boolean | null = null

  ngOnChanges (): void {
    if (!this.applicationConfig?.challenges?.restrictToTutorialsFirst) {
      this.tutorialModeActive = false
      return
    }

    const allTutorialChallengesSolved = this.allChallenges
      .filter(challenge => challenge.tutorialOrder !== null)
      .every(challenge => challenge.solved)
    this.tutorialModeActive = !allTutorialChallengesSolved
  }
}


/* ===== FILE: ./frontend/src/app/score-board/components/tutorial-mode-warning/tutorial-mode-warning.component.spec.ts ===== */

import { type ComponentFixture, TestBed } from '@angular/core/testing'

import { TutorialModeWarningComponent } from './tutorial-mode-warning.component'
import { TranslateModule } from '@ngx-translate/core'

describe('TutorialModeWarningComponent', () => {
  let component: TutorialModeWarningComponent
  let fixture: ComponentFixture<TutorialModeWarningComponent>

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [TranslateModule.forRoot(), TutorialModeWarningComponent]
    }).compileComponents()

    fixture = TestBed.createComponent(TutorialModeWarningComponent)
    component = fixture.componentInstance

    component.allChallenges = [
      {
        category: 'foobar',
        name: 'my name',
        tutorialOrder: 1,
        solved: false
      },
      {
        category: 'foobar',
        name: 'my name two',
        description: 'lorem ipsum',
        tutorialOrder: null,
        solved: false
      }
    ] as any

    component.applicationConfig = {
      challenges: {
        restrictToTutorialsFirst: true
      }
    } as any

    fixture.detectChanges()
  })

  it('should show warning when there are configured and unsolved tutorial challenges exist', () => {
    component.ngOnChanges()
    expect(component.tutorialModeActive).toBe(true)
  })

  it('not show if tutorial is not configured', () => {
    component.applicationConfig = {
      challenges: {
        restrictToTutorialsFirst: false
      }
    } as any
    component.ngOnChanges()
    expect(component.tutorialModeActive).toBe(false)
  })

  it('should not show warning when all tutorial mode challenges are solved', () => {
    component.allChallenges = [
      {
        category: 'foobar',
        name: 'my name',
        tutorialOrder: 1,
        solved: true
      },
      {
        category: 'foobar',
        name: 'my name two',
        description: 'lorem ipsum',
        tutorialOrder: null,
        solved: false
      }
    ] as any
    component.ngOnChanges()
    expect(component.tutorialModeActive).toBe(false)
  })
})


/* ===== FILE: ./frontend/src/app/score-board/components/challenges-unavailable-warning/challenges-unavailable-warning.component.ts ===== */

import { Component, EventEmitter, Input, type OnChanges, Output } from '@angular/core'

import { FilterSetting } from '../../filter-settings/FilterSetting'
import { type EnrichedChallenge } from '../../types/EnrichedChallenge'
import { TranslateModule } from '@ngx-translate/core'
import { MatButtonModule } from '@angular/material/button'
import { WarningCardComponent } from '../warning-card/warning-card.component'
import { NgIf, NgClass } from '@angular/common'

@Component({
  selector: 'challenges-unavailable-warning',
  templateUrl: './challenges-unavailable-warning.component.html',
  styleUrls: ['./challenges-unavailable-warning.component.scss'],
  imports: [NgIf, WarningCardComponent, NgClass, MatButtonModule, TranslateModule]
})
export class ChallengesUnavailableWarningComponent implements OnChanges {
  @Input()
  public challenges: EnrichedChallenge[]

  @Input()
  public filterSetting: FilterSetting

  @Output()
  public filterSettingChange = new EventEmitter<FilterSetting>()

  public numberOfDisabledChallenges = 0
  public disabledBecauseOfEnv: string | null = null
  public disabledOnWindows: boolean
  public numberOfDisabledChallengesOnWindows = 0

  public ngOnChanges () {
    const disabledChallenges = this.challenges.filter(challenge => challenge.disabledEnv !== null)
    const disabledOnWindows = disabledChallenges.filter(challenge => challenge.disabledEnv === 'Windows')
    this.numberOfDisabledChallenges = disabledChallenges.length
    if (this.numberOfDisabledChallenges > 0) {
      this.disabledBecauseOfEnv = disabledChallenges[0].disabledEnv
    }
    if (disabledOnWindows.length > 0) {
      this.disabledOnWindows = true
      this.numberOfDisabledChallengesOnWindows = disabledOnWindows.length
    }
  }

  public toggleShowDisabledChallenges () {
    const filterSetting = {
      ...structuredClone(this.filterSetting),
      showDisabledChallenges: !this.filterSetting.showDisabledChallenges
    }
    this.filterSetting = filterSetting
    this.filterSettingChange.emit(filterSetting)
  }
}


/* ===== FILE: ./frontend/src/app/score-board/components/challenges-unavailable-warning/challenges-unavailable-warning.component.spec.ts ===== */

import { type ComponentFixture, TestBed } from '@angular/core/testing'

import { ChallengesUnavailableWarningComponent } from './challenges-unavailable-warning.component'
import { TranslateModule } from '@ngx-translate/core'
import { DEFAULT_FILTER_SETTING } from '../../filter-settings/FilterSetting'

describe('ChallengesUnavailableWarningComponent', () => {
  let component: ChallengesUnavailableWarningComponent
  let fixture: ComponentFixture<ChallengesUnavailableWarningComponent>

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [TranslateModule.forRoot(), ChallengesUnavailableWarningComponent]
    })
      .compileComponents()

    fixture = TestBed.createComponent(ChallengesUnavailableWarningComponent)
    component = fixture.componentInstance

    component.challenges = [
      {
        category: 'foobar',
        name: 'my name',
        mitigationUrl: 'https://owasp.example.com',
        hasCodingChallenge: true,
        description: 'lorem ipsum',
        tagList: ['Easy'],
        disabledEnv: 'Docker'
      },
      {
        category: 'foobar',
        name: 'my name two',
        mitigationUrl: 'https://owasp.example.com',
        hasCodingChallenge: true,
        description: 'lorem ipsum',
        tagList: ['Easy'],
        disabledEnv: null
      }
    ] as any

    component.filterSetting = structuredClone(DEFAULT_FILTER_SETTING)

    fixture.detectChanges()
  })

  it('should properly calculate number of disabled challenges when there is one out of two', () => {
    component.ngOnChanges()

    expect(component.numberOfDisabledChallenges).toBe(1)
    expect(component.disabledBecauseOfEnv).toBe('Docker')
  })

  it('should properly calculate number of disabled challenges when there are none', () => {
    component.challenges = [
      {
        category: 'foobar',
        name: 'my name',
        mitigationUrl: 'https://owasp.example.com',
        hasCodingChallenge: true,
        description: 'lorem ipsum',
        tagList: ['Easy'],
        disabledEnv: null
      }
    ] as any

    component.ngOnChanges()

    expect(component.numberOfDisabledChallenges).toBe(0)
    expect(component.disabledBecauseOfEnv).toBeNull()
  })

  it('should properly calculate number of disabled challenges when there are multiple of different type', () => {
    component.challenges = [
      {
        category: 'foobar',
        name: 'my name',
        mitigationUrl: 'https://owasp.example.com',
        hasCodingChallenge: true,
        description: 'lorem ipsum',
        tagList: ['Easy'],
        disabledEnv: 'Docker'
      },
      {
        category: 'foobar',
        name: 'my name two',
        mitigationUrl: 'https://owasp.example.com',
        hasCodingChallenge: true,
        description: 'lorem ipsum',
        tagList: ['Easy'],
        disabledEnv: 'Windows'
      }
    ] as any

    component.ngOnChanges()

    expect(component.numberOfDisabledChallenges).toBe(2)
    expect(component.disabledBecauseOfEnv).toBe('Docker')
    expect(component.disabledOnWindows).toBeTrue()
    expect(component.numberOfDisabledChallengesOnWindows).toBe(1)
  })

  it('should toggle via filter if disabled challenges are shown', () => {
    expect(component.filterSetting.showDisabledChallenges).toBeTrue()

    component.toggleShowDisabledChallenges()

    expect(component.filterSetting.showDisabledChallenges).toBeFalse()
  })
})


/* ===== FILE: ./frontend/src/app/score-board/components/challenges-unavailable-warning/challenges-unavailable-warning.component.html ===== */

<warning-card *ngIf="numberOfDisabledChallenges > 0">
  <ng-container warning-icon>
    <i class="env-icon" *ngIf="disabledBecauseOfEnv !== 'Windows'" [ngClass]="'icon-' + disabledBecauseOfEnv.toString().toLowerCase()"></i>
    <i class="env-icon" *ngIf="disabledBecauseOfEnv === 'Windows'" [ngClass]="'fab fa-' + disabledBecauseOfEnv.toString().toLowerCase()"></i>
  </ng-container>
  
  <span *ngIf="disabledBecauseOfEnv !=='Safety Mode'" warning-text [innerHTML]="'INFO_DISABLED_CHALLENGES' | translate: {num: numberOfDisabledChallenges, env: disabledBecauseOfEnv}"></span>
  <span *ngIf="disabledBecauseOfEnv ==='Safety Mode'" warning-text [innerHTML]="'INFO_DISABLED_CHALLENGES' | translate: {num: numberOfDisabledChallenges,env:'safety mode being turned on'}"></span>
  
  <button warning-action mat-button color="accent" (click)="toggleShowDisabledChallenges()">
    <ng-container *ngIf="filterSetting.showDisabledChallenges == false">
      {{ 'SHOW_DISABLED_CHALLENGES' | translate }}
    </ng-container>
    <ng-container *ngIf="filterSetting.showDisabledChallenges == true">
      {{ 'HIDE_DISABLED_CHALLENGES' | translate }}
    </ng-container>
  </button>
</warning-card>


/* ===== FILE: ./frontend/src/app/score-board/components/coding-challenge-progress-score-card/coding-challenge-progress-score-card.component.spec.ts ===== */

import { type ComponentFixture, TestBed } from '@angular/core/testing'

import { ScoreCardComponent } from '../score-card/score-card.component'
import { CodingChallengeProgressScoreCardComponent } from './coding-challenge-progress-score-card.component'
import { TranslateModule } from '@ngx-translate/core'

describe('CodingChallengeProgressScoreCardComponent', () => {
  let component: CodingChallengeProgressScoreCardComponent
  let fixture: ComponentFixture<CodingChallengeProgressScoreCardComponent>

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [TranslateModule.forRoot(), ScoreCardComponent,
        CodingChallengeProgressScoreCardComponent]
    })
      .compileComponents()

    fixture = TestBed.createComponent(CodingChallengeProgressScoreCardComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })
})


/* ===== FILE: ./frontend/src/app/score-board/components/coding-challenge-progress-score-card/coding-challenge-progress-score-card.component.html ===== */

<score-card
  [description]="'TITLE_CODING_CHALLENGES' | translate"
  [total]="availableCodingChallenges"
  [score]="solvedCodingChallenges"
  [showAsPercentage]="true"
>
  <div right-side class="icon-group">
    <svg
      width="74"
      height="85"
      viewBox="0 0 74 85"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
    >
      <g clip-path="url(#clip0_2_635)">
        <path
          d="M69.2371 41.1778C68.9506 40.8702 68.6049 40.6235 68.2209 40.4524C67.8369 40.2813 67.4224 40.1893 67.0021 40.1819C66.5817 40.1745 66.1642 40.2518 65.7744 40.4092C65.3846 40.5667 65.0305 40.801 64.7332 41.0983C64.436 41.3956 64.2016 41.7497 64.0442 42.1395C63.8867 42.5293 63.8094 42.9468 63.8168 43.3671C63.8242 43.7875 63.9162 44.202 64.0873 44.586C64.2584 44.97 64.5051 45.3156 64.8127 45.6022L65.5265 46.3201C68.3731 49.1668 70.2806 51.0785 71.512 52.698C72.6932 54.2424 72.9603 55.1439 72.9603 55.912C72.9603 56.68 72.6932 57.5816 71.512 59.1259C70.2806 60.7413 68.3731 62.6571 65.5265 65.5038L64.8127 66.2217C64.5051 66.5083 64.2584 66.8539 64.0873 67.2379C63.9162 67.6219 63.8242 68.0365 63.8168 68.4568C63.8094 68.8771 63.8867 69.2947 64.0442 69.6845C64.2016 70.0743 64.436 70.4284 64.7332 70.7256C65.0305 71.0229 65.3846 71.2572 65.7744 71.4147C66.1642 71.5721 66.5817 71.6495 67.0021 71.642C67.4224 71.6346 67.8369 71.5426 68.2209 71.3715C68.6049 71.2004 68.9506 70.9537 69.2371 70.6462L70.1095 69.778C72.76 67.1275 74.9722 64.9153 76.4915 62.9243C78.0944 60.8206 79.2213 58.6 79.2213 55.912C79.2213 53.2239 78.0944 51.0033 76.4915 48.8997C74.9722 46.9087 72.76 44.6964 70.1053 42.046L69.2371 41.1778ZM58.6269 32.7296C59.428 32.9448 60.1111 33.4692 60.5259 34.1877C60.9406 34.9062 61.0533 35.7599 60.8391 36.5613L50.0368 76.8821C49.9302 77.2792 49.7464 77.6515 49.4959 77.9776C49.2454 78.3037 48.9332 78.5772 48.577 78.7827C47.8576 79.1975 47.0029 79.3096 46.2009 79.0943C45.3988 78.879 44.7152 78.3539 44.3003 77.6345C43.8855 76.9152 43.7733 76.0605 43.9887 75.2584L54.791 34.9418C54.8975 34.5442 55.0814 34.1715 55.3321 33.845C55.5828 33.5186 55.8955 33.2447 56.2522 33.0393C56.6089 32.8338 57.0026 32.7007 57.4108 32.6475C57.819 32.5944 58.2336 32.6223 58.631 32.7296H58.6269ZM40.0192 41.1778C39.4322 40.5915 38.6366 40.2622 37.807 40.2622C36.9774 40.2622 36.1817 40.5915 35.5948 41.1778L34.7266 42.046C32.0719 44.6964 29.8597 46.9087 28.3404 48.8997C26.7375 51.0033 25.6147 53.2239 25.6147 55.912C25.6147 58.6 26.7417 60.8206 28.3404 62.9243C29.8597 64.9153 32.0719 67.1275 34.7266 69.778L35.5948 70.6462C36.1882 71.1991 36.9731 71.5002 37.7841 71.4859C38.5951 71.4716 39.3689 71.143 39.9425 70.5694C40.516 69.9959 40.8446 69.2221 40.8589 68.4111C40.8732 67.6001 40.5722 66.8152 40.0192 66.2217L39.3054 65.5038C36.4588 62.6571 34.5554 60.7454 33.3199 59.1259C32.1387 57.5816 31.8757 56.68 31.8757 55.912C31.8757 55.1439 32.1387 54.2424 33.3199 52.698C34.5554 51.0827 36.4588 49.1668 39.3054 46.3201L40.0234 45.6022C40.6096 45.0152 40.9389 44.2196 40.9389 43.39C40.9389 42.5604 40.6096 41.7647 40.0234 41.1778H40.0192Z"
          fill="var(--theme-text)"
          fill-opacity="0.12"
        />
        <path
          fill-rule="evenodd"
          clip-rule="evenodd"
          d="M52.4188 11.0416C27.6378 11.0416 7.54834 31.1311 7.54834 55.912C7.54834 80.693 27.6378 100.782 52.4188 100.782C77.1998 100.782 97.2892 80.693 97.2892 55.912C97.2892 31.1311 77.1998 11.0416 52.4188 11.0416ZM13.8093 55.912C13.8093 45.6722 17.8771 35.8517 25.1178 28.6111C32.3584 21.3704 42.1789 17.3026 52.4188 17.3026C62.6586 17.3026 72.4791 21.3704 79.7197 28.6111C86.9604 35.8517 91.0282 45.6722 91.0282 55.912C91.0282 66.1519 86.9604 75.9724 79.7197 83.213C72.4791 90.4537 62.6586 94.5215 52.4188 94.5215C42.1789 94.5215 32.3584 90.4537 25.1178 83.213C17.8771 75.9724 13.8093 66.1519 13.8093 55.912Z"
          fill="var(--theme-text)"
          fill-opacity="0.12"
        />
      </g>
      <defs>
        <clipPath id="clip0_2_635">
          <rect width="106" height="106" fill="var(--theme-text)" />
        </clipPath>
      </defs>
    </svg>
  </div>
</score-card>


/* ===== FILE: ./frontend/src/app/score-board/components/coding-challenge-progress-score-card/coding-challenge-progress-score-card.component.ts ===== */

import { Component, Input, type OnChanges, type OnInit, type SimpleChanges } from '@angular/core'

import { type EnrichedChallenge } from '../../types/EnrichedChallenge'
import { TranslateModule } from '@ngx-translate/core'
import { ScoreCardComponent } from '../score-card/score-card.component'

@Component({
  selector: 'coding-challenge-progress-score-card',
  templateUrl: './coding-challenge-progress-score-card.component.html',
  styleUrls: ['./coding-challenge-progress-score-card.component.scss'],
  imports: [ScoreCardComponent, TranslateModule]
})
export class CodingChallengeProgressScoreCardComponent implements OnInit, OnChanges {
  @Input()
  public allChallenges: EnrichedChallenge[] = []

  public availableCodingChallenges: number
  public solvedCodingChallenges: number

  ngOnInit (): void {
    this.updatedNumberOfSolvedChallenges()
  }

  ngOnChanges (changes: SimpleChanges): void {
    this.updatedNumberOfSolvedChallenges()
  }

  private updatedNumberOfSolvedChallenges (): void {
    const availableCodingChallenges = this.allChallenges
      .filter((challenge) => challenge.hasCodingChallenge)

    this.solvedCodingChallenges = availableCodingChallenges
      .map((challenge) => challenge.codingChallengeStatus)
      .reduce((a, b) => a + b, 0) // sum up the scores
    // multiply by 2 because each coding challenge has 2 parts (find it and fix it)
    this.availableCodingChallenges = availableCodingChallenges.length * 2
  }
}


/* ===== FILE: ./frontend/src/app/score-board/components/score-card/score-card.component.spec.ts ===== */

import { type ComponentFixture, TestBed } from '@angular/core/testing'

import { ScoreCardComponent } from './score-card.component'

describe('ScoreCardComponent', () => {
  let component: ScoreCardComponent
  let fixture: ComponentFixture<ScoreCardComponent>

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [ScoreCardComponent]
    })
      .compileComponents()

    fixture = TestBed.createComponent(ScoreCardComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })
})


/* ===== FILE: ./frontend/src/app/score-board/components/score-card/score-card.component.ts ===== */

import { Component, Input } from '@angular/core'
import { NgIf, DecimalPipe } from '@angular/common'

@Component({
  selector: 'score-card',
  templateUrl: './score-card.component.html',
  styleUrls: ['./score-card.component.scss'],
  imports: [NgIf, DecimalPipe]
})
export class ScoreCardComponent {
  @Input()
  public description: string

  @Input()
  public total: number

  @Input()
  public score: number

  @Input()
  public showAsPercentage: boolean = true

  @Input()
  public showProgressBar: boolean = true
}


/* ===== FILE: ./frontend/src/app/score-board/components/score-card/score-card.component.html ===== */

<div class="score-group">
  <p class="score">
    <ng-container *ngIf="showAsPercentage == true">
      {{ (score / total) * 100 | number : "1.0-0" }}%
    </ng-container>
    <ng-container *ngIf="showAsPercentage == false">
      {{ score }}/<span class="fraction-total">{{ total }}</span>
    </ng-container>
  </p>
  <p class="category">{{ description }}</p>
  <div *ngIf="showProgressBar === true" class="progress-bar-container">
    <div class="progress-bar" [style.width]="(score / total) * 100 + '%'"></div>
  </div>
</div>
<div class="right-group">
  <ng-content select="[right-side]" />
</div>


/* ===== FILE: ./frontend/src/app/score-board/score-board.component.html ===== */

<div class="score-row">
  <hacking-challenge-progress-score-card [allChallenges]="allChallenges" />
  <coding-challenge-progress-score-card [allChallenges]="allChallenges" />
  <difficulty-overview-score-card [allChallenges]="allChallenges" />
</div>

<filter-settings
  *ngIf="applicationConfiguration?.challenges.restrictToTutorialsFirst === false"
  [filterSetting]="filterSetting"
  (filterSettingChange)="onFilterSettingUpdate($event)"
  [allChallenges]="allChallenges"
  [reset]="reset.bind(this)"
></filter-settings>

<div *ngIf="isInitialized === false" class="loading-spinner-wrapper">
  <mat-spinner></mat-spinner>
</div>

<ng-container *ngIf="isInitialized === true">
  <challenges-unavailable-warning
    [challenges]="allChallenges"
    [filterSetting]="filterSetting"
    (filterSettingChange)="onFilterSettingUpdate($event)"
  ></challenges-unavailable-warning>

  <tutorial-mode-warning
    [allChallenges]="allChallenges"
    [applicationConfig]="applicationConfiguration"
  ></tutorial-mode-warning>

  <div class="challenges" *ngIf="filteredChallenges.length > 0; else emptyChallenges">
    <challenge-card
      *ngFor="let challenge of filteredChallenges; trackBy:getChallengeKey"
      [challenge]="challenge"
      [applicationConfiguration]="applicationConfiguration"
      [openCodingChallengeDialog]="openCodingChallengeDialog.bind(this)"
      [repeatChallengeNotification]="repeatChallengeNotification.bind(this)"
      [ngClass]="{ solved: challenge.solved, unsolved: !challenge.solved, disabled: challenge.disabledEnv !== null }"
    />
  </div>

  <ng-template #emptyChallenges>
    <!-- only showing when there are more than 1 challenge in total. not completely loaded otherwise -->
    <div class="empty-challenges" *ngIf="allChallenges.length > 0">
      <p>{{ 'NO_CHALLENGES_FOUND' | translate }}</p>
    </div>
  </ng-template>

  <img src="assets/public/images/padding/1px.png"/>

</ng-container>



/* ===== FILE: ./frontend/src/app/score-board/helpers/challenge-filtering.spec.ts ===== */

import { type EnrichedChallenge } from '../types/EnrichedChallenge'
import { DEFAULT_FILTER_SETTING } from '../filter-settings/FilterSetting'
import { filterChallenges } from './challenge-filtering'

const CHALLENGE_1 = {
  category: 'foobar',
  description: 'lorem ipsum',
  originalDescription: 'lorem ipsum',
  difficulty: 1,
  hasCodingChallenge: true,
  id: 1,
  key: 'challenge-1',
  mitigationUrl: 'https://owasp.example.com',
  name: 'challenge one',
  solved: false,
  codingChallengeStatus: 0,
  tagList: ['easy'],
  disabledEnv: null,
  tutorialOrder: 1
} as EnrichedChallenge

const CHALLENGE_2 = {
  category: 'foobar',
  description: 'lorem ipsum',
  originalDescription: 'lorem ipsum',
  difficulty: 3,
  hasCodingChallenge: true,
  id: 2,
  key: 'challenge-2',
  mitigationUrl: 'https://owasp.example.com',
  name: 'challenge two',
  solved: true,
  codingChallengeStatus: 2,
  tagList: ['easy'],
  disabledEnv: null,
  tutorialOrder: 2
} as EnrichedChallenge

const CHALLENGE_3 = {
  category: 'barfoo',
  description: 'lorem ipsum',
  originalDescription: 'lorem ipsum',
  difficulty: 6,
  hasCodingChallenge: true,
  id: 3,
  key: 'challenge-3',
  mitigationUrl: 'https://owasp.example.com',
  name: 'challenge three',
  solved: true,
  codingChallengeStatus: 1,
  tagList: ['hard'],
  disabledEnv: 'docker',
  tutorialOrder: null
} as EnrichedChallenge

describe('filterChallenges', () => {
  it('should filter empty list', () => {
    expect(filterChallenges([], { ...DEFAULT_FILTER_SETTING })).toEqual([])
    expect(filterChallenges([], { categories: ['foo', 'bar'], difficulties: [1, 2, 3, 5, 6], tags: ['hard'], status: 'solved', searchQuery: 'foobar', showDisabledChallenges: true, restrictToTutorialChallengesFirst: true })).toEqual([])
  })

  it('should filter challenges based on categories properly', () => {
    expect(filterChallenges(
      [CHALLENGE_1, CHALLENGE_2, CHALLENGE_3],
      { ...DEFAULT_FILTER_SETTING, categories: ['foobar'] }
    ).map((challenge) => challenge.key)).toEqual(jasmine.arrayWithExactContents(['challenge-1', 'challenge-2']))
    expect(filterChallenges(
      [CHALLENGE_1, CHALLENGE_2, CHALLENGE_3],
      { ...DEFAULT_FILTER_SETTING, categories: ['barfoo'] }
    ).map((challenge) => challenge.key)).toEqual(jasmine.arrayWithExactContents(['challenge-3']))
  })

  it('should filter challenges based on difficulties properly', () => {
    expect(filterChallenges(
      [CHALLENGE_1, CHALLENGE_2, CHALLENGE_3],
      { ...DEFAULT_FILTER_SETTING, difficulties: [1, 6] }
    ).map((challenge) => challenge.key)).toEqual(jasmine.arrayWithExactContents(['challenge-1', 'challenge-3']))
    expect(filterChallenges(
      [CHALLENGE_1, CHALLENGE_2, CHALLENGE_3],
      { ...DEFAULT_FILTER_SETTING, difficulties: [3] }
    ).map((challenge) => challenge.key)).toEqual(jasmine.arrayWithExactContents(['challenge-2']))
  })

  it('should filter challenges based on tags properly', () => {
    expect(filterChallenges(
      [CHALLENGE_1, CHALLENGE_2, CHALLENGE_3],
      { ...DEFAULT_FILTER_SETTING, tags: ['easy'] }
    ).map((challenge) => challenge.key)).toEqual(jasmine.arrayWithExactContents(['challenge-1', 'challenge-2']))
    expect(filterChallenges(
      [CHALLENGE_1, CHALLENGE_2, CHALLENGE_3],
      { ...DEFAULT_FILTER_SETTING, tags: ['hard'] }
    ).map((challenge) => challenge.key)).toEqual(jasmine.arrayWithExactContents(['challenge-3']))
  })

  it('should filter challenges based on status properly', () => {
    expect(filterChallenges(
      [CHALLENGE_1, CHALLENGE_2, CHALLENGE_3],
      { ...DEFAULT_FILTER_SETTING, status: 'solved' }
    ).map((challenge) => challenge.key)).toEqual(jasmine.arrayWithExactContents(['challenge-2']))
    expect(filterChallenges(
      [CHALLENGE_1, CHALLENGE_2, CHALLENGE_3],
      { ...DEFAULT_FILTER_SETTING, status: 'unsolved' }
    ).map((challenge) => challenge.key)).toEqual(jasmine.arrayWithExactContents(['challenge-1']))
    expect(filterChallenges(
      [CHALLENGE_1, CHALLENGE_2, CHALLENGE_3],
      { ...DEFAULT_FILTER_SETTING, status: 'partially-solved' }
    ).map((challenge) => challenge.key)).toEqual(jasmine.arrayWithExactContents(['challenge-3']))
  })

  it('should filter challenges based on searchQuery properly', () => {
    expect(filterChallenges(
      [CHALLENGE_1, CHALLENGE_2, CHALLENGE_3],
      { ...DEFAULT_FILTER_SETTING, searchQuery: 'lorem' }
    ).map((challenge) => challenge.key)).toEqual(jasmine.arrayWithExactContents(['challenge-1', 'challenge-2', 'challenge-3']))
    expect(filterChallenges(
      [CHALLENGE_1, CHALLENGE_2, CHALLENGE_3],
      { ...DEFAULT_FILTER_SETTING, searchQuery: 'challenge three' }
    ).map((challenge) => challenge.key)).toEqual(jasmine.arrayWithExactContents(['challenge-3']))
  })

  it('should filter challenges based on disabled setting properly', () => {
    expect(filterChallenges(
      [CHALLENGE_1, CHALLENGE_2, CHALLENGE_3],
      { ...DEFAULT_FILTER_SETTING, showDisabledChallenges: true }
    ).map((challenge) => challenge.key)).toEqual(jasmine.arrayWithExactContents(['challenge-1', 'challenge-2', 'challenge-3']))
    expect(filterChallenges(
      [CHALLENGE_1, CHALLENGE_2, CHALLENGE_3],
      { ...DEFAULT_FILTER_SETTING, showDisabledChallenges: false }
    ).map((challenge) => challenge.key)).toEqual(jasmine.arrayWithExactContents(['challenge-1', 'challenge-2']))
  })

  it('should only show unsolved tutorial of first difficulty if no challenges are solved', () => {
    expect(filterChallenges(
      [CHALLENGE_1, { ...CHALLENGE_2, solved: false }, CHALLENGE_3],
      { ...DEFAULT_FILTER_SETTING, restrictToTutorialChallengesFirst: true }
    ).map((challenge) => challenge.key)).toEqual(jasmine.arrayWithExactContents(['challenge-1']))
  })

  it('should only show tutorial challenges when restrictToTutorialChallengesFirst is set', () => {
    expect(filterChallenges(
      [CHALLENGE_1, { ...CHALLENGE_2, solved: false, difficulty: 1, tutorialOrder: null }, CHALLENGE_3],
      { ...DEFAULT_FILTER_SETTING, restrictToTutorialChallengesFirst: true }
    ).map((challenge) => challenge.key)).toEqual(jasmine.arrayWithExactContents(['challenge-1']))
  })

  it('should only show unsolved tutorial of first difficulty and solved ones of easier difficulties', () => {
    expect(filterChallenges(
      [{ ...CHALLENGE_1, solved: true }, { ...CHALLENGE_2, solved: false }, CHALLENGE_3],
      { ...DEFAULT_FILTER_SETTING, restrictToTutorialChallengesFirst: true }
    ).map((challenge) => challenge.key)).toEqual(jasmine.arrayWithExactContents(['challenge-1', 'challenge-2']))
  })

  it('should only show ignore tutorial mode when all tutorial challenges are solved', () => {
    expect(filterChallenges(
      [{ ...CHALLENGE_1, solved: true }, { ...CHALLENGE_2, solved: true }, CHALLENGE_3],
      { ...DEFAULT_FILTER_SETTING, restrictToTutorialChallengesFirst: true }
    ).map((challenge) => challenge.key)).toEqual(jasmine.arrayWithExactContents(['challenge-1', 'challenge-2', 'challenge-3']))
  })
})


/* ===== FILE: ./frontend/src/app/score-board/helpers/challenge-filtering.ts ===== */

import { type EnrichedChallenge } from '../types/EnrichedChallenge'
import { type FilterSetting, type SolvedStatus } from '../filter-settings/FilterSetting'

export function filterChallenges (
  challenges: EnrichedChallenge[],
  filterSetting: FilterSetting
): EnrichedChallenge[] {
  return (
    challenges
      // filter by category
      .filter((challenge) => {
        if (filterSetting.categories.length === 0) {
          return true
        }
        return filterSetting.categories.includes(challenge.category)
      })
      // filter by difficulty
      .filter((challenge) => {
        if (filterSetting.difficulties.length === 0) {
          return true
        }
        return filterSetting.difficulties.includes(challenge.difficulty)
      })
      // filter by tags
      .filter((challenge) => {
        if (filterSetting.tags.length === 0) {
          return true
        }
        return challenge.tagList.some((tag) =>
          filterSetting.tags.includes(tag)
        )
      })
      // filter by status
      .filter((challenge) => {
        if (filterSetting.status === null) {
          return true
        }
        return filterSetting.status === getCompleteChallengeStatus(challenge)
      })
      // filter disabled challenges
      .filter((challenge) => {
        if (challenge.disabledEnv === null) {
          return true
        }
        return filterSetting.showDisabledChallenges
      })
      // filter by search query
      .filter((challenge) => {
        if (filterSetting.searchQuery === null) {
          return true
        }
        return (
          challenge.name
            .toLowerCase()
            .includes(filterSetting.searchQuery.toLowerCase()) ||
          challenge.originalDescription
            .toLowerCase()
            .includes(filterSetting.searchQuery.toLowerCase())
        )
      })
      // filter by tutorial challenges
      .filter((challenge) => {
        if (!filterSetting.restrictToTutorialChallengesFirst) {
          return true
        }

        const tutorialChallenges = challenges.filter(
          (challenge) => challenge.tutorialOrder !== null
        )
        const allTutorialChallengesSolved = tutorialChallenges.every((challenge) => challenge.solved)

        if (allTutorialChallengesSolved) {
          return true
        } else if (!allTutorialChallengesSolved && challenge.tutorialOrder === null) {
          // there are still unsolved tutorial challenges, but this challenge is not a tutorial challenge so we don't want to show it
          return false
        }

        // find --include difficulty of unsolved tutorial challenges, we only want to show ones matching it or easier
        const difficultiesOfUnsolvedTutorialChallenges = tutorialChallenges
          .filter((challenge) => !challenge.solved)
          .map((challenge) => challenge.difficulty)
        const easiestDifficultyOfUnsolvedTutorialChallenges = Math.min(...difficultiesOfUnsolvedTutorialChallenges)

        if (challenge.difficulty <= easiestDifficultyOfUnsolvedTutorialChallenges) {
          return true
        }
        return false
      })
  )
}

function getCompleteChallengeStatus (
  challenge: EnrichedChallenge
): SolvedStatus {
  if (!challenge.solved) {
    return 'unsolved'
  }

  if (!challenge.hasCodingChallenge) {
    return challenge.solved ? 'solved' : 'unsolved'
  } else {
    if (challenge.codingChallengeStatus === 2) {
      return 'solved'
    }
    return 'partially-solved'
  }
}


/* ===== FILE: ./frontend/src/app/score-board/helpers/challenge-sorting.ts ===== */

import { type EnrichedChallenge } from '../types/EnrichedChallenge'

import sortBy from 'lodash-es/sortBy'

export function sortChallenges (
  challenges: EnrichedChallenge[]
): EnrichedChallenge[] {
  return sortBy(challenges, ['difficulty', 'tutorialOrder', 'name'])
}


/* ===== FILE: ./frontend/src/app/score-board/helpers/challenge-sorting.spec.ts ===== */

import { type EnrichedChallenge } from '../types/EnrichedChallenge'
import { sortChallenges } from './challenge-sorting'

const CHALLENGE_1 = {
  category: 'foobar',
  description: 'lorem ipsum',
  originalDescription: 'lorem ipsum',
  difficulty: 1,
  hasCodingChallenge: true,
  id: 1,
  key: 'challenge-1',
  mitigationUrl: 'https://owasp.example.com',
  name: 'challenge one',
  solved: false,
  codingChallengeStatus: 0,
  tagList: ['easy'],
  disabledEnv: null,
  tutorialOrder: 1
} as EnrichedChallenge

const CHALLENGE_2 = {
  category: 'foobar',
  description: 'lorem ipsum',
  originalDescription: 'lorem ipsum',
  difficulty: 1,
  hasCodingChallenge: true,
  id: 2,
  key: 'challenge-2',
  mitigationUrl: 'https://owasp.example.com',
  name: 'challenge two',
  solved: true,
  codingChallengeStatus: 2,
  tagList: ['easy'],
  disabledEnv: null,
  tutorialOrder: 2
} as EnrichedChallenge

const CHALLENGE_3 = {
  category: 'barfoo',
  description: 'lorem ipsum',
  originalDescription: 'lorem ipsum',
  difficulty: 6,
  hasCodingChallenge: true,
  id: 3,
  key: 'challenge-3',
  mitigationUrl: 'https://owasp.example.com',
  name: 'challenge three',
  solved: true,
  codingChallengeStatus: 1,
  tagList: ['hard'],
  disabledEnv: 'docker',
  tutorialOrder: null
} as EnrichedChallenge

describe('sortChallenges', () => {
  it('sort tutorial challenges correctly', () => {
    expect(sortChallenges([CHALLENGE_1, CHALLENGE_2]).map(challenge => challenge.key)).toEqual(['challenge-1', 'challenge-2'])
    expect(sortChallenges([CHALLENGE_2, CHALLENGE_1]).map(challenge => challenge.key)).toEqual(['challenge-1', 'challenge-2'])
    for (const challengeOrderingCombination of [
      [CHALLENGE_1, CHALLENGE_2],
      [CHALLENGE_2, CHALLENGE_1]
    ]) {
      expect(sortChallenges(challengeOrderingCombination).map(challenge => challenge.key)).toEqual(['challenge-1', 'challenge-2'])
    }
  })

  it('sort non tutorial challenges by difficulty while still maintaining tutorial order for challenges with tutorials', () => {
    for (const challengeOrderingCombination of [
      [CHALLENGE_1, CHALLENGE_2, CHALLENGE_3],
      [CHALLENGE_1, CHALLENGE_3, CHALLENGE_2],
      [CHALLENGE_2, CHALLENGE_1, CHALLENGE_3],
      [CHALLENGE_2, CHALLENGE_3, CHALLENGE_1],
      [CHALLENGE_3, CHALLENGE_1, CHALLENGE_2],
      [CHALLENGE_3, CHALLENGE_2, CHALLENGE_1]
    ]) {
      expect(sortChallenges(challengeOrderingCombination).map(challenge => challenge.key)).toEqual(['challenge-1', 'challenge-2', 'challenge-3'])
    }
  })
})


/* ===== FILE: ./frontend/src/app/score-board/score-board.component.ts ===== */

import { Component, NgZone, type OnDestroy, type OnInit } from '@angular/core'
import { ActivatedRoute, Router } from '@angular/router'
import { DomSanitizer } from '@angular/platform-browser'
import { MatDialog } from '@angular/material/dialog'
import { type Subscription, combineLatest } from 'rxjs'

import { fromQueryParams, toQueryParams } from './filter-settings/query-params-converters'
import { DEFAULT_FILTER_SETTING, type FilterSetting } from './filter-settings/FilterSetting'
import { type Config, ConfigurationService } from '../Services/configuration.service'
import { CodeSnippetComponent } from '../code-snippet/code-snippet.component'
import { ChallengeService } from '../Services/challenge.service'
import { filterChallenges } from './helpers/challenge-filtering'
import { SocketIoService } from '../Services/socket-io.service'
import { type EnrichedChallenge } from './types/EnrichedChallenge'
import { sortChallenges } from './helpers/challenge-sorting'
import { TranslateModule } from '@ngx-translate/core'
import { ChallengeCardComponent } from './components/challenge-card/challenge-card.component'
import { TutorialModeWarningComponent } from './components/tutorial-mode-warning/tutorial-mode-warning.component'
import { ChallengesUnavailableWarningComponent } from './components/challenges-unavailable-warning/challenges-unavailable-warning.component'
import { MatProgressSpinner } from '@angular/material/progress-spinner'
import { FilterSettingsComponent } from './components/filter-settings/filter-settings.component'
import { NgIf, NgFor, NgClass } from '@angular/common'
import { DifficultyOverviewScoreCardComponent } from './components/difficulty-overview-score-card/difficulty-overview-score-card.component'
import { CodingChallengeProgressScoreCardComponent } from './components/coding-challenge-progress-score-card/coding-challenge-progress-score-card.component'
import { HackingChallengeProgressScoreCardComponent } from './components/hacking-challenge-progress-score-card/hacking-challenge-progress-score-card.component'

interface ChallengeSolvedWebsocket {
  key: string
  name: string
  challenge: string
  flag: string
  hidden: boolean
  isRestore: boolean
}
interface CodeChallengeSolvedWebsocket {
  key: string
  codingChallengeStatus: 0 | 1 | 2
}

@Component({
  selector: 'app-score-board',
  templateUrl: './score-board.component.html',
  styleUrls: ['./score-board.component.scss'],
  imports: [HackingChallengeProgressScoreCardComponent, CodingChallengeProgressScoreCardComponent, DifficultyOverviewScoreCardComponent, NgIf, FilterSettingsComponent, MatProgressSpinner, ChallengesUnavailableWarningComponent, TutorialModeWarningComponent, NgFor, ChallengeCardComponent, NgClass, TranslateModule]
})
export class ScoreBoardComponent implements OnInit, OnDestroy {
  public allChallenges: EnrichedChallenge[] = []
  public filteredChallenges: EnrichedChallenge[] = []
  public filterSetting: FilterSetting = structuredClone(DEFAULT_FILTER_SETTING)
  public applicationConfiguration: Config | null = null

  public isInitialized: boolean = false

  private readonly subscriptions: Subscription[] = []

  constructor (
    private readonly challengeService: ChallengeService,
    private readonly configurationService: ConfigurationService,
    private readonly sanitizer: DomSanitizer,
    private readonly ngZone: NgZone,
    private readonly io: SocketIoService,
    private readonly dialog: MatDialog,
    private readonly router: Router,
    private readonly route: ActivatedRoute
  ) { }

  ngOnInit (): void {
    const dataLoaderSubscription = combineLatest([
      this.challengeService.find({ sort: 'name' }),
      this.configurationService.getApplicationConfiguration()
    ]).subscribe(([challenges, applicationConfiguration]) => {
      this.applicationConfiguration = applicationConfiguration

      const transformedChallenges = challenges.map((challenge) => {
        return {
          ...challenge,
          tagList: challenge.tags ? challenge.tags.split(',').map((tag) => tag.trim()) : [],
          originalDescription: challenge.description as string,
          description: this.sanitizer.bypassSecurityTrustHtml(challenge.description as string)
        }
      })

      this.allChallenges = transformedChallenges
      this.filterAndUpdateChallenges()
      this.isInitialized = true
    })
    this.subscriptions.push(dataLoaderSubscription)

    const routerSubscription = this.route.queryParams.subscribe((queryParams) => {
      this.filterSetting = fromQueryParams(queryParams)
      this.filterAndUpdateChallenges()
    })
    this.subscriptions.push(routerSubscription)

    this.io.socket().on('challenge solved', this.onChallengeSolvedWebsocket.bind(this))
    this.io.socket().on('code challenge solved', this.onCodeChallengeSolvedWebsocket.bind(this))
  }

  ngOnDestroy (): void {
    this.io.socket().off('challenge solved', this.onChallengeSolvedWebsocket.bind(this))
    this.io.socket().off('code challenge solved', this.onCodeChallengeSolvedWebsocket.bind(this))
    for (const subscription of this.subscriptions) {
      subscription.unsubscribe()
    }
  }

  onFilterSettingUpdate (filterSetting: FilterSetting) {
    this.router.navigate([], {
      queryParams: toQueryParams(filterSetting)
    })
  }

  onChallengeSolvedWebsocket (data?: ChallengeSolvedWebsocket) {
    if (!data) {
      return
    }

    this.allChallenges = this.allChallenges.map((challenge) => {
      if (challenge.key === data.key) {
        return {
          ...challenge,
          solved: true
        }
      }
      return { ...challenge }
    })
    this.filterAndUpdateChallenges()
    // manually trigger angular change detection... :(
    // unclear why this is necessary, possibly because the socket.io callback is not running inside angular
    this.ngZone.run(() => {})
  }

  onCodeChallengeSolvedWebsocket (data?: CodeChallengeSolvedWebsocket) {
    if (!data) {
      return
    }

    this.allChallenges = this.allChallenges.map((challenge) => {
      if (challenge.key === data.key) {
        return {
          ...challenge,
          codingChallengeStatus: data.codingChallengeStatus
        }
      }
      return { ...challenge }
    })
    this.filterAndUpdateChallenges()
    // manually trigger angular change detection... :(
    // unclear why this is necessary, possibly because the socket.io callback is not running inside angular
    this.ngZone.run(() => {})
  }

  filterAndUpdateChallenges (): void {
    this.filteredChallenges = sortChallenges(
      filterChallenges(this.allChallenges, {
        ...this.filterSetting,
        restrictToTutorialChallengesFirst: this.applicationConfiguration?.challenges?.restrictToTutorialsFirst ?? true
      })
    )
  }

  // angular helper to speed up challenge rendering
  getChallengeKey (index: number, challenge: EnrichedChallenge): string {
    return challenge.key
  }

  reset () {
    this.router.navigate([], {
      queryParams: toQueryParams(DEFAULT_FILTER_SETTING)
    })
  }

  openCodingChallengeDialog (challengeKey: string) {
    const challenge = this.allChallenges.find((challenge) => challenge.key === challengeKey)

    this.dialog.open(CodeSnippetComponent, {
      disableClose: true,
      data: {
        key: challengeKey,
        name: challenge.name,
        codingChallengeStatus: challenge.codingChallengeStatus
      }
    })
  }

  async repeatChallengeNotification (challengeKey: string) {
    const challenge = this.allChallenges.find((challenge) => challenge.key === challengeKey)
    await this.challengeService.repeatNotification(encodeURIComponent(challenge.name)).toPromise()
  }
}


/* ===== FILE: ./frontend/src/app/payment/payment.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { UntypedFormControl, Validators, FormsModule, ReactiveFormsModule } from '@angular/forms'
import { Component, NgZone, type OnInit } from '@angular/core'
import { ConfigurationService } from '../Services/configuration.service'
import { BasketService } from '../Services/basket.service'
import { TranslateService, TranslateModule } from '@ngx-translate/core'
import { library } from '@fortawesome/fontawesome-svg-core'
import {
  faCartArrowDown,
  faCoffee,
  faGift,
  faHandHoldingUsd,
  faHeart,
  faStickyNote,
  faThumbsUp,
  faTimes,
  faTshirt,
  faPalette
} from '@fortawesome/free-solid-svg-icons'
import { faLeanpub, faStripe } from '@fortawesome/free-brands-svg-icons'
import { QrCodeComponent } from '../qr-code/qr-code.component'
import { MatDialog } from '@angular/material/dialog'
import { ActivatedRoute, type ParamMap, Router } from '@angular/router'
import { WalletService } from '../Services/wallet.service'
import { DeliveryService } from '../Services/delivery.service'
import { UserService } from '../Services/user.service'
import { CookieService } from 'ngy-cookie'
import { Location, NgIf } from '@angular/common'
import { SnackBarHelperService } from '../Services/snack-bar-helper.service'
import { MatIconModule } from '@angular/material/icon'
import { MatInputModule } from '@angular/material/input'
import { MatFormFieldModule, MatLabel, MatHint, MatError } from '@angular/material/form-field'
import { MatExpansionPanel, MatExpansionPanelHeader, MatExpansionPanelTitle, MatExpansionPanelDescription } from '@angular/material/expansion'
import { MatButtonModule } from '@angular/material/button'
import { FlexModule } from '@angular/flex-layout/flex'
import { MatDivider } from '@angular/material/divider'
import { PaymentMethodComponent } from '../payment-method/payment-method.component'
import { MatCardModule } from '@angular/material/card'

library.add(faCartArrowDown, faGift, faHeart, faLeanpub, faThumbsUp, faTshirt, faStickyNote, faHandHoldingUsd, faCoffee, faTimes, faStripe, faPalette)

@Component({
  selector: 'app-payment',
  templateUrl: './payment.component.html',
  styleUrls: ['./payment.component.scss'],
  imports: [MatCardModule, PaymentMethodComponent, MatDivider, NgIf, FlexModule, TranslateModule, MatButtonModule, MatExpansionPanel, MatExpansionPanelHeader, MatExpansionPanelTitle, MatExpansionPanelDescription, MatFormFieldModule, MatLabel, MatHint, MatInputModule, FormsModule, ReactiveFormsModule, MatError, MatIconModule]
})
export class PaymentComponent implements OnInit {
  public couponConfirmation: any
  public couponError: any
  public card: any = {}
  public blueSkyUrl = null
  public redditUrl = null
  public applicationName = 'OWASP Juice Shop'
  private campaignCoupon: string
  public couponControl: UntypedFormControl = new UntypedFormControl('', [Validators.required, Validators.minLength(10), Validators.maxLength(10)])
  public clientDate: any
  public paymentId: any = undefined
  public couponPanelExpanded: boolean = false
  public paymentPanelExpanded: boolean = false
  public mode: any
  public walletBalance: number = 0
  public walletBalanceStr: string
  public totalPrice: any = 0
  public paymentMode: string = 'card'
  private readonly campaigns = {
    WMNSDY2019: { validOn: 1551999600000, discount: 75 },
    WMNSDY2020: { validOn: 1583622000000, discount: 60 },
    WMNSDY2021: { validOn: 1615158000000, discount: 60 },
    WMNSDY2022: { validOn: 1646694000000, discount: 60 },
    WMNSDY2023: { validOn: 1678230000000, discount: 60 },
    ORANGE2020: { validOn: 1588546800000, discount: 50 },
    ORANGE2021: { validOn: 1620082800000, discount: 40 },
    ORANGE2022: { validOn: 1651618800000, discount: 40 },
    ORANGE2023: { validOn: 1683154800000, discount: 40 }
  }

  constructor (private readonly location: Location, private readonly cookieService: CookieService,
    private readonly userService: UserService, private readonly deliveryService: DeliveryService, private readonly walletService: WalletService,
    private readonly router: Router, private readonly dialog: MatDialog, private readonly configurationService: ConfigurationService,
    private readonly basketService: BasketService, private readonly translate: TranslateService,
    private readonly activatedRoute: ActivatedRoute, private readonly ngZone: NgZone,
    private readonly snackBarHelperService: SnackBarHelperService) { }

  ngOnInit (): void {
    this.initTotal()
    this.walletService.get().subscribe((balance) => {
      this.walletBalance = balance
      this.walletBalanceStr = parseFloat(balance).toFixed(2)
    }, (err) => { console.log(err) })
    this.couponPanelExpanded = localStorage.getItem('couponPanelExpanded') ? JSON.parse(localStorage.getItem('couponPanelExpanded')) : false
    this.paymentPanelExpanded = localStorage.getItem('paymentPanelExpanded') ? JSON.parse(localStorage.getItem('paymentPanelExpanded')) : false

    this.configurationService.getApplicationConfiguration().subscribe((config) => {
      if (config?.application?.social) {
        if (config.application.social.blueSkyUrl) {
          this.blueSkyUrl = config.application.social.blueSkyUrl
        }
        if (config.application.social.redditUrl) {
          this.redditUrl = config.application.social.redditUrl
        }
        if (config.application.name) {
          this.applicationName = config.application.name
        }
      }
    }, (err) => { console.log(err) })
  }

  initTotal () {
    this.activatedRoute.paramMap.subscribe((paramMap: ParamMap) => {
      this.mode = paramMap.get('entity')
      if (this.mode === 'wallet') {
        this.totalPrice = parseFloat(sessionStorage.getItem('walletTotal'))
      } else if (this.mode === 'deluxe') {
        this.userService.deluxeStatus().subscribe((res) => {
          this.totalPrice = res.membershipCost
        }, (err) => { console.log(err) })
      } else {
        const itemTotal = parseFloat(sessionStorage.getItem('itemTotal'))
        const promotionalDiscount = sessionStorage.getItem('couponDiscount') ? (parseFloat(sessionStorage.getItem('couponDiscount')) / 100) * itemTotal : 0
        this.deliveryService.getById(sessionStorage.getItem('deliveryMethodId')).subscribe((method) => {
          const deliveryPrice = method.price
          this.totalPrice = itemTotal + deliveryPrice - promotionalDiscount
        })
      }
    }, (err) => { console.log(err) })
  }

  applyCoupon () {
    this.campaignCoupon = this.couponControl.value
    this.clientDate = new Date()
    // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
    const offsetTimeZone = (this.clientDate.getTimezoneOffset() + 60) * 60 * 1000
    this.clientDate.setHours(0, 0, 0, 0)
    this.clientDate = this.clientDate.getTime() - offsetTimeZone
    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
    sessionStorage.setItem('couponDetails', `${this.campaignCoupon}-${this.clientDate}`)
    const campaign = this.campaigns[this.couponControl.value]
    if (campaign) {
      if (this.clientDate === campaign.validOn) {
        this.showConfirmation(campaign.discount)
      } else {
        this.couponConfirmation = undefined
        this.translate.get('INVALID_COUPON').subscribe((invalidCoupon) => {
          this.couponError = { error: invalidCoupon }
        }, (translationId) => {
          this.couponError = { error: translationId }
        })
        this.resetCouponForm()
      }
    } else {
      this.basketService.applyCoupon(Number(sessionStorage.getItem('bid')), encodeURIComponent(this.couponControl.value)).subscribe((discount: any) => {
        this.showConfirmation(discount)
      }, (err) => {
        this.couponConfirmation = undefined
        this.couponError = err
        this.resetCouponForm()
      })
    }
  }

  showConfirmation (discount) {
    this.resetCouponForm()
    this.couponError = undefined
    sessionStorage.setItem('couponDiscount', discount)
    this.translate.get('DISCOUNT_APPLIED', { discount }).subscribe((discountApplied) => {
      this.couponConfirmation = discountApplied
    }, (translationId) => {
      this.couponConfirmation = translationId
    })
    this.initTotal()
  }

  getMessage (id) {
    this.paymentId = id
    this.paymentMode = 'card'
  }

  routeToPreviousUrl () {
    this.location.back()
  }

  choosePayment () {
    sessionStorage.removeItem('itemTotal')
    if (this.mode === 'wallet') {
      this.walletService.put({ balance: this.totalPrice, paymentId: this.paymentId }).subscribe(() => {
        sessionStorage.removeItem('walletTotal')
        this.ngZone.run(async () => await this.router.navigate(['/wallet']))
        this.snackBarHelperService.open('CHARGED_WALLET', 'confirmBar')
      }, (err) => {
        console.log(err)
        this.snackBarHelperService.open(err.error?.message, 'errorBar')
      })
    } else if (this.mode === 'deluxe') {
      this.userService.upgradeToDeluxe(this.paymentMode, this.paymentId).subscribe((data) => {
        localStorage.setItem('token', data.token)
        this.cookieService.put('token', data.token)
        this.ngZone.run(async () => await this.router.navigate(['/deluxe-membership']))
      }, (err) => { console.log(err) })
    } else {
      if (this.paymentMode === 'wallet') {
        if (this.walletBalance < this.totalPrice) {
          this.snackBarHelperService.open('INSUFFICIENT_WALLET_BALANCE', 'errorBar')
          return
        }
        sessionStorage.setItem('paymentId', 'wallet')
      } else {
        sessionStorage.setItem('paymentId', this.paymentId)
      }
      this.ngZone.run(async () => await this.router.navigate(['/order-summary']))
    }
  }

  // eslint-disable-next-line no-empty,@typescript-eslint/no-empty-function
  noop () { }

  showBitcoinQrCode () {
    this.dialog.open(QrCodeComponent, {
      data: {
        data: 'bitcoin:1AbKfgvw9psQ41NbLi8kufDQTezwG8DRZm',
        url: './redirect?to=https://blockchain.info/address/1AbKfgvw9psQ41NbLi8kufDQTezwG8DRZm',
        address: '1AbKfgvw9psQ41NbLi8kufDQTezwG8DRZm',
        title: 'TITLE_BITCOIN_ADDRESS'
      }
    })
  }

  showDashQrCode () {
    this.dialog.open(QrCodeComponent, {
      data: {
        data: 'dash:Xr556RzuwX6hg5EGpkybbv5RanJoZN17kW',
        url: './redirect?to=https://explorer.dash.org/address/Xr556RzuwX6hg5EGpkybbv5RanJoZN17kW',
        address: 'Xr556RzuwX6hg5EGpkybbv5RanJoZN17kW',
        title: 'TITLE_DASH_ADDRESS'
      }
    })
  }

  showEtherQrCode () {
    this.dialog.open(QrCodeComponent, {
      data: {
        data: '0x0f933ab9fCAAA782D0279C300D73750e1311EAE6',
        url: './redirect?to=https://etherscan.io/address/0x0f933ab9fcaaa782d0279c300d73750e1311eae6',
        address: '0x0f933ab9fCAAA782D0279C300D73750e1311EAE6',
        title: 'TITLE_ETHER_ADDRESS'
      }
    })
  }

  useWallet () {
    this.paymentMode = 'wallet'
    this.choosePayment()
  }

  resetCouponForm () {
    this.couponControl.setValue('')
    this.couponControl.markAsPristine()
    this.couponControl.markAsUntouched()
  }
}


/* ===== FILE: ./frontend/src/app/payment/payment.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<mat-card appearance="outlined" class="mat-own-card mat-elevation-z6">
  <div class="mdc-card">
    <app-payment-method (emitSelection)="getMessage($event)" [allowDelete]="false"></app-payment-method>
    <mat-divider></mat-divider>
    <div class="mat-elevation-z0" class="custom-card" *ngIf="mode !== 'wallet'">
      <div fxLayout="row">
        <div fxFlex="42%">
          <span translate class="card-title">LABEL_PAY_USING_WALLET</span>
        </div>
        <div fxFlex="38%">
          <b>
            <span class="card-title" translate>LABEL_WALLET_BALANCE</span>
            <span class="confirmation card-title"> {{ walletBalanceStr }}</span>
          </b>
        </div>
        <div fxFlex="20%">
          <button type="submit" color="primary" mat-raised-button class="btn" style="float: right;"
                  [disabled]="(walletBalance - totalPrice) < 0" (click)="useWallet()">
            <i class="fas fa-hand-holding-usd fa-lg"></i> {{'LABEL_PAY' | translate}} {{ totalPrice?.toFixed(2) }}¤
          </button>
        </div>
      </div>
    </div>
    <mat-divider></mat-divider>
    <mat-expansion-panel class="mat-elevation-z0" [expanded]="couponPanelExpanded" id="collapseCouponElement"
                         *ngIf="mode !== 'wallet'">
      <mat-expansion-panel-header class="detail-divider">
        <mat-panel-title>
          {{"ADD_A_COUPON" | translate}}
        </mat-panel-title>
        <mat-panel-description>
          {{"VOUCHERS_AND_PROMOTIONAL_CODE" | translate}}
        </mat-panel-description>
      </mat-expansion-panel-header>
      <div *ngIf="couponConfirmation && !couponControl.dirty" style="margin-top:5px;" class="confirmation">{{
        couponConfirmation }}
      </div>
      <div *ngIf="couponError && !couponControl.dirty" style="margin-top:5px;" class="error">{{couponError?.error}}
      </div>
      <mat-form-field appearance="outline" color="accent">
        <mat-label translate>LABEL_COUPON</mat-label>
        <mat-hint
            [innerHtml]="'FOLLOW_FOR_MONTHLY_COUPONS' | translate:{blueSky: blueSkyUrl, reddit: redditUrl}">
        </mat-hint>
        <input #coupon id="coupon" [formControl]="couponControl" matInput type="text" placeholder="{{ 'ENTER_COUPON_CODE' | translate}}">
        <mat-hint align="end">{{coupon .value?.length || 0}}/10</mat-hint>
        <mat-error *ngIf="couponControl.invalid && (couponControl.errors.minlength || couponControl.errors.maxlength)">
          {{'COUPON_CODE_HINT' | translate}}
        </mat-error>
      </mat-form-field>
      <button type="submit" id="applyCouponButton" color="accent" style="margin-top:5px; float: right;" (click)="applyCoupon()"
              [disabled]="couponControl.invalid" mat-raised-button>
        <mat-icon>
          redeem
        </mat-icon>
        {{'BTN_REDEEM' | translate}}
      </button>
    </mat-expansion-panel>
    <mat-divider></mat-divider>
    <mat-expansion-panel class="mat-elevation-z0" [expanded]="paymentPanelExpanded" *ngIf="mode !== 'wallet'">
      <mat-expansion-panel-header class="detail-divider">
        <mat-panel-title>
          {{"OTHER_PAYMENT_OPTIONS" | translate}}
        </mat-panel-title>
      </mat-expansion-panel-header>
      <div fxLayout="row" fxLayout.lt-lg="column">
        <div fxFlex="34%" fxFlex.lt-lg="100%" class="mat-elevation-z0">
          <div class="payment-label">
            <label translate>LABEL_DONATIONS</label>
          </div>
          <small>
            (<span *ngIf="applicationName === 'OWASP Juice Shop'" translate
                   [translateParams]="{juiceshop: 'OWASP Juice Shop'}">THANKS_FOR_SUPPORT</span>
            <span *ngIf="applicationName !== 'OWASP Juice Shop'" translate
                  [translateParams]="{appname: applicationName}">THANKS_FOR_SUPPORT_CUSTOMIZED</span>
            <i style="margin-left: 3px;" class="fas fa-heart error"></i>)
          </small>
          <div class="button-container" style="margin-top: 6px;">
            <a href="https://pwning.owasp-juice.shop/companion-guide/latest/part3/donations.html">
              <button mat-stroked-button><i class="fab fa-stripe fa-lg"></i> {{'BTN_CREDIT_CARD' | translate}}</button>
            </a>
            <button mat-stroked-button (click)="showBitcoinQrCode()" *ngIf="false"><i class="fab fa-btc fa-lg"></i>
              Bitcoin
            </button>
            <button mat-stroked-button (click)="showDashQrCode()" *ngIf="false"><i class="fa-lg">Ð</i> Dash</button>
            <button mat-stroked-button (click)="showEtherQrCode()" *ngIf="false"><i class="fab fa-ethereum fa-lg"></i>
              Ether
            </button>
          </div>
        </div>
        <span class="fill-remaining-space"></span>
        <div fxFlex="65%" fxFlex.lt-lg="100%" class="mat-elevation-z0">
          <div class="payment-label">
            <label translate>LABEL_MERCHANDISE</label>
          </div>
          <small>
            (<span *ngIf="applicationName === 'OWASP Juice Shop'" translate
                   [translateParams]="{juiceshop: 'OWASP Juice Shop'}">OFFICIAL_MERCHANDISE_STORES</span>
            <span *ngIf="applicationName !== 'OWASP Juice Shop'" translate
                  [translateParams]="{appname: applicationName}">OFFICIAL_MERCHANDISE_STORES_CUSTOMIZED</span>
            <i style="margin-left: 3px;" class="fas fa-thumbs-up confirmation"></i>)
          </small>
          <div class="button-container" style="margin-top: 6px;">
            <a href="./redirect?to=http://shop.spreadshirt.com/juiceshop">
              <button mat-stroked-button><i class="fas fa-tshirt fa-lg"></i> Spreadshirt (US)</button>
            </a>
            <a href="./redirect?to=http://shop.spreadshirt.de/juiceshop">
              <button mat-stroked-button><i class="fas fa-tshirt fa-lg"></i> Spreadshirt (DE)</button>
            </a>
            <a href="./redirect?to=https://www.stickeryou.com/products/owasp-juice-shop/794">
              <button mat-stroked-button><i class="fas fa-sticky-note fa-lg"></i> StickerYou</button>
            </a>
            <a href="./redirect?to=http://leanpub.com/juice-shop">
              <button mat-stroked-button><i class="fab fa-leanpub fa-lg"></i> Leanpub</button>
            </a>
            <a href="https://opensea.io/collection/juice-shop">
              <button mat-stroked-button><i class="fas fa-palette fa-lg"></i> OpenSea</button>
            </a>
          </div>
        </div>
      </div>
    </mat-expansion-panel>
    <mat-divider></mat-divider>
    <div style="margin-top: 20px; margin-bottom: 20px;">
      <button mat-stroked-button class="btn btn-return" (click)="routeToPreviousUrl()">
        <mat-icon>
          navigate_before
        </mat-icon>
        {{'LABEL_BACK' | translate}}
      </button>
      <button mat-raised-button mat-button class="btn nextButton" color="primary" aria-label="Proceed to review"
              [disabled]="paymentId === undefined && paymentMode !== 'wallet'" (click)="choosePayment()">
        <mat-icon>
          navigate_next
        </mat-icon>
        <span translate>LABEL_CONTINUE</span>
      </button>
      <p style="text-align: center;margin-top: -27px;">
        <span translate *ngIf="mode !== 'deluxe' && mode !== 'wallet'">REVIEW_ALERT</span>
        <span translate *ngIf="mode === 'wallet'">REVIEW_WALLET</span>
      </p>
    </div>
  </div>

</mat-card>


/* ===== FILE: ./frontend/src/app/payment/payment.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateModule, TranslateService } from '@ngx-translate/core'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { MatCardModule } from '@angular/material/card'
import { MatFormFieldModule } from '@angular/material/form-field'
import { type ComponentFixture, fakeAsync, TestBed, waitForAsync } from '@angular/core/testing'
import { PaymentComponent } from './payment.component'
import { MatInputModule } from '@angular/material/input'
import { ReactiveFormsModule } from '@angular/forms'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'

import { of, throwError } from 'rxjs'
import { MatTableModule } from '@angular/material/table'
import { MatExpansionModule } from '@angular/material/expansion'
import { MatDividerModule } from '@angular/material/divider'
import { MatRadioModule } from '@angular/material/radio'
import { ConfigurationService } from '../Services/configuration.service'
import { EventEmitter } from '@angular/core'
import { BasketService } from '../Services/basket.service'
import { QrCodeComponent } from '../qr-code/qr-code.component'
import { MatDialog, MatDialogModule } from '@angular/material/dialog'
import { PaymentMethodComponent } from '../payment-method/payment-method.component'
import { RouterTestingModule } from '@angular/router/testing'
import { OrderSummaryComponent } from '../order-summary/order-summary.component'
import { PurchaseBasketComponent } from '../purchase-basket/purchase-basket.component'
import { CookieService } from 'ngy-cookie'
import { WalletService } from '../Services/wallet.service'
import { DeliveryService } from '../Services/delivery.service'
import { UserService } from '../Services/user.service'
import { LoginComponent } from '../login/login.component'
import { Location } from '@angular/common'
import { WalletComponent } from '../wallet/wallet.component'
import { MatIconModule } from '@angular/material/icon'
import { MatCheckboxModule } from '@angular/material/checkbox'
import { MatTooltipModule } from '@angular/material/tooltip'
import { MatSnackBar } from '@angular/material/snack-bar'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('PaymentComponent', () => {
  let component: PaymentComponent
  let fixture: ComponentFixture<PaymentComponent>
  let configurationService
  let translateService
  let basketService
  let dialog
  let cookieService: any
  let walletService: any
  let deliveryService: any
  let userService: any
  let snackBar: any

  beforeEach(waitForAsync(() => {
    configurationService = jasmine.createSpyObj('ConfigurationService', ['getApplicationConfiguration'])
    configurationService.getApplicationConfiguration.and.returnValue(of({}))
    translateService = jasmine.createSpyObj('TranslateService', ['get'])
    translateService.get.and.returnValue(of({}))
    translateService.onLangChange = new EventEmitter()
    translateService.onTranslationChange = new EventEmitter()
    translateService.onDefaultLangChange = new EventEmitter()
    basketService = jasmine.createSpyObj('BasketService', ['applyCoupon'])
    basketService.applyCoupon.and.returnValue(of({}))
    dialog = jasmine.createSpyObj('MatDialog', ['open'])
    dialog.open.and.returnValue(null)
    cookieService = jasmine.createSpyObj('CookieService', ['remove', 'put'])
    walletService = jasmine.createSpyObj('AddressService', ['get', 'put'])
    walletService.get.and.returnValue(of({}))
    walletService.put.and.returnValue(of({}))
    deliveryService = jasmine.createSpyObj('DeliveryService', ['getById'])
    deliveryService.getById.and.returnValue(of({ price: 10 }))
    userService = jasmine.createSpyObj('UserService', ['deluxeStatus', 'upgradeToDeluxe', 'saveLastLoginIp'])
    userService.deluxeStatus.and.returnValue(of({}))
    userService.upgradeToDeluxe.and.returnValue(of({}))
    userService.isLoggedIn = jasmine.createSpyObj('userService.isLoggedIn', ['next'])
    userService.isLoggedIn.next.and.returnValue({})
    userService.saveLastLoginIp.and.returnValue(of({}))
    snackBar = jasmine.createSpyObj('MatSnackBar', ['open'])

    TestBed.configureTestingModule({
      imports: [RouterTestingModule.withRoutes([
        { path: 'order-summary', component: OrderSummaryComponent },
        { path: 'login', component: LoginComponent },
        { path: 'wallet', component: WalletComponent }
      ]),
      TranslateModule.forRoot(),
      ReactiveFormsModule,
      BrowserAnimationsModule,
      MatCardModule,
      MatTableModule,
      MatFormFieldModule,
      MatInputModule,
      MatExpansionModule,
      MatDividerModule,
      MatRadioModule,
      MatDialogModule,
      MatIconModule,
      MatCheckboxModule,
      MatTooltipModule,
      PaymentComponent, PaymentMethodComponent, OrderSummaryComponent, PurchaseBasketComponent, LoginComponent, WalletComponent],
      providers: [
        { provide: BasketService, useValue: basketService },
        { provide: MatDialog, useValue: dialog },
        { provide: TranslateService, useValue: translateService },
        { provide: ConfigurationService, useValue: configurationService },
        { provide: CookieService, useValue: cookieService },
        { provide: WalletService, useValue: walletService },
        { provide: DeliveryService, useValue: deliveryService },
        { provide: UserService, useValue: userService },
        { provide: MatSnackBar, useValue: snackBar },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
    TestBed.inject(Location)
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(PaymentComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should not hold blueSky or reddit URL if not defined in configuration', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({}))
    expect(component.blueSkyUrl).toBeNull()
    expect(component.redditUrl).toBeNull()
  })

  it('should hold the default applicationName if not defined in configuration', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({}))
    expect(component.applicationName).toBe('OWASP Juice Shop')
  })

  it('should use custom blueSky URL if configured', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { social: { blueSkyUrl: 'blueSky' } } }))
    component.ngOnInit()
    expect(component.blueSkyUrl).toBe('blueSky')
  })

  it('should use custom reddit URL if configured', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { social: { redditUrl: 'reddit' } } }))
    component.ngOnInit()
    expect(component.redditUrl).toBe('reddit')
  })

  it('should log error while getting application configuration from backend API directly to browser console', fakeAsync(() => {
    configurationService.getApplicationConfiguration.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.ngOnInit()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should reinitizalise coupon code form by calling resetCouponForm', () => {
    component.couponControl.setValue('1234567890')
    component.resetCouponForm()
    expect(component.couponControl.value).toBe('')
    expect(component.couponControl.pristine).toBe(true)
    expect(component.couponControl.untouched).toBe(true)
  })

  it('should reject an invalid coupon code', fakeAsync(() => {
    basketService.applyCoupon.and.returnValue(throwError('Error'))

    component.couponControl.setValue('')
    component.couponControl.markAsPristine()
    component.couponControl.markAsUntouched()

    component.couponControl.setValue('invalid_base85')
    component.applyCoupon()

    expect(component.couponConfirmation).toBeUndefined()
    expect(component.couponError).toBe('Error')
  }))

  it('should accept a valid coupon code', () => {
    basketService.applyCoupon.and.returnValue(of(42))
    translateService.get.and.returnValue(of('DISCOUNT_APPLIED'))

    component.couponControl.setValue('')
    component.couponControl.markAsPristine()
    component.couponControl.markAsUntouched()

    component.couponControl.setValue('valid_base85')
    component.applyCoupon()

    expect(translateService.get).toHaveBeenCalledWith('DISCOUNT_APPLIED', { discount: 42 })
    expect(component.couponError).toBeUndefined()
  })

  it('should translate DISCOUNT_APPLIED message', () => {
    basketService.applyCoupon.and.returnValue(of(42))
    translateService.get.and.returnValue(of('Translation of DISCOUNT_APPLIED'))
    component.couponControl.setValue('')
    component.couponControl.markAsPristine()
    component.couponControl.markAsUntouched()

    component.couponControl.setValue('valid_base85')
    component.applyCoupon()

    expect(component.couponConfirmation).toBe('Translation of DISCOUNT_APPLIED')
    expect(component.couponError).toBeUndefined()
  })

  it('should store discount percent in session storage', () => {
    translateService.get.and.returnValue(of('Translation of DISCOUNT_APPLIED'))
    spyOn(sessionStorage, 'setItem')
    component.showConfirmation(70)
    expect(sessionStorage.setItem).toHaveBeenCalledWith('couponDiscount', 70 as any)
  })

  it('should store payment id on calling getMessage', () => {
    component.getMessage(1)
    expect(component.paymentId).toBe(1)
    expect(component.paymentMode).toEqual('card')
  })

  it('should open QrCodeComponent for Bitcoin', () => {
    component.showBitcoinQrCode()
    const data = {
      data: {
        data: 'bitcoin:1AbKfgvw9psQ41NbLi8kufDQTezwG8DRZm',
        url: './redirect?to=https://blockchain.info/address/1AbKfgvw9psQ41NbLi8kufDQTezwG8DRZm',
        address: '1AbKfgvw9psQ41NbLi8kufDQTezwG8DRZm',
        title: 'TITLE_BITCOIN_ADDRESS'
      }
    }
    expect(dialog.open).toHaveBeenCalledWith(QrCodeComponent, data)
  })

  it('should open QrCodeComponent for Dash', () => {
    component.showDashQrCode()
    const data = {
      data: {
        data: 'dash:Xr556RzuwX6hg5EGpkybbv5RanJoZN17kW',
        url: './redirect?to=https://explorer.dash.org/address/Xr556RzuwX6hg5EGpkybbv5RanJoZN17kW',
        address: 'Xr556RzuwX6hg5EGpkybbv5RanJoZN17kW',
        title: 'TITLE_DASH_ADDRESS'
      }
    }
    expect(dialog.open).toHaveBeenCalledWith(QrCodeComponent, data)
  })

  it('should open QrCodeComponent for Ether', () => {
    component.showEtherQrCode()
    const data = {
      data: {
        data: '0x0f933ab9fCAAA782D0279C300D73750e1311EAE6',
        url: './redirect?to=https://etherscan.io/address/0x0f933ab9fcaaa782d0279c300d73750e1311eae6',
        address: '0x0f933ab9fCAAA782D0279C300D73750e1311EAE6',
        title: 'TITLE_ETHER_ADDRESS'
      }
    }
    expect(dialog.open).toHaveBeenCalledWith(QrCodeComponent, data)
  })

  it('should call initTotal on calling ngOnInit', () => {
    spyOn(component, 'initTotal')
    component.ngOnInit()
    expect(component.initTotal).toHaveBeenCalled()
  })

  it('should call initTotal on calling showConfirmation', () => {
    spyOn(component, 'initTotal')
    component.showConfirmation(10)
    expect(component.initTotal).toHaveBeenCalled()
  })

  it('should make paymentMode wallet on calling useWallet', () => {
    component.useWallet()
    expect(component.paymentMode).toEqual('wallet')
  })

  it('should store paymentId in session storage on calling choosePayment in shop mode', () => {
    component.mode = 'shop'
    component.paymentMode = 'card'
    component.paymentId = 1
    spyOn(sessionStorage, 'setItem')
    component.choosePayment()
    expect(sessionStorage.setItem).toHaveBeenCalledWith('paymentId', 1 as any)
  })

  it('should store wallet as paymentId in session storage on calling choosePayment while paymentMode is equal to wallet', () => {
    component.mode = 'shop'
    component.paymentMode = 'wallet'
    spyOn(sessionStorage, 'setItem')
    component.choosePayment()
    expect(sessionStorage.setItem).toHaveBeenCalledWith('paymentId', 'wallet')
  })

  it('should log error from upgrade to deluxe API call directly to browser console', fakeAsync(() => {
    component.mode = 'deluxe'
    userService.upgradeToDeluxe.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.choosePayment()
    fixture.detectChanges()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should remove walletTotal from session storage on calling choosePayment in wallet mode', () => {
    component.mode = 'wallet'
    walletService.put.and.returnValue(of({}))
    spyOn(sessionStorage, 'removeItem')
    component.choosePayment()
    expect(sessionStorage.removeItem).toHaveBeenCalledWith('walletTotal')
  })

  it('should add token to local storage and cookie on calling choosePayment in deluxe mode', () => {
    component.mode = 'deluxe'
    userService.upgradeToDeluxe.and.returnValue(of({ token: 'tokenValue' }))
    spyOn(localStorage, 'setItem')
    component.choosePayment()
    expect(localStorage.setItem).toHaveBeenCalledWith('token', 'tokenValue')
    expect(cookieService.put).toHaveBeenCalledWith('token', 'tokenValue')
  })
})


/* ===== FILE: ./frontend/src/app/recycle/recycle.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { ConfigurationService } from '../Services/configuration.service'
import { UserService } from '../Services/user.service'
import { RecycleService } from '../Services/recycle.service'
import { Component, type OnInit, ViewChild } from '@angular/core'
import { UntypedFormControl, Validators, FormsModule, ReactiveFormsModule } from '@angular/forms'
import { library } from '@fortawesome/fontawesome-svg-core'
import { faPaperPlane } from '@fortawesome/free-solid-svg-icons'
import { FormSubmitService } from '../Services/form-submit.service'
import { AddressComponent } from '../address/address.component'
import { TranslateService, TranslateModule } from '@ngx-translate/core'
import { SnackBarHelperService } from '../Services/snack-bar-helper.service'
import { MatButtonModule } from '@angular/material/button'
import { MatCheckbox } from '@angular/material/checkbox'
import { MatDatepickerInput, MatDatepickerToggle, MatDatepicker } from '@angular/material/datepicker'
import { NgIf } from '@angular/common'
import { MatInputModule } from '@angular/material/input'
import { MatFormFieldModule, MatLabel, MatError, MatSuffix } from '@angular/material/form-field'
import { FlexModule } from '@angular/flex-layout/flex'
import { MatCardModule, MatCardImage, MatCardContent } from '@angular/material/card'

library.add(faPaperPlane)

@Component({
  selector: 'app-recycle',
  templateUrl: './recycle.component.html',
  styleUrls: ['./recycle.component.scss'],
  imports: [MatCardModule, FlexModule, TranslateModule, MatFormFieldModule, MatLabel, MatInputModule, FormsModule, ReactiveFormsModule, NgIf, MatError, AddressComponent, MatDatepickerInput, MatDatepickerToggle, MatSuffix, MatDatepicker, MatCheckbox, MatButtonModule, MatCardImage, MatCardContent]
})
export class RecycleComponent implements OnInit {
  @ViewChild('addressComp', { static: true }) public addressComponent: AddressComponent
  public requestorControl: UntypedFormControl = new UntypedFormControl({ value: '', disabled: true }, [])
  public recycleQuantityControl: UntypedFormControl = new UntypedFormControl('', [Validators.required, Validators.min(10), Validators.max(1000)])
  public pickUpDateControl: UntypedFormControl = new UntypedFormControl()
  public pickup: UntypedFormControl = new UntypedFormControl(false)
  public topImage?: string
  public bottomImage?: string
  public recycles: any
  public recycle: any = {}
  public userEmail: any
  public confirmation: any
  public addressId: any = undefined
  constructor (private readonly recycleService: RecycleService, private readonly userService: UserService,
    private readonly configurationService: ConfigurationService, private readonly formSubmitService: FormSubmitService,
    private readonly translate: TranslateService, private readonly snackBarHelperService: SnackBarHelperService) { }

  ngOnInit (): void {
    this.configurationService.getApplicationConfiguration().subscribe((config: any) => {
      if (config?.application?.recyclePage) {
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        this.topImage = `assets/public/images/products/${config.application.recyclePage.topProductImage}`
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        this.bottomImage = `assets/public/images/products/${config.application.recyclePage.bottomProductImage}`
      }
    }, (err) => { console.log(err) })

    this.initRecycle()
    this.findAll()

    this.formSubmitService.attachEnterKeyHandler('recycle-form', 'recycleButton', () => { this.save() })
  }

  initRecycle () {
    this.userService.whoAmI().subscribe((data) => {
      this.recycle = {}
      this.recycle.UserId = data.id
      this.userEmail = data.email
      this.requestorControl.setValue(this.userEmail)
    }, (err) => { console.log(err) })
  }

  save () {
    this.recycle.AddressId = this.addressId
    this.recycle.quantity = this.recycleQuantityControl.value
    if (this.pickup.value) {
      this.recycle.isPickUp = this.pickup.value
      this.recycle.date = this.pickUpDateControl.value
    }

    this.recycleService.save(this.recycle).subscribe((savedRecycle: any) => {
      if (savedRecycle.isPickup) {
        this.translate.get('CONFIRM_RECYCLING_PICKUP', { pickupdate: savedRecycle.pickupDate }).subscribe((confirmRecyclingPickup) => {
          this.snackBarHelperService.open(confirmRecyclingPickup, 'confirmBar')
        }, (translationId) => {
          this.snackBarHelperService.open(translationId, 'confirmBar')
        })
      } else {
        this.translate.get('CONFIRM_RECYCLING_BOX').subscribe((confirmRecyclingBox) => {
          this.snackBarHelperService.open(confirmRecyclingBox, 'confirmBar')
        }, (translationId) => {
          this.snackBarHelperService.open(translationId, 'confirmBar')
        })
      }
      this.addressComponent.load()
      this.initRecycle()
      this.resetForm()
    }, (err) => {
      this.snackBarHelperService.open(err.error?.error, 'errorBar')
      console.log(err)
    })
  }

  findAll () {
    this.recycleService.find().subscribe((recycles) => {
      this.recycles = recycles
    }, (error) => {
      console.log(error)
    })
  }

  resetForm () {
    this.addressId = undefined
    this.recycleQuantityControl.setValue('')
    this.recycleQuantityControl.markAsPristine()
    this.recycleQuantityControl.markAsUntouched()
    this.pickUpDateControl.setValue('')
    this.pickUpDateControl.markAsPristine()
    this.pickUpDateControl.markAsUntouched()
    this.pickup.setValue(false)
  }

  getMessage (id) {
    this.addressId = id
  }
}


/* ===== FILE: ./frontend/src/app/recycle/recycle.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<mat-card class="mat-elevation-z6 mat-own-card" fxLayout="row"  fxLayout.lt-md="column"
          fxLayoutGap.lt-md="20px">
          <!-- left -->
  <div fxLayout="column" fxLayoutGap="20px" class="left-container" fxFlex="50%">
    <h1>{{"TITLE_RECYCLE" | translate}}</h1>

      <div class="form-container" id="recycle-form">
        <mat-form-field appearance="outline" color="accent">
          <mat-label>{{"LABEL_REQUESTOR" | translate}}</mat-label>
          <input [formControl]="requestorControl" type="text" matInput>
        </mat-form-field>

        <mat-form-field appearance="outline" color="accent">
          <mat-label>{{"LABEL_QUANTITY" | translate}}</mat-label>
          <input [formControl]="recycleQuantityControl" type="number" [placeholder]="'IN_LITERS_PLACEHOLDER' | translate"
                 matInput>
          <mat-error *ngIf="recycleQuantityControl.invalid && recycleQuantityControl.errors.required" translate>
            {{"MANDATORY_QUANTITY" | translate}}
          </mat-error>
          <mat-error *ngIf="recycleQuantityControl.invalid && (recycleQuantityControl.errors.min || recycleQuantityControl.errors.max)">
            {{"INVALID_QUANTITY" | translate: {range: '10-1000'} }}
          </mat-error>
        </mat-form-field>

        <app-address (emitSelection)="getMessage($event)" [addNewAddressDiv]="false" #addressComp
                    class="mat-elevation-z0"></app-address>

      <mat-form-field *ngIf="pickup.value && recycleQuantityControl.value > 100" appearance="outline">
        <mat-label>{{"LABEL_PICKUP_DATE" | translate}}</mat-label>
        <input [formControl]="pickUpDateControl" matInput [matDatepicker]="picker">
        <mat-datepicker-toggle matSuffix [for]="picker"></mat-datepicker-toggle>
        <mat-datepicker #picker></mat-datepicker>
        <mat-error *ngIf="pickUpDateControl.invalid">{{"INVALID_DATE" | translate }}</mat-error>
      </mat-form-field>

        <mat-checkbox [formControl]="pickup" *ngIf="recycleQuantityControl.value > 100">{{'REQUEST_PICKUP' | translate}}
        </mat-checkbox>

      </div>

      <button type="submit" id="recycleButton"
              [disabled]="addressId === undefined || recycleQuantityControl.invalid || pickUpDateControl.invalid"
              mat-raised-button color="primary" (click)="save()"><i class="fas fa-paper-plane fa-lg"></i> {{'BTN_SUBMIT' |
        translate}}
      </button>

    </div>
    <!-- right -->
    <div fxFlex="50%" fxLayout="column" fxLayoutGap="20px" > 
      <div fxLayout="column" fxLayoutGap="20px" fxLayoutAlign="center">

      <h3 class="responsibility-header">{{"SECTION_PRESS_JUICE_RESPONSIBLY" | translate}}</h3>
      <mat-card fxLayout="row" fxLayoutGap="20px" class="mat-elevation-z0">
        <img mat-card-image [src]="topImage">
        <mat-card-content>
          <div>
            <small>Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut
              labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea
              rebum.
            </small>
          </div>
        </mat-card-content>
      </mat-card>

      <mat-card fxLayout="row" fxLayoutGap="20px" class="mat-elevation-z0">
        <img mat-card-image [src]="bottomImage">
        <mat-card-content>
          <div>
            <small>Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor
              sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna
              aliquyam erat, sed diam voluptua.
            </small>
          </div>
        </mat-card-content>
      </mat-card>

      <span class="fill-remaining-space"></span>

    </div>
 </div>
</mat-card>


/* ===== FILE: ./frontend/src/app/recycle/recycle.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateModule, TranslateService } from '@ngx-translate/core'
import { MatDatepickerModule } from '@angular/material/datepicker'
import { ConfigurationService } from '../Services/configuration.service'
import { UserService } from '../Services/user.service'
import { RecycleService } from '../Services/recycle.service'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { MatCardModule } from '@angular/material/card'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'
import { MatButtonModule } from '@angular/material/button'
import { MatInputModule } from '@angular/material/input'
import { type ComponentFixture, fakeAsync, TestBed, waitForAsync } from '@angular/core/testing'

import { RecycleComponent } from './recycle.component'
import { MatFormFieldModule } from '@angular/material/form-field'
import { ReactiveFormsModule } from '@angular/forms'
import { MatCheckboxModule } from '@angular/material/checkbox'
import { MatNativeDateModule } from '@angular/material/core'
import { of, throwError } from 'rxjs'
import { AddressComponent } from '../address/address.component'
import { RouterTestingModule } from '@angular/router/testing'
import { EventEmitter } from '@angular/core'
import { MatIconModule } from '@angular/material/icon'
import { MatTableModule } from '@angular/material/table'
import { MatToolbarModule } from '@angular/material/toolbar'
import { MatRadioModule } from '@angular/material/radio'
import { MatTooltipModule } from '@angular/material/tooltip'
import { MatDialogModule } from '@angular/material/dialog'
import { MatDividerModule } from '@angular/material/divider'
import { MatSnackBar } from '@angular/material/snack-bar'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('RecycleComponent', () => {
  let component: RecycleComponent
  let fixture: ComponentFixture<RecycleComponent>
  let recycleService: any
  let userService: any
  let configurationService: any
  let translateService
  let snackBar: any

  beforeEach(waitForAsync(() => {
    recycleService = jasmine.createSpyObj('RecycleService', ['save', 'find'])
    recycleService.save.and.returnValue(of({}))
    recycleService.find.and.returnValue(of([{}]))
    userService = jasmine.createSpyObj('UserService', ['whoAmI'])
    userService.whoAmI.and.returnValue(of({}))
    configurationService = jasmine.createSpyObj('ConfigurationService', ['getApplicationConfiguration'])
    configurationService.getApplicationConfiguration.and.returnValue(of({}))
    translateService = jasmine.createSpyObj('TranslateService', ['get'])
    translateService.get.and.returnValue(of({}))
    translateService.onLangChange = new EventEmitter()
    translateService.onTranslationChange = new EventEmitter()
    translateService.onDefaultLangChange = new EventEmitter()
    snackBar = jasmine.createSpyObj('MatSnackBar', ['open'])

    TestBed.configureTestingModule({
      imports: [RouterTestingModule,
        TranslateModule.forRoot(),
        BrowserAnimationsModule,
        ReactiveFormsModule,
        MatFormFieldModule,
        MatInputModule,
        MatButtonModule,
        MatCardModule,
        MatCheckboxModule,
        MatDatepickerModule,
        MatNativeDateModule,
        MatIconModule,
        MatToolbarModule,
        MatTableModule,
        MatRadioModule,
        MatTooltipModule,
        MatDialogModule,
        MatDividerModule,
        RecycleComponent, AddressComponent],
      providers: [
        { provide: RecycleService, useValue: recycleService },
        { provide: UserService, useValue: userService },
        { provide: ConfigurationService, useValue: configurationService },
        { provide: TranslateService, useValue: translateService },
        { provide: MatSnackBar, useValue: snackBar },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(RecycleComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should reset the form by calling resetForm', () => {
    component.addressId = '1'
    component.recycleQuantityControl.setValue('100')
    component.pickUpDateControl.setValue('10/7/2018')
    component.pickup.setValue(true)
    component.resetForm()
    expect(component.addressId).toBeUndefined()
    expect(component.recycleQuantityControl.value).toBe('')
    expect(component.recycleQuantityControl.untouched).toBe(true)
    expect(component.recycleQuantityControl.pristine).toBe(true)
    expect(component.pickUpDateControl.value).toBe('')
    expect(component.pickUpDateControl.untouched).toBe(true)
    expect(component.pickUpDateControl.pristine).toBe(true)
    expect(component.pickup.value).toBe(false)
  })

  it('should hold the user id of the currently logged in user', () => {
    userService.whoAmI.and.returnValue(of({ id: 42 }))
    component.ngOnInit()
    expect(component.recycle.UserId).toBe(42)
  })

  it('should hold no email if current user is not logged in', () => {
    userService.whoAmI.and.returnValue(of({}))
    component.ngOnInit()
    expect(component.userEmail).toBeUndefined()
  })

  it('should hold the user email of the currently logged in user', () => {
    userService.whoAmI.and.returnValue(of({ email: 'x@x.xx' }))
    component.ngOnInit()
    expect(component.userEmail).toBe('x@x.xx')
  })

  it('should display pickup message and reset recycle form on saving', () => {
    recycleService.save.and.returnValue(of({}))
    userService.whoAmI.and.returnValue(of({}))
    translateService.get.and.returnValue(of('CONFIRM_RECYCLING_BOX'))
    spyOn(component, 'initRecycle')
    spyOn(component.addressComponent, 'load')
    component.addressId = '1'
    component.recycleQuantityControl.setValue(100)
    component.pickup.setValue(false)
    const recycle = { UserId: undefined, AddressId: '1', quantity: 100 }
    component.save()
    expect(recycleService.save.calls.count()).toBe(1)
    expect(recycleService.save.calls.argsFor(0)[0]).toEqual(recycle)
    expect(component.initRecycle).toHaveBeenCalled()
    expect(component.addressComponent.load).toHaveBeenCalled()
    expect(translateService.get).toHaveBeenCalledWith('CONFIRM_RECYCLING_BOX')
  })

  it('should display pickup message and reset recycle form on saving when pickup is selected', () => {
    recycleService.save.and.returnValue(of({ isPickup: true, pickupDate: '10/7/2018' }))
    userService.whoAmI.and.returnValue(of({}))
    translateService.get.and.returnValue(of('CONFIRM_RECYCLING_PICKUP'))
    spyOn(component, 'initRecycle')
    spyOn(component.addressComponent, 'load')
    component.addressId = '1'
    component.recycleQuantityControl.setValue(100)
    component.pickup.setValue(true)
    component.pickUpDateControl.setValue('10/7/2018')
    const recycle = { isPickUp: true, date: '10/7/2018', UserId: undefined, AddressId: '1', quantity: 100 }
    component.save()
    expect(recycleService.save.calls.count()).toBe(1)
    expect(recycleService.save.calls.argsFor(0)[0]).toEqual(recycle)
    expect(component.initRecycle).toHaveBeenCalled()
    expect(component.addressComponent.load).toHaveBeenCalled()
    expect(translateService.get).toHaveBeenCalledWith('CONFIRM_RECYCLING_PICKUP', { pickupdate: '10/7/2018' })
  })

  it('should hold existing recycles', () => {
    recycleService.find.and.returnValue(of([{ quantity: 1 }, { quantity: 2 }]))
    component.ngOnInit()
    expect(component.recycles.length).toBe(2)
    expect(component.recycles[0].quantity).toBe(1)
    expect(component.recycles[1].quantity).toBe(2)
  })

  it('should hold nothing when no recycles exists', () => {
    recycleService.find.and.returnValue(of([]))
    component.ngOnInit()
    expect(component.recycles.length).toBe(0)
  })

  it('should hold nothing on error from backend API', () => {
    recycleService.find.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.ngOnInit()
    expect(console.log).toHaveBeenCalledWith('Error')
  })

  it('should log the error on retrieving the user', fakeAsync(() => {
    userService.whoAmI.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.ngOnInit()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should use a configured product image on top of page', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { recyclePage: { topProductImage: 'top.png' } } }))
    component.ngOnInit()
    expect(component.topImage).toEqual('assets/public/images/products/top.png')
  })

  it('should use a configured product image on bottom of page', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { recyclePage: { topProductImage: 'bottom.png' } } }))
    component.ngOnInit()
    expect(component.topImage).toEqual('assets/public/images/products/bottom.png')
  })

  it('should show broken top and bottom image on error retrieving configuration', fakeAsync(() => {
    configurationService.getApplicationConfiguration.and.returnValue(throwError('Error'))
    component.ngOnInit()
    expect(component.topImage).toBeUndefined()
    expect(component.bottomImage).toBeUndefined()
  }))
})


/* ===== FILE: ./frontend/src/app/feedback-details/feedback-details.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Component, type OnInit, Inject } from '@angular/core'
import { MAT_DIALOG_DATA, MatDialogContent, MatDialogActions, MatDialogClose } from '@angular/material/dialog'
import { TranslateModule } from '@ngx-translate/core'
import { MatButtonModule } from '@angular/material/button'
import { FlexModule } from '@angular/flex-layout/flex'
import { MatDivider } from '@angular/material/divider'
import { MatIconModule } from '@angular/material/icon'

@Component({
  selector: 'app-feedback-details',
  templateUrl: './feedback-details.component.html',
  styleUrls: ['./feedback-details.component.scss'],
  imports: [MatDialogContent, MatDivider, FlexModule, MatDialogActions, MatButtonModule, MatDialogClose, TranslateModule, MatIconModule]
})
export class FeedbackDetailsComponent implements OnInit {
  public feedback: any
  public id: any
  constructor (@Inject(MAT_DIALOG_DATA) public dialogData: any) { }

  ngOnInit (): void {
    this.feedback = this.dialogData.feedback
    this.id = this.dialogData.id
  }
}


/* ===== FILE: ./frontend/src/app/feedback-details/feedback-details.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateModule } from '@ngx-translate/core'
import { MAT_DIALOG_DATA, MatDialogModule, MatDialogRef } from '@angular/material/dialog'
import { UserService } from '../Services/user.service'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { MatDividerModule } from '@angular/material/divider'
import { type ComponentFixture, TestBed, waitForAsync } from '@angular/core/testing'

import { FeedbackDetailsComponent } from './feedback-details.component'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('FeedbackDetailsComponent', () => {
  let component: FeedbackDetailsComponent
  let fixture: ComponentFixture<FeedbackDetailsComponent>

  beforeEach(waitForAsync(() => {
    TestBed.configureTestingModule({
      imports: [TranslateModule.forRoot(),
        MatDividerModule,
        MatDialogModule,
        FeedbackDetailsComponent],
      providers: [
        UserService,
        { provide: MatDialogRef, useValue: {} },
        { provide: MAT_DIALOG_DATA, useValue: { productData: {} } },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(FeedbackDetailsComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })
})


/* ===== FILE: ./frontend/src/app/feedback-details/feedback-details.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<mat-dialog-content>
  <header>
    <h1>{{"LABEL_COMMENT" | translate}}</h1>
  </header>
  <mat-divider></mat-divider>
  <div class="container" fxLayout="column">

      <div fxLayout="row" fxLayoutGap="10px">
        <span>{{"LABEL_USER" | translate}}:</span>
        <p>#{{id}}</p>
      </div>

      <div style="margin-top: 10px !important;">
        <cite [innerHTML]="feedback"></cite>
      </div>
  </div>
  <mat-dialog-actions align="end" class="dialogAction">
    <button mat-button style="height: 0; position: absolute;">
      <!-- 'absorbs' the auto-focus behavior -->
    </button>
    <button mat-stroked-button mat-dialog-close class="close-dialog buttons" aria-label="Close Dialog">
      <mat-icon>close</mat-icon>
      <span>{{'BTN_CLOSE' | translate}}</span>
    </button>
  </mat-dialog-actions>
</mat-dialog-content>


/* ===== FILE: ./frontend/src/app/app.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { ClipboardModule } from 'ngx-clipboard'
import { ServerStartedNotificationComponent } from './server-started-notification/server-started-notification.component'
import { TranslateModule, TranslateService } from '@ngx-translate/core'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { RouterTestingModule } from '@angular/router/testing'
import { TestBed, waitForAsync } from '@angular/core/testing'
import { AppComponent } from './app.component'
import { NavbarComponent } from './navbar/navbar.component'
import { SidenavComponent } from './sidenav/sidenav.component'
import { WelcomeComponent } from './welcome/welcome.component'
import { ChallengeSolvedNotificationComponent } from './challenge-solved-notification/challenge-solved-notification.component'

import { MatSelectModule } from '@angular/material/select'
import { MatFormFieldModule } from '@angular/material/form-field'
import { MatToolbarModule } from '@angular/material/toolbar'
import { MatIconModule } from '@angular/material/icon'
import { MatButtonModule } from '@angular/material/button'
import { MatSidenavModule } from '@angular/material/sidenav'
import { MatMenuModule } from '@angular/material/menu'
import { MatTooltipModule } from '@angular/material/tooltip'
import { MatListModule } from '@angular/material/list'
import { MatCardModule } from '@angular/material/card'
import { NoopAnimationsModule } from '@angular/platform-browser/animations'
import { MatRadioModule } from '@angular/material/radio'
import { MatDividerModule } from '@angular/material/divider'
import { MatDialogModule } from '@angular/material/dialog'
import { LoginGuard } from './app.guard'
import { MatInputModule } from '@angular/material/input'
import { MatSnackBarModule } from '@angular/material/snack-bar'
import { MatSearchBarComponent } from './mat-search-bar/mat-search-bar.component'
import { CookieModule } from 'ngy-cookie'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('AppComponent', () => {
  let app: AppComponent

  beforeEach(waitForAsync(() => {
    TestBed.configureTestingModule({
      imports: [RouterTestingModule,
        MatToolbarModule,
        CookieModule.forRoot(),
        TranslateModule.forRoot(),
        ClipboardModule,
        MatIconModule,
        MatCardModule,
        MatFormFieldModule,
        MatSelectModule,
        MatInputModule,
        MatButtonModule,
        MatSidenavModule,
        MatMenuModule,
        MatTooltipModule,
        NoopAnimationsModule,
        MatSnackBarModule,
        MatRadioModule,
        MatDividerModule,
        MatListModule,
        MatDialogModule,
        NavbarComponent,
        WelcomeComponent,
        SidenavComponent,
        ChallengeSolvedNotificationComponent,
        ServerStartedNotificationComponent,
        MatSearchBarComponent,
        AppComponent],
      providers: [TranslateService, LoginGuard, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    }).compileComponents()
  }))

  beforeEach(() => {
    const fixture = TestBed.createComponent(AppComponent)
    app = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create the app', waitForAsync(() => {
    expect(app).toBeTruthy()
  }))
})


/* ===== FILE: ./frontend/src/app/two-factor-auth/two-factor-auth.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type ComponentFixture, TestBed, waitForAsync } from '@angular/core/testing'
import { TwoFactorAuthComponent } from './two-factor-auth.component'

import { ReactiveFormsModule } from '@angular/forms'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'

import { TranslateModule } from '@ngx-translate/core'

import { MatCardModule } from '@angular/material/card'
import { MatFormFieldModule } from '@angular/material/form-field'
import { MatButtonModule } from '@angular/material/button'
import { MatInputModule } from '@angular/material/input'
import { MatCheckboxModule } from '@angular/material/checkbox'
import { MatIconModule } from '@angular/material/icon'
import { MatTableModule } from '@angular/material/table'
import { MatPaginatorModule } from '@angular/material/paginator'
import { MatDialogModule } from '@angular/material/dialog'
import { MatDividerModule } from '@angular/material/divider'
import { MatSnackBarModule } from '@angular/material/snack-bar'
import { MatTooltipModule } from '@angular/material/tooltip'

import { of } from 'rxjs'
import { ConfigurationService } from '../Services/configuration.service'
import { TwoFactorAuthService } from '../Services/two-factor-auth-service'
import { throwError } from 'rxjs/internal/observable/throwError'
import { QrCodeModule } from 'ng-qrcode'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('TwoFactorAuthComponent', () => {
  let component: TwoFactorAuthComponent
  let fixture: ComponentFixture<TwoFactorAuthComponent>
  let twoFactorAuthService: any
  let configurationService: any

  beforeEach(waitForAsync(() => {
    twoFactorAuthService = jasmine.createSpyObj('TwoFactorAuthService', ['status', 'setup', 'disable'])
    configurationService = jasmine.createSpyObj('ConfigurationService', ['getApplicationConfiguration'])
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { } }))
    TestBed.configureTestingModule({
      imports: [ReactiveFormsModule,
        TranslateModule.forRoot(),
        BrowserAnimationsModule,
        MatCheckboxModule,
        MatFormFieldModule,
        MatCardModule,
        MatIconModule,
        MatInputModule,
        MatTableModule,
        MatPaginatorModule,
        MatDialogModule,
        MatDividerModule,
        MatButtonModule,
        QrCodeModule,
        MatSnackBarModule,
        MatTooltipModule,
        TwoFactorAuthComponent],
      providers: [
        { provide: ConfigurationService, useValue: configurationService },
        { provide: TwoFactorAuthService, useValue: twoFactorAuthService },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    }).compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(TwoFactorAuthComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should compile', () => {
    expect(component).toBeTruthy()
  })

  it('should set TOTP secret and URL if 2FA is not already set up', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { name: 'Test App' } }))
    twoFactorAuthService.status.and.returnValue(of({ setup: false, email: 'email', secret: 'secret', setupToken: '12345' }))

    component.updateStatus()

    expect(component.setupStatus).toBe(false)
    expect(component.totpUrl).toBe('otpauth://totp/Test%20App:email?secret=secret&issuer=Test%20App')
    expect(component.totpSecret).toBe('secret')
  })

  it('should not set TOTP secret and URL if 2FA is already set up', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { name: 'Test App' } }))
    twoFactorAuthService.status.and.returnValue(of({ setup: true, email: 'email', secret: 'secret', setupToken: '12345' }))

    component.updateStatus()

    expect(component.setupStatus).toBe(true)
    expect(component.totpUrl).toBe(undefined)
    expect(component.totpSecret).toBe(undefined)
  })

  it('should confirm successful setup of 2FA', () => {
    twoFactorAuthService.setup.and.returnValue(of({}))
    component.setupStatus = false
    component.twoFactorSetupForm.get('passwordControl').setValue('password')
    component.twoFactorSetupForm.get('initialTokenControl').setValue('12345')

    component.setup()

    expect(component.setupStatus).toBe(true)
    expect(twoFactorAuthService.setup).toHaveBeenCalledWith('password', '12345', undefined)
  })

  it('should reset and mark form as errored when 2FA setup fails', () => {
    twoFactorAuthService.setup.and.returnValue(throwError(new Error('Error')))
    component.setupStatus = false
    component.errored = false
    component.twoFactorSetupForm.get('passwordControl').markAsDirty()
    component.twoFactorSetupForm.get('initialTokenControl').markAsDirty()

    expect(component.twoFactorSetupForm.get('passwordControl').pristine).toBe(false)
    expect(component.twoFactorSetupForm.get('initialTokenControl').pristine).toBe(false)
    component.setup()

    expect(component.setupStatus).toBe(false)
    expect(component.errored).toBe(true)
    expect(component.twoFactorSetupForm.get('passwordControl').pristine).toBe(true)
    expect(component.twoFactorSetupForm.get('initialTokenControl').pristine).toBe(true)
  })

  it('should confirm successfully disabling 2FA', () => {
    twoFactorAuthService.status.and.returnValue(of({ setup: true, email: 'email', secret: 'secret', setupToken: '12345' }))
    twoFactorAuthService.disable.and.returnValue(of({}))
    component.setupStatus = true
    component.twoFactorDisableForm.get('passwordControl').setValue('password')

    component.disable()

    expect(component.setupStatus).toBe(false)
    expect(twoFactorAuthService.disable).toHaveBeenCalledWith('password')
  })

  it('should reset and mark form as errored when disabling 2FA fails', () => {
    twoFactorAuthService.disable.and.returnValue(throwError(new Error('Error')))
    component.setupStatus = true
    component.errored = false
    component.twoFactorDisableForm.get('passwordControl').markAsDirty()

    expect(component.twoFactorDisableForm.get('passwordControl').pristine).toBe(false)
    component.disable()

    expect(component.setupStatus).toBe(true)
    expect(component.errored).toBe(true)
    expect(component.twoFactorDisableForm.get('passwordControl').pristine).toBe(true)
  })
})


/* ===== FILE: ./frontend/src/app/two-factor-auth/two-factor-auth.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Component } from '@angular/core'
import { UntypedFormControl, UntypedFormGroup, Validators, FormsModule, ReactiveFormsModule } from '@angular/forms'

import { TwoFactorAuthService } from '../Services/two-factor-auth-service'
import { ConfigurationService } from '../Services/configuration.service'

import { library } from '@fortawesome/fontawesome-svg-core'
import { faSave, faUnlockAlt } from '@fortawesome/free-solid-svg-icons'

import { forkJoin } from 'rxjs'
import { TranslateService, TranslateModule } from '@ngx-translate/core'
import { MatSnackBar } from '@angular/material/snack-bar'
import { SnackBarHelperService } from '../Services/snack-bar-helper.service'
import { MatTooltip } from '@angular/material/tooltip'
import { MatIconModule } from '@angular/material/icon'
import { QrCodeModule } from 'ng-qrcode'
import { MatButtonModule } from '@angular/material/button'
import { MatInputModule } from '@angular/material/input'
import { MatFormFieldModule, MatLabel, MatError, MatSuffix, MatHint } from '@angular/material/form-field'
import { NgIf } from '@angular/common'
import { MatCardModule } from '@angular/material/card'
import { FlexModule } from '@angular/flex-layout/flex'

library.add(faUnlockAlt, faSave)

@Component({
  selector: 'app-two-factor-auth',
  templateUrl: './two-factor-auth.component.html',
  styleUrls: ['./two-factor-auth.component.scss'],
  imports: [FlexModule, MatCardModule, TranslateModule, NgIf, FormsModule, ReactiveFormsModule, MatFormFieldModule, MatLabel, MatInputModule, MatButtonModule, QrCodeModule, MatError, MatIconModule, MatSuffix, MatTooltip, MatHint, MatIconModule]
})
export class TwoFactorAuthComponent {
  public data?: string

  public twoFactorSetupForm: UntypedFormGroup = new UntypedFormGroup({
    passwordControl: new UntypedFormControl('', [Validators.required]),
    initialTokenControl: new UntypedFormControl('', [Validators.required, Validators.pattern('^[\\d]{6}$')])
  })

  public twoFactorDisableForm: UntypedFormGroup = new UntypedFormGroup({
    passwordControl: new UntypedFormControl('', [Validators.required])
  })

  public setupStatus: boolean | null = null
  public errored: boolean | null = null

  public totpUrl?: string
  public totpSecret?: string
  private setupToken?: string

  private appName = 'OWASP Juice Shop'

  constructor (private readonly twoFactorAuthService: TwoFactorAuthService, private readonly configurationService: ConfigurationService, private readonly snackBar: MatSnackBar, private readonly translateService: TranslateService, private readonly snackBarHelperService: SnackBarHelperService) {}

  ngOnInit (): void {
    this.updateStatus()
  }

  updateStatus () {
    const status = this.twoFactorAuthService.status()
    const config = this.configurationService.getApplicationConfiguration()

    forkJoin([status, config]).subscribe(([{ setup, email, secret, setupToken }, config]) => {
      this.setupStatus = setup
      this.appName = config.application.name
      if (!setup) {
        const encodedAppName = encodeURIComponent(this.appName)
        this.totpUrl = `otpauth://totp/${encodedAppName}:${email}?secret=${secret}&issuer=${encodedAppName}`
        this.totpSecret = secret
        this.setupToken = setupToken
      }
    }, () => {
      console.log('Failed to fetch 2fa status')
    })
    return status
  }

  setup () {
    this.twoFactorAuthService.setup(
      this.twoFactorSetupForm.get('passwordControl')?.value,
      this.twoFactorSetupForm.get('initialTokenControl')?.value,
      this.setupToken
    ).subscribe(() => {
      this.setupStatus = true
      this.snackBarHelperService.open('CONFIRM_2FA_SETUP')
    }, () => {
      this.twoFactorSetupForm.get('passwordControl')?.markAsPristine()
      this.twoFactorSetupForm.get('initialTokenControl')?.markAsPristine()
      this.errored = true
    })
  }

  disable () {
    this.twoFactorAuthService.disable(
      this.twoFactorDisableForm.get('passwordControl')?.value
    ).subscribe(() => {
      this.updateStatus().subscribe(
        () => {
          this.setupStatus = false
        }
      )
      this.snackBarHelperService.open('CONFIRM_2FA_DISABLE')
    }, () => {
      this.twoFactorDisableForm.get('passwordControl')?.markAsPristine()
      this.errored = true
    })
  }
}


/* ===== FILE: ./frontend/src/app/two-factor-auth/two-factor-auth.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<div fxLayoutAlign="center">
  <mat-card appearance="outlined" class="mat-elevation-z6">
    <div class="mdc-card">

      <h1 id="2fa-setup-title" translate>TITLE_TWO_FACTOR_AUTH_CONFIG</h1>

      <div id="2fa-setup-successfully" *ngIf="setupStatus === true">
        <p translate>2FA_SUCCESSFUL_SETUP</p>

        <form
          class="form-container"
          id="two-factor-auth-disable"
          [formGroup]="twoFactorDisableForm"
          (ngSubmit)="disable()"
        >

          <h2 id="two-factor-auth-disable-title" translate>REMOVE_TWO_FACTOR_AUTH</h2>

          <div class="error" [hidden]="!(errored && !twoFactorDisableForm.dirty)" translate>2FA_SETUP_ERROR</div>

          <mat-form-field appearance="outline" color="accent">
            <mat-label translate>LABEL_CURRENT_PASSWORD</mat-label>
            <input id="currentPasswordDisable" formControlName="passwordControl" type="password" matInput
                  aria-label="Field to enter the current password"
                  placeholder="{{'MANDATORY_CURRENT_PASSWORD' | translate }}"
                  autocomplete="off">
          </mat-form-field>

          <button
            type="submit"
            id="disableTwoFactorAuth"
            [disabled]="twoFactorDisableForm.invalid"
            mat-raised-button
            color="warn"
            aria-label="Button to remove the two-factor authentication"
          >
            <mat-icon>remove_selection</mat-icon>
            {{'BTN_REMOVE' | translate}}
          </button>
        </form>
      </div>

      <form
        *ngIf="setupStatus === false"
        class="form-container"
        id="two-factor-auth-setup"
        [formGroup]="twoFactorSetupForm"
        (ngSubmit)="setup()"
      >

        <span id="2fa-setup-instructions" translate>2FA_AUTH_SETUP_INSTRUCTIONS</span>

        <div fxLayoutAlign="center" class="two-factor-qr-code">
          <qr-code
            [value]="totpUrl"
            [size]="300"
            [errorCorrectionLevel]="'L'"
          ></qr-code>
        </div>

        <div class="error" [hidden]="!(errored && !twoFactorSetupForm.dirty)" translate>2FA_SETUP_ERROR</div>

        <mat-form-field appearance="outline" color="accent">
          <mat-label translate>LABEL_CURRENT_PASSWORD</mat-label>
          <input id="currentPasswordSetup" formControlName="passwordControl" type="password" matInput
                aria-label="Field to enter the current password"
                placeholder="{{'MANDATORY_CURRENT_PASSWORD' | translate }}"
                autocomplete="off">
        </mat-form-field>

        <mat-form-field appearance="outline" color="accent">
          <mat-label translate>INITIAL_CODE</mat-label>
          <input
            #initToken
            id="initialToken"
            formControlName="initialTokenControl"
            type="text"
            matInput
            [attr.data-test-totp-secret]="totpSecret"
            aria-label="Field to enter the initial token. This must have 6 digits."
            placeholder="{{'INITIAL_CODE_PLACEHOLDER' | translate }}"
            minlength="6" maxlength="6" pattern="^[\d]{6}$"
          >
          <mat-error translate>INVALID_TWO_FACTOR_AUTH_TOKEN</mat-error>
          <mat-icon matSuffix matTooltip="{{ 'INITIAL_TOKEN_TOOLTIP' | translate}}"
                    matTooltipPosition=right
                    aria-label="The token to be entered from the authenticator must have 6 digits.">
            help_outline
          </mat-icon>
          <mat-hint align="end">{{initToken.value?.length || 0}}/6</mat-hint>
        </mat-form-field>

        <button
          type="submit"
          id="setupTwoFactorAuth"
          [disabled]="twoFactorSetupForm.invalid"
          mat-raised-button
          color="primary"
          aria-label="Button to complete the two-factor configuration"
        >
          <mat-icon>save</mat-icon>
          {{'BTN_SAVE' | translate}}
        </button>
      </form>
    </div>
  </mat-card>
</div>


/* ===== FILE: ./frontend/src/app/deluxe-user/deluxe-user.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
-->

<div *ngIf="error" class="heading mat-elevation-z6">
  <span class="error">{{error}}</span>
</div>

<mat-card appearance="outlined" class="mat-elevation-z6 deluxe-membership">
  <svg preserveAspectRatio="xMidYMid meet" viewBox="0 0 720 720" xmlns="http://www.w3.org/2000/svg">
    <image href="assets/public/images/deluxe/blankBoxes.png" x="0" y="0" height="720" width="720" />
    <image [attr.href]="logoSrc" x="260" y="130" height="50" />
    <image [attr.href]="logoSrc" x="230" y="330" height="70" />
    <image [attr.href]="logoSrc" x="70" y="355" height="40" />
    <image [attr.href]="logoSrc" x="120" y="450" height="55" />
    <image [attr.href]="logoSrc" x="500" y="410" height="45" />
  </svg>
  <div class="card-text">
    <strong class="item-name" translate="">LABEL_DELUXE_MEMBERSHIP</strong>
    <span translate [translateParams]="{appname: applicationName}">DESCRIPTION_DELUXE_MEMBERSHIP</span>
    @if (!error) {
      <span>
        {{ membershipCost }}&curren;
      </span>
      <button (click)="upgradeToDeluxe()" aria-label="Become deluxe member" class="btn-become-member" color="primary"
        mat-button mat-raised-button>
        <span translate>LABEL_BECOME_MEMBER</span>
      </button>
    }
  </div>
</mat-card>
<div class="feature-cards-container">
  @for (item of SHOWCASES; track item.name) {
    <mat-card appearance="outlined" class="mat-elevation-z6 feature-card">
      <mat-icon [fontIcon]="item.icon"></mat-icon>
      <div class="card-text">
        <strong class="item-name">{{ item.name | translate }}</strong>
        <span>{{ item.description | translate }}</span>
      </div>
    </mat-card>
  }
</div>

/* ===== FILE: ./frontend/src/app/deluxe-user/deluxe-user.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateModule } from '@ngx-translate/core'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { MatCardModule } from '@angular/material/card'
import { MatFormFieldModule } from '@angular/material/form-field'
import { type ComponentFixture, fakeAsync, TestBed, waitForAsync } from '@angular/core/testing'
import { MatInputModule } from '@angular/material/input'
import { ReactiveFormsModule } from '@angular/forms'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'

import { of } from 'rxjs'
import { RouterTestingModule } from '@angular/router/testing'
import { DeluxeUserComponent } from './deluxe-user.component'
import { UserService } from '../Services/user.service'
import { CookieService } from 'ngy-cookie'
import { LoginComponent } from '../login/login.component'
import { Location } from '@angular/common'
import { MatTableModule } from '@angular/material/table'
import { MatExpansionModule } from '@angular/material/expansion'
import { MatDividerModule } from '@angular/material/divider'
import { MatRadioModule } from '@angular/material/radio'
import { MatDialogModule } from '@angular/material/dialog'
import { MatIconModule } from '@angular/material/icon'
import { MatCheckboxModule } from '@angular/material/checkbox'
import { MatTooltipModule } from '@angular/material/tooltip'
import { ConfigurationService } from '../Services/configuration.service'
import { throwError } from 'rxjs/internal/observable/throwError'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('DeluxeUserComponent', () => {
  let component: DeluxeUserComponent
  let fixture: ComponentFixture<DeluxeUserComponent>
  let userService
  let cookieService: any
  let configurationService: any

  beforeEach(waitForAsync(() => {
    configurationService = jasmine.createSpyObj('ConfigurationService', ['getApplicationConfiguration'])
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { } }))
    userService = jasmine.createSpyObj('UserService', ['deluxeStatus', 'upgradeToDeluxe', 'saveLastLoginIp'])
    userService.deluxeStatus.and.returnValue(of({}))
    userService.upgradeToDeluxe.and.returnValue(of({}))
    userService.isLoggedIn = jasmine.createSpyObj('userService.isLoggedIn', ['next'])
    userService.isLoggedIn.next.and.returnValue({})
    userService.saveLastLoginIp.and.returnValue(of({}))
    cookieService = jasmine.createSpyObj('CookieService', ['remove'])

    TestBed.configureTestingModule({
      imports: [RouterTestingModule.withRoutes([
        { path: 'login', component: LoginComponent }
      ]),
      TranslateModule.forRoot(),
      ReactiveFormsModule,
      BrowserAnimationsModule,
      MatCardModule,
      MatTableModule,
      MatFormFieldModule,
      MatInputModule,
      MatExpansionModule,
      MatDividerModule,
      MatRadioModule,
      MatDialogModule,
      MatIconModule,
      MatCheckboxModule,
      MatTooltipModule,
      DeluxeUserComponent, LoginComponent],
      providers: [
        { provide: UserService, useValue: userService },
        { provide: ConfigurationService, useValue: configurationService },
        { provide: CookieService, useValue: cookieService },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
    TestBed.inject(Location)
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(DeluxeUserComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should hold membership cost on ngOnInit', () => {
    userService.deluxeStatus.and.returnValue(of({ membershipCost: 30 }))
    component.ngOnInit()
    expect(component.membershipCost).toEqual(30)
  })

  it('should set application name and logo as obtained from configuration', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { name: 'Name', logo: 'Logo' } }))
    component.ngOnInit()

    expect(component.applicationName).toBe('Name')
    expect(component.logoSrc).toBe('assets/public/images/Logo')
  })

  it('should assemble internal logo location from image base path and URL obtained from configuration', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { logo: 'http://test.com/logo.jpg' } }))
    component.ngOnInit()

    expect(component.logoSrc).toBe('assets/public/images/logo.jpg')
  })

  it('should log error on failure in retrieving configuration from backend', fakeAsync(() => {
    configurationService.getApplicationConfiguration.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.ngOnInit()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))
})


/* ===== FILE: ./frontend/src/app/deluxe-user/deluxe-user.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Component, NgZone, type OnInit } from '@angular/core'
import { UserService } from '../Services/user.service'
import { ActivatedRoute, Router } from '@angular/router'
import { ConfigurationService } from '../Services/configuration.service'
import { SocketIoService } from '../Services/socket-io.service'
import { MatIconModule } from '@angular/material/icon'
import { MatButtonModule } from '@angular/material/button'
import { TranslateModule } from '@ngx-translate/core'
import { MatCardModule } from '@angular/material/card'
import { NgIf } from '@angular/common'

@Component({
  selector: 'app-deluxe-user',
  templateUrl: './deluxe-user.component.html',
  styleUrls: ['./deluxe-user.component.scss'],
  imports: [NgIf, MatCardModule, TranslateModule, MatButtonModule, MatIconModule]
})

export class DeluxeUserComponent implements OnInit {
  public membershipCost: number = 0
  public error?: string = undefined
  public applicationName = 'OWASP Juice Shop'
  public logoSrc: string = 'assets/public/images/JuiceShop_Logo.png'

  public SHOWCASES = [
    {
      icon: 'slideshow',
      name: 'LABEL_DEALS_OFFERS',
      description: 'DESCRIPTION_DEALS_OFFERS'
    },
    {
      icon: 'directions_car',
      name: 'LABEL_FREE_FAST_DELIVERY',
      description: 'DESCRIPTION_FREE_FAST_DELIVERY'
    },
    {
      icon: 'add',
      name: 'LABEL_UNLIMITED_PURCHASE',
      description: 'DESCRIPTION_UNLIMITED_PURCHASE'
    }
  ] as const

  constructor (private readonly router: Router, private readonly userService: UserService, private readonly configurationService: ConfigurationService, private readonly route: ActivatedRoute, private readonly ngZone: NgZone, private readonly io: SocketIoService) {
  }

  ngOnInit (): void {
    this.configurationService.getApplicationConfiguration().subscribe((config) => {
      const decalParam: string = this.route.snapshot.queryParams.testDecal // "Forgotten" test parameter to play with different stickers on the delivery box image
      if (config?.application) {
        if (config.application.name) {
          this.applicationName = config.application.name
        }
        if (config.application.logo) {
          let logo: string = config.application.logo

          if (logo.substring(0, 4) === 'http') {
            logo = decodeURIComponent(logo.substring(logo.lastIndexOf('/') + 1))
          }
          this.logoSrc = `assets/public/images/${decalParam || logo}`
        }
      }
      if (decalParam) {
        this.ngZone.runOutsideAngular(() => {
          this.io.socket().emit('verifySvgInjectionChallenge', decalParam)
        })
      }
    }, (err) => { console.log(err) })
    this.userService.deluxeStatus().subscribe((res) => {
      this.membershipCost = res.membershipCost
    }, (err) => {
      this.error = err.error.error
    })
  }

  upgradeToDeluxe () {
    this.ngZone.run(async () => await this.router.navigate(['/payment', 'deluxe']))
  }
}


/* ===== FILE: ./frontend/src/app/user-details/user-details.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { UserService } from '../Services/user.service'
import { Component, Inject, type OnInit } from '@angular/core'
import { MAT_DIALOG_DATA, MatDialogContent, MatDialogActions, MatDialogClose } from '@angular/material/dialog'
import { library } from '@fortawesome/fontawesome-svg-core'
import { faArrowCircleLeft } from '@fortawesome/free-solid-svg-icons'
import { MatButtonModule } from '@angular/material/button'
import { TranslateModule } from '@ngx-translate/core'
import { FlexModule } from '@angular/flex-layout/flex'
import { MatDivider } from '@angular/material/divider'
import { MatIconModule } from '@angular/material/icon'

library.add(faArrowCircleLeft)

@Component({
  selector: 'app-user-details',
  templateUrl: './user-details.component.html',
  styleUrls: ['./user-details.component.scss'],
  imports: [MatDialogContent, MatDivider, FlexModule, TranslateModule, MatDialogActions, MatButtonModule, MatDialogClose, MatIconModule]
})
export class UserDetailsComponent implements OnInit {
  public user: any
  constructor (@Inject(MAT_DIALOG_DATA) public dialogData: any, private readonly userService: UserService) { }

  ngOnInit (): void {
    this.userService.get(this.dialogData.id).subscribe((user) => {
      this.user = user
    }, (err) => { console.log(err) })
  }
}


/* ===== FILE: ./frontend/src/app/user-details/user-details.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateModule } from '@ngx-translate/core'
import { MAT_DIALOG_DATA, MatDialogModule, MatDialogRef } from '@angular/material/dialog'
import { UserService } from '../Services/user.service'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { MatDividerModule } from '@angular/material/divider'
import { type ComponentFixture, TestBed, waitForAsync } from '@angular/core/testing'

import { UserDetailsComponent } from './user-details.component'
import { of, throwError } from 'rxjs'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('UserDetailsComponent', () => {
  let component: UserDetailsComponent
  let fixture: ComponentFixture<UserDetailsComponent>
  let userService: any

  beforeEach(waitForAsync(() => {
    userService = jasmine.createSpyObj('UserService', ['get'])
    userService.get.and.returnValue(of({}))

    TestBed.configureTestingModule({
      imports: [TranslateModule.forRoot(),
        MatDividerModule,
        MatDialogModule,
        UserDetailsComponent],
      providers: [
        { provide: UserService, useValue: userService },
        { provide: MatDialogRef, useValue: {} },
        { provide: MAT_DIALOG_DATA, useValue: { dialogData: {} } },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(UserDetailsComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should log the error on retrieving user', () => {
    userService.get.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.ngOnInit()
    expect(console.log).toHaveBeenCalledWith('Error')
  })

  it('should set the retrieved user', () => {
    userService.get.and.returnValue(of('User'))
    component.ngOnInit()
    expect(component.user).toBe('User')
  })
})


/* ===== FILE: ./frontend/src/app/user-details/user-details.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<mat-dialog-content>
  <header>
    <h1>{{"LABEL_USER" | translate}} #{{user?.id}}</h1>
  </header>
  <mat-divider></mat-divider>
  <div class="container" fxLayout="column">
    <div fxLayout="row" fxLayoutGap="10px">
      <div>
        <strong translate="LABEL_EMAIL"></strong>
        <p>{{user?.email}}</p>
      </div>
      <!--<div>
        <strong translate="LABEL_PASSWORD"></strong>
        <p>{{user?.password}}</p>
      </div>-->
    </div>
    <div fxLayout="row" fxLayoutGap="10px">
      <div>
        <strong translate="LABEL_CREATED_AT"></strong>
        <p>{{user?.createdAt}}</p>
      </div>
      <div>
        <strong translate="LABEL_UPDATED_AT"></strong>
        <p>{{user?.updatedAt}}</p>
      </div>
    </div>
  </div>
  <mat-dialog-actions align="end" class="dialogAction">
    <button mat-button style="height: 0; position: absolute;">
      <!-- 'absorbs' the auto-focus behavior -->
    </button>
    <button mat-stroked-button mat-dialog-close class="close-dialog buttons" aria-label="Close Dialog">
      <mat-icon>close</mat-icon>
      <span>{{'BTN_CLOSE' | translate}}</span>
    </button>
  </mat-dialog-actions>
</mat-dialog-content>


/* ===== FILE: ./frontend/src/app/mat-search-bar/mat-search-bar.component.html ===== */

<mat-form-field class="mat-search_field" [@slideInOut]="searchVisible">
    <input #input matInput type="text" [(ngModel)]="value" [placeholder]="placeholder" [disabled]="isDisabled" (ngModelChange)="updateChanges()"
        (blur)="onBlurring(input.value)" (keyup.enter)="onEnterring(input.value)" (focus)="onFocussing(input.value)"
        autocapitalize="none" />
</mat-form-field>


<span class="mat-search_icons" [class.mat-search_icons--active]="searchVisible">
    <mat-icon class="mat-search_icon-close" (click)="close()" matRipple>
        close
    </mat-icon>
    <mat-icon class="mat-search_icon-search" (click)="open()" matRipple>
        search
    </mat-icon>
</span>


/* ===== FILE: ./frontend/src/app/mat-search-bar/mat-search-bar.component.ts ===== */

import {
  animate,
  state,
  style,
  transition,
  trigger
} from '@angular/animations'
import {
  Component,
  ElementRef,
  EventEmitter,
  forwardRef,
  Input,
  type OnInit,
  Output,
  ViewChild
} from '@angular/core'
import { FormControl, NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms'
import { MatAutocomplete } from '@angular/material/autocomplete'
import { AbstractControlValueAccessor } from './abstract-value-accessor'
import { MatRipple } from '@angular/material/core'
import { MatIconModule } from '@angular/material/icon'
import { MatInputModule } from '@angular/material/input'
import { MatFormFieldModule } from '@angular/material/form-field'

@Component({
  selector: 'app-mat-search-bar',
  templateUrl: './mat-search-bar.component.html',
  styleUrls: ['./mat-search-bar.component.scss'],
  animations: [
    trigger('slideInOut', [
      state('true', style({ width: '*' })),
      state('false', style({ width: '0' })),
      transition('true => false', animate('300ms ease-in')),
      transition('false => true', animate('300ms ease-out'))
    ])
  ],
  providers: [
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => MatSearchBarComponent),
      multi: true
    }
  ],
  imports: [MatFormFieldModule, MatInputModule, FormsModule, MatIconModule, MatRipple]
})
export class MatSearchBarComponent extends AbstractControlValueAccessor
  implements OnInit {
  @ViewChild('input') inputElement: ElementRef

  @Input() formControl: FormControl
  @Input() matAutocomplete: MatAutocomplete
  @Input() placeholder = ''
  @Input() alwaysOpen: boolean = false
  @Output() onBlur = new EventEmitter<string>()
  @Output() onClose = new EventEmitter<void>()
  @Output() onEnter = new EventEmitter<string>()
  @Output() onFocus = new EventEmitter<string>()
  @Output() onOpen = new EventEmitter<void>()

  searchVisible = false

  get isDisabled (): string {
    return this.searchVisible ? null : 'disabled'
  }

  ngOnInit (): void {
    if (this.alwaysOpen) {
      this.searchVisible = true
    }
  }

  public close (): void {
    if (!this.alwaysOpen) {
      this.searchVisible = false
    }
    this.value = ''
    this.updateChanges()
    this.onClose.emit()
  }

  public open (): void {
    this.searchVisible = true
    this.inputElement.nativeElement.focus()
    this.onOpen.emit()
  }

  onBlurring (searchValue: string) {
    if (!searchValue && !this.alwaysOpen) {
      this.searchVisible = false
    }
    this.onBlur.emit(searchValue)
  }

  onEnterring (searchValue: string) {
    this.onEnter.emit(searchValue)
  }

  onFocussing (searchValue: string) {
    this.onFocus.emit(searchValue)
  }
}


/* ===== FILE: ./frontend/src/app/mat-search-bar/abstract-value-accessor.ts ===== */

import { type ControlValueAccessor } from '@angular/forms'

export abstract class AbstractControlValueAccessor
implements ControlValueAccessor {
  value: string

  /**
   * Invoked when the model has been changed
   */
  onChange: (_: any) => void = (_: any) => {}
  /**
   * Invoked when the model has been touched
   */
  onTouched: () => void = () => {}
  /**
   * Method that is invoked on an update of a model.
   */
  updateChanges () {
    this.onChange(this.value)
  }

  /**
   * Writes a new item to the element.
   * @param value the value
   */
  writeValue (value: string): void {
    this.value = value
    this.updateChanges()
  }

  /**
   * Registers a callback function that should be called when the control's value changes in the UI.
   * @param fn
   */
  registerOnChange (fn: any): void {
    this.onChange = fn
  }

  /**
   * Registers a callback function that should be called when the control receives a blur event.
   * @param fn
   */
  registerOnTouched (fn: any): void {
    this.onTouched = fn
  }
}


/* ===== FILE: ./frontend/src/app/photo-wall/photo-wall.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Component, type OnInit } from '@angular/core'
import { UntypedFormControl, UntypedFormGroup, Validators, FormsModule, ReactiveFormsModule } from '@angular/forms'
import { mimeType } from './mime-type.validator'
import { PhotoWallService } from '../Services/photo-wall.service'
import { ConfigurationService } from '../Services/configuration.service'
import { library } from '@fortawesome/fontawesome-svg-core'
import { faTwitter } from '@fortawesome/free-brands-svg-icons'
import { SnackBarHelperService } from '../Services/snack-bar-helper.service'
import { catchError } from 'rxjs/operators'
import { EMPTY } from 'rxjs'
import { MatInputModule } from '@angular/material/input'
import { MatFormFieldModule, MatLabel, MatError } from '@angular/material/form-field'
import { TranslateModule } from '@ngx-translate/core'
import { MatIconButton, MatButtonModule } from '@angular/material/button'
import { NgIf, NgFor } from '@angular/common'
import { MatCardModule, MatCardTitle, MatCardContent } from '@angular/material/card'

library.add(faTwitter)

@Component({
  selector: 'app-photo-wall',
  templateUrl: './photo-wall.component.html',
  styleUrls: ['./photo-wall.component.scss'],
  imports: [MatCardModule, NgIf, NgFor, MatIconButton, MatCardTitle, TranslateModule, MatCardContent, FormsModule, ReactiveFormsModule, MatButtonModule, MatFormFieldModule, MatLabel, MatInputModule, MatError]
})
export class PhotoWallComponent implements OnInit {
  public emptyState: boolean = true
  public imagePreview: string
  public form: UntypedFormGroup = new UntypedFormGroup({
    image: new UntypedFormControl('', { validators: [Validators.required], asyncValidators: [mimeType] }),
    caption: new UntypedFormControl('', [Validators.required])
  })

  public slideshowDataSource: Array<{ url: string, caption: string }> = []
  public twitterHandle = null

  constructor (private readonly photoWallService: PhotoWallService, private readonly configurationService: ConfigurationService,
    private readonly snackBarHelperService: SnackBarHelperService) { }

  ngOnInit (): void {
    this.slideshowDataSource = []
    this.photoWallService.get().pipe(catchError(err => {
      console.log(err)

      return EMPTY
    })).subscribe((memories) => {
      if (memories.length === 0) {
        this.emptyState = true
      } else {
        this.emptyState = false
      }
      for (const memory of memories) {
        if (memory.User?.username) {
          // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
          memory.caption = `${memory.caption} (© ${memory.User.username})`
        }
        this.slideshowDataSource.push({ url: memory.imagePath, caption: memory.caption })
      }
    })

    this.configurationService.getApplicationConfiguration().pipe(catchError(err => {
      console.log(err)

      return EMPTY
    })).subscribe((config) => {
      if (config?.application?.social) {
        if (config.application.social.twitterUrl) {
          this.twitterHandle = config.application.social.twitterUrl.replace('https://twitter.com/', '@')
        }
      }
    })
  }

  onImagePicked (event: Event) {
    const file = (event.target as HTMLInputElement).files[0]
    this.form.patchValue({ image: file })
    this.form.get('image').updateValueAndValidity()
    const reader = new FileReader()
    reader.onload = () => {
      this.imagePreview = reader.result as string
    }
    reader.readAsDataURL(file)
  }

  save () {
    this.photoWallService.addMemory(this.form.value.caption, this.form.value.image).subscribe(() => {
      this.resetForm()
      this.ngOnInit()
      this.snackBarHelperService.open('IMAGE_UPLOAD_SUCCESS', 'confirmBar')
    }, (err) => {
      this.snackBarHelperService.open(err.error?.error, 'errorBar')
      console.log(err)
    })
  }

  isLoggedIn () {
    return localStorage.getItem('token')
  }

  resetForm () {
    this.form.get('image').setValue('')
    this.form.get('image').markAsPristine()
    this.form.get('image').markAsUntouched()
    this.form.get('caption').setValue('')
    this.form.get('caption').markAsPristine()
    this.form.get('caption').markAsUntouched()
    this.form.get('caption').setErrors(null)
  }
}


/* ===== FILE: ./frontend/src/app/photo-wall/mime-type.validator.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type AbstractControl } from '@angular/forms'
import { Observable, type Observer, of } from 'rxjs'

export const mimeType = (
  control: AbstractControl
): Promise<Record<string, any>> | Observable<Record<string, any>> => {
  if (typeof (control.value) === 'string') {
    return of(null)
  }
  const file = control.value as File
  const fileReader = new FileReader()
  const frObs = new Observable(
    (observer: Observer<Record<string, any>>) => {
      fileReader.addEventListener('loadend', () => {
        const arr = new Uint8Array(fileReader.result as ArrayBuffer).subarray(0, 4)
        let header = ''
        let isValid = false
        for (let i = 0; i < arr.length; i++) {
          header += arr[i].toString(16)
        }
        switch (header) {
          case '89504e47':
            isValid = true
            break
          case 'ffd8ffe0':
          case 'ffd8ffe1':
          case 'ffd8ffe2':
          case 'ffd8ffe3':
          case 'ffd8ffe8':
            isValid = true
            break
          default:
            isValid = false
            break
        }
        if (isValid) {
          observer.next(null)
        } else {
          observer.next({ invalidMimeType: true })
        }
        observer.complete()
      })
      fileReader.readAsArrayBuffer(file)
    }
  )
  return frObs
}


/* ===== FILE: ./frontend/src/app/photo-wall/photo-wall.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<mat-card appearance="outlined" class="heading mat-elevation-z6 mat-own-card" style="margin-bottom:10px;">
  <div class="mdc-card">
    <h1>{{"LABEL_PHOTO_WALL" | translate}}</h1>
    <div>
      <div class="grid" *ngIf="!emptyState; else emptyResult">
                  <span *ngFor="let image of slideshowDataSource" class="container mat-elevation-z6">
                      <img src="{{ image.url }}" alt="{{ image.caption }}" class="image">
                      <div class="overlay">
                          <div>{{ image.caption }}</div>
                          <a *ngIf="twitterHandle"
                            href="https://twitter.com/intent/tweet?text={{ image.caption }} {{ twitterHandle }}&hashtags=appsec"
                            target="_blank">
                              <button mat-icon-button aria-label="Tweet">
                                  <i class="fab fa-twitter fa-lg"></i>
                              </button>
                          </a>
                      </div>
                  </span>
      </div>
    </div>

    <ng-template #emptyResult>
      <mat-card appearance="outlined" class="mat-elevation-z0 emptyState">
        <div class="mdc-card">
          <img alt=" No results found"
              class="img-responsive noResult"
              src="assets/public/images/products/no-results.png">
          <mat-card-title>
                <span class="noResultText" translate>
                    NO_SEARCH_RESULT
                </span>
          </mat-card-title>
          <mat-card-content>
                <span class="noResultText" translate>
                    EMPTY_MEMORY_LIST
                </span>
          </mat-card-content>
        </div>
      </mat-card>
    </ng-template>

    <div *ngIf="isLoggedIn()">
      <div style="margin-top: 10px;">
        <h2 translate>LABEL_SHARE_A_MEMORY</h2>
        <form [formGroup]="form" enctype="multipart/form-data">
          <div>
            <button mat-stroked-button type="button" (click)="filePicker.click()">{{'LABEL_PICK_IMAGE' | translate}}
            </button>
            <input type="file" name='file' #filePicker (change)="onImagePicked($event)">
          </div>
          <div class="image-preview" *ngIf="imagePreview !== '' && imagePreview && form.get('image').valid">
            <img [src]="imagePreview" [alt]="form.value.caption">
          </div>
          <mat-form-field appearance="outline" color="accent">
            <mat-label translate>LABEL_CAPTION</mat-label>
            <input formControlName="caption" type="text" matInput>
            <mat-error *ngIf="form.get('caption').invalid" translate>{{'MANDATORY_CAPTION' | translate}}</mat-error>
          </mat-form-field>
          <button id="submitButton" mat-raised-button color="primary" (click)="save()"
                  [disabled]="form.get('image').invalid || form.get('caption').invalid">
            <mat-icon>send</mat-icon>
            {{'BTN_SUBMIT' | translate}}
          </button>
        </form>
      </div>
    </div>
  </div>
</mat-card>


/* ===== FILE: ./frontend/src/app/photo-wall/photo-wall.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateModule, TranslateService } from '@ngx-translate/core'
import { MatDividerModule } from '@angular/material/divider'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { type ComponentFixture, fakeAsync, TestBed, waitForAsync } from '@angular/core/testing'
import { RouterTestingModule } from '@angular/router/testing'
import { MatGridListModule } from '@angular/material/grid-list'
import { MatCardModule } from '@angular/material/card'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'
import { MatTableModule } from '@angular/material/table'
import { MatPaginatorModule } from '@angular/material/paginator'
import { of } from 'rxjs'
import { MatFormFieldModule } from '@angular/material/form-field'
import { throwError } from 'rxjs/internal/observable/throwError'
import { PhotoWallComponent } from './photo-wall.component'
import { PhotoWallService } from '../Services/photo-wall.service'
import { FormsModule, ReactiveFormsModule } from '@angular/forms'
import { ConfigurationService } from '../Services/configuration.service'
import { MatIconModule } from '@angular/material/icon'
import { MatTooltipModule } from '@angular/material/tooltip'
import { MatDialogModule } from '@angular/material/dialog'
import { MatExpansionModule } from '@angular/material/expansion'
import { MatInputModule } from '@angular/material/input'
import { MatSnackBar } from '@angular/material/snack-bar'
import { EventEmitter } from '@angular/core'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('PhotoWallComponent', () => {
  let component: PhotoWallComponent
  let fixture: ComponentFixture<PhotoWallComponent>
  let photoWallService: any
  let configurationService: any
  let snackBar: any
  let translateService

  beforeEach(waitForAsync(() => {
    configurationService = jasmine.createSpyObj('ConfigurationService', ['getApplicationConfiguration'])
    configurationService.getApplicationConfiguration.and.returnValue(of({}))
    photoWallService = jasmine.createSpyObj('PhotoWallService', ['get', 'addMemory'])
    photoWallService.get.and.returnValue(of([]))
    photoWallService.addMemory.and.returnValue(of({}))
    translateService = jasmine.createSpyObj('TranslateService', ['get'])
    translateService.get.and.returnValue(of({}))
    translateService.onLangChange = new EventEmitter()
    translateService.onTranslationChange = new EventEmitter()
    translateService.onDefaultLangChange = new EventEmitter()
    snackBar = jasmine.createSpyObj('MatSnackBar', ['open'])

    TestBed.configureTestingModule({
      imports: [RouterTestingModule,
        TranslateModule.forRoot(),
        BrowserAnimationsModule,
        MatTableModule,
        MatPaginatorModule,
        MatFormFieldModule,
        MatDividerModule,
        MatGridListModule,
        MatCardModule,
        MatIconModule,
        MatTooltipModule,
        MatDialogModule,
        MatExpansionModule,
        FormsModule,
        ReactiveFormsModule,
        MatInputModule,
        PhotoWallComponent],
      providers: [
        { provide: PhotoWallService, useValue: photoWallService },
        { provide: ConfigurationService, useValue: configurationService },
        { provide: TranslateService, useValue: translateService },
        { provide: MatSnackBar, useValue: snackBar },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(PhotoWallComponent)
    component = fixture.componentInstance
    component.ngOnInit()
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should make emptyState true and hold no memories when get API gives empty response', () => {
    photoWallService.get.and.returnValue(of([]))
    component.ngOnInit()
    expect(component.emptyState).toBe(true)
    expect(component.slideshowDataSource).toEqual([])
  })

  it('should make emptyState false when get API gives non empty response', () => {
    photoWallService.get.and.returnValue(of([{ imagePath: '', caption: '' }]))
    component.ngOnInit()
    expect(component.emptyState).toBe(false)
  })

  it('should log error from get API call directly to browser console', fakeAsync(() => {
    photoWallService.get.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.ngOnInit()
    fixture.detectChanges()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should log error from addMemory API call directly to browser console', fakeAsync(() => {
    photoWallService.addMemory.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.save()
    fixture.detectChanges()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should add new memory to photo wall', () => {
    photoWallService.addMemory.and.returnValue(of({}))
    spyOn(component, 'ngOnInit')
    spyOn(component, 'resetForm')
    component.save()
    expect(component.ngOnInit).toHaveBeenCalled()
    expect(component.resetForm).toHaveBeenCalled()
  })

  it('should reinitizalise add memory form by calling resetForm', () => {
    component.form.get('image').setValue(new File([''], 'image'))
    component.form.get('caption').setValue('Juice Party')
    component.resetForm()
    expect(component.form.get('image').value).toBe('')
    expect(component.form.get('image').pristine).toBe(true)
    expect(component.form.get('image').untouched).toBe(true)
    expect(component.form.get('caption').value).toBe('')
    expect(component.form.get('caption').pristine).toBe(true)
    expect(component.form.get('caption').untouched).toBe(true)
  })

  it('should use custom twitter handle if configured', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { social: { twitterUrl: 'twitter' } } }))
    component.ngOnInit()
    expect(component.twitterHandle).toBe('twitter')
  })

  it('should log error while getting application configuration from backend API directly to browser console', fakeAsync(() => {
    configurationService.getApplicationConfiguration.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.ngOnInit()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))
})


/* ===== FILE: ./frontend/src/app/about/about.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<mat-card appearance="outlined" class="mat-elevation-z6">
  <div class="mdc-card">
    <section class="about-us">
      <h1>{{"TITLE_ABOUT" | translate}}</h1>
      <h3>{{"SECTION_CORPORATE_HISTORY" | translate}}</h3>
      <p class="text-justify">

        Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et
        dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet
        clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet,
        consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed
        diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea
        takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed
        diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua.

        Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu
        feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent luptatum zzril
        delenit augue duis dolore te feugait nulla facilisi. Lorem ipsum dolor sit amet, consectetuer adipiscing elit,
        sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat.

        <a href="ftp/legal.md" aria-label="Link to the Terms of Use" translate>LINK_TERMS_OF_USE</a>

        At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est
        Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod
        tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo
        dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem
        ipsum dolor sit amet, consetetur sadipscing elitr, At accusam aliquyam diam diam dolore dolores duo eirmod eos
        erat, et nonumy sed tempor et et invidunt justo labore Stet clita ea et gubergren, kasd magna no rebum.
      </p>

      <h3><span>{{"SECTION_CUSTOMER_FEEDBACK" | translate}}</span></h3>
      <gallery id="feedback-gallery"
               style="height: 300px;"
               [autoPlay]="true"
               [thumb]="false"
               [counter]="false"
               [imageSize]="'cover'"
               >
                <ng-container *galleryImageDef="let item; let active = active">
                  <div *ngIf="active" class="item-text">
                    <div class="caption" [innerHTML]="item?.args"></div>
                  </div>
                </ng-container>
      </gallery>
      <div *ngIf="blueSkyUrl || mastodonUrl || twitterUrl || facebookUrl || slackUrl || redditUrl || pressKitUrl || nftUrl" class="social">
        <h3><span>{{"SECTION_SOCIAL_MEDIA" | translate }}</span></h3>
      <a *ngIf="blueSkyUrl" [href]="blueSkyUrl" target="_blank" rel="noopener noreferrer" style="margin-left: 0px;" aria-label="Button for the BlueSky page of the shop">
        <button mat-raised-button color="accent"><i class="fas fa-bold fa-lg"></i> BlueSky</button>
      </a>
      <a *ngIf="mastodonUrl" [href]="mastodonUrl" target="_blank" rel="noopener noreferrer" style="margin-left: 0px;" aria-label="Button for the Mastodon page of the shop">
        <button mat-raised-button color="accent"><i class="fab fa-mastodon fa-lg"></i> Mastodon</button>
      </a>
        <a *ngIf="twitterUrl" [href]="twitterUrl" target="_blank" rel="noopener noreferrer" style="margin-left: 0px;" aria-label="Button for the Twitter page of the shop">
          <button mat-raised-button color="accent"><i class="fab fa-twitter fa-lg"></i> Twitter</button>
        </a>
        <a *ngIf="facebookUrl" [href]="facebookUrl" target="_blank" rel="noopener noreferrer" aria-label="Button for the Facebook page of the shop">
          <button mat-raised-button color="accent"><i class="fab fa-facebook fa-lg"></i> Facebook</button>
        </a>
        <a *ngIf="slackUrl" [href]="slackUrl" target="_blank" rel="noopener noreferrer" aria-label="Button for the Slack page of the shop">
          <button mat-raised-button color="accent"><i class="fab fa-slack fa-lg"></i> Slack</button>
        </a>
        <a *ngIf="redditUrl" [href]="redditUrl" target="_blank" rel="noopener noreferrer" aria-label="Button for the Reddit page of the shop">
          <button mat-raised-button color="accent"><i class="fab fa-reddit fa-lg"></i> Reddit</button>
        </a>
        <a *ngIf="pressKitUrl" [href]="pressKitUrl" target="_blank" rel="noopener noreferrer" aria-label="Button for the PressKit page of the shop">
          <button mat-raised-button color="accent"><i class="far fa-newspaper fa-lg"></i> Press Kit</button>
        </a>
        <a *ngIf="nftUrl" [href]="nftUrl" target="_blank" rel="noopener noreferrer" aria-label="Button for the NFT of the shop">
          <button mat-raised-button color="accent"><i class="fas fa-palette fa-lg"></i> NFT</button>
        </a>
      </div>
    </section>
  </div>
</mat-card>


/* ===== FILE: ./frontend/src/app/about/about.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateModule, TranslateService } from '@ngx-translate/core'
import { EventEmitter, NO_ERRORS_SCHEMA } from '@angular/core'
import { type ComponentFixture, TestBed, waitForAsync } from '@angular/core/testing'
import { provideHttpClientTesting } from '@angular/common/http/testing'

import { AboutComponent } from './about.component'
import { MatCardModule } from '@angular/material/card'

import { of } from 'rxjs'
import { ConfigurationService } from '../Services/configuration.service'
import { GalleryModule } from 'ng-gallery'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('AboutComponent', () => {
  let component: AboutComponent
  let fixture: ComponentFixture<AboutComponent>
  let configurationService
  let translateService

  beforeEach(waitForAsync(() => {
    configurationService = jasmine.createSpyObj('ConfigurationService', ['getApplicationConfiguration'])
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { } }))
    translateService = jasmine.createSpyObj('TranslateService', ['get'])
    translateService.get.and.returnValue(of({}))
    translateService.onLangChange = new EventEmitter()
    translateService.onTranslationChange = new EventEmitter()
    translateService.onDefaultLangChange = new EventEmitter()

    TestBed.configureTestingModule({
      schemas: [NO_ERRORS_SCHEMA],
      imports: [MatCardModule,
        GalleryModule,
        AboutComponent,
        TranslateModule.forRoot()],
      providers: [
        { provide: ConfigurationService, useValue: configurationService },
        { provide: TranslateService, useValue: translateService },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(AboutComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should set Twitter link as obtained from configuration', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { social: { twitterUrl: 'TWITTER' } } }))
    component.ngOnInit()

    expect(component.twitterUrl).toBe('TWITTER')
  })

  it('should set Facebook link as obtained from configuration', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { social: { facebookUrl: 'FACEBOOK' } } }))
    component.ngOnInit()

    expect(component.facebookUrl).toBe('FACEBOOK')
  })

  it('should set Slack link as obtained from configuration', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { social: { slackUrl: 'SLACK' } } }))
    component.ngOnInit()

    expect(component.slackUrl).toBe('SLACK')
  })

  it('should set Reddit link as obtained from configuration', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { social: { redditUrl: 'REDDIT' } } }))
    component.ngOnInit()

    expect(component.redditUrl).toBe('REDDIT')
  })

  it('should set press kit link as obtained from configuration', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { social: { pressKitUrl: 'PRESS_KIT' } } }))
    component.ngOnInit()

    expect(component.pressKitUrl).toBe('PRESS_KIT')
  })

  it('should set NFT link as obtained from configuration', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { social: { nftUrl: 'NFT' } } }))
    component.ngOnInit()

    expect(component.nftUrl).toBe('NFT')
  })
})


/* ===== FILE: ./frontend/src/app/about/about.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Component, type OnInit } from '@angular/core'
import { DomSanitizer } from '@angular/platform-browser'
import { ConfigurationService } from '../Services/configuration.service'
import { FeedbackService } from '../Services/feedback.service'
import { Gallery, type GalleryRef, GalleryComponent, GalleryImageDef } from 'ng-gallery'
import { library } from '@fortawesome/fontawesome-svg-core'
import { faFacebook, faMastodon, faReddit, faSlack, faTwitter } from '@fortawesome/free-brands-svg-icons'
import { faNewspaper, faStar } from '@fortawesome/free-regular-svg-icons'
import { faStar as fasStar, faPalette, faBold } from '@fortawesome/free-solid-svg-icons'
import { catchError } from 'rxjs/operators'
import { EMPTY } from 'rxjs'
import { MatButtonModule } from '@angular/material/button'
import { NgIf } from '@angular/common'
import { TranslateModule } from '@ngx-translate/core'
import { MatCardModule } from '@angular/material/card'
import { FlexModule } from '@angular/flex-layout/flex'

library.add(faFacebook, faTwitter, faSlack, faReddit, faNewspaper, faStar, fasStar, faPalette, faMastodon, faBold)

@Component({
  selector: 'app-about',
  templateUrl: './about.component.html',
  styleUrls: ['./about.component.scss'],
  imports: [FlexModule, MatCardModule, TranslateModule, GalleryComponent, GalleryImageDef, NgIf, MatButtonModule]
})
export class AboutComponent implements OnInit {
  public blueSkyUrl?: string
  public mastodonUrl?: string
  public twitterUrl?: string
  public facebookUrl?: string
  public slackUrl?: string
  public redditUrl?: string
  public pressKitUrl?: string
  public nftUrl?: string
  public galleryRef: GalleryRef

  private readonly images = [
    'assets/public/images/carousel/1.jpg',
    'assets/public/images/carousel/2.jpg',
    'assets/public/images/carousel/3.jpg',
    'assets/public/images/carousel/4.jpg',
    'assets/public/images/carousel/5.png',
    'assets/public/images/carousel/6.jpg',
    'assets/public/images/carousel/7.jpg'
  ]

  private readonly stars = [
    null,
    '<i class="fas fa-star"></i><i class="far fa-star"></i><i class="far fa-star"></i><i class="far fa-star"></i><i class="far fa-star"></i>',
    '<i class="fas fa-star"></i><i class="fas fa-star"></i><i class="far fa-star"></i><i class="far fa-star"></i><i class="far fa-star"></i>',
    '<i class="fas fa-star"></i><i class="fas fa-star"></i><i class="fas fa-star"></i><i class="far fa-star"></i><i class="far fa-star"></i>',
    '<i class="fas fa-star"></i><i class="fas fa-star"></i><i class="fas fa-star"></i><i class="fas fa-star"></i><i class="far fa-star"></i>',
    '<i class="fas fa-star"></i><i class="fas fa-star"></i><i class="fas fa-star"></i><i class="fas fa-star"></i><i class="fas fa-star"></i>'
  ]

  constructor (
    private readonly configurationService: ConfigurationService,
    private readonly feedbackService: FeedbackService,
    private readonly sanitizer: DomSanitizer,
    private readonly gallery: Gallery
  ) {}

  ngOnInit (): void {
    this.galleryRef = this.gallery.ref('feedback-gallery')
    this.populateSlideshowFromFeedbacks()
    this.configurationService.getApplicationConfiguration()
      .pipe(
        catchError((err) => {
          console.error(err)
          return EMPTY
        })
      ).subscribe((config) => {
        if (config?.application?.social) {
          if (config.application.social.blueSkyUrl) {
            this.blueSkyUrl = config.application.social.blueSkyUrl
          }
          if (config.application.social.mastodonUrl) {
            this.mastodonUrl = config.application.social.mastodonUrl
          }
          if (config.application.social.twitterUrl) {
            this.twitterUrl = config.application.social.twitterUrl
          }
          if (config.application.social.facebookUrl) {
            this.facebookUrl = config.application.social.facebookUrl
          }
          if (config.application.social.slackUrl) {
            this.slackUrl = config.application.social.slackUrl
          }
          if (config.application.social.redditUrl) {
            this.redditUrl = config.application.social.redditUrl
          }
          if (config.application.social.pressKitUrl) {
            this.pressKitUrl = config.application.social.pressKitUrl
          }
          if (config.application.social.nftUrl) {
            this.nftUrl = config.application.social.nftUrl
          }
        }
      })
  }

  populateSlideshowFromFeedbacks () {
    this.feedbackService
      .find()
      .pipe(
        catchError((err) => {
          console.error(err)
          return EMPTY
        })
      )
      .subscribe((feedbacks) => {
        for (let i = 0; i < feedbacks.length; i++) {
          // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
          feedbacks[i].comment = `<span style="width: 90%; display:block;">${
            feedbacks[i].comment
          }<br/> (${this.stars[feedbacks[i].rating]})</span>`
          feedbacks[i].comment = this.sanitizer.bypassSecurityTrustHtml(
            feedbacks[i].comment
          )

          this.galleryRef.addImage({
            src: this.images[i % this.images.length],
            args: feedbacks[i].comment
          })
        }
      })
  }
}


/* ===== FILE: ./frontend/src/app/server-started-notification/server-started-notification.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateService, TranslateModule } from '@ngx-translate/core'
import { ChallengeService } from '../Services/challenge.service'
import { ChangeDetectorRef, Component, NgZone, type OnInit } from '@angular/core'
import { CookieService } from 'ngy-cookie'
import { SocketIoService } from '../Services/socket-io.service'
import { MatIconModule } from '@angular/material/icon'
import { MatButtonModule } from '@angular/material/button'
import { MatCardModule, MatCardContent } from '@angular/material/card'
import { NgIf } from '@angular/common'

interface HackingProgress {
  autoRestoreMessage: string | null
  cleared: boolean
}

@Component({
  selector: 'app-server-started-notification',
  templateUrl: './server-started-notification.component.html',
  styleUrls: ['./server-started-notification.component.scss'],
  imports: [NgIf, MatCardModule, MatCardContent, TranslateModule, MatButtonModule, MatIconModule]
})
export class ServerStartedNotificationComponent implements OnInit {
  public hackingProgress: HackingProgress = {} as HackingProgress

  constructor (private readonly ngZone: NgZone, private readonly challengeService: ChallengeService, private readonly translate: TranslateService, private readonly cookieService: CookieService, private readonly ref: ChangeDetectorRef, private readonly io: SocketIoService) {
  }

  ngOnInit (): void {
    this.ngZone.runOutsideAngular(() => {
      this.io.socket().on('server started', () => {
        const continueCode = this.cookieService.get('continueCode')
        const continueCodeFindIt = this.cookieService.get('continueCodeFindIt')
        const continueCodeFixIt = this.cookieService.get('continueCodeFixIt')
        if (continueCode) {
          this.challengeService.restoreProgress(encodeURIComponent(continueCode)).subscribe(() => {
            this.translate.get('AUTO_RESTORED_PROGRESS').subscribe((notificationServerStarted) => {
              this.hackingProgress.autoRestoreMessage = notificationServerStarted
            }, (translationId) => {
              this.hackingProgress.autoRestoreMessage = translationId
            })
          }, (error) => {
            console.log(error)
            this.translate.get('AUTO_RESTORE_PROGRESS_FAILED', { error }).subscribe((notificationServerStarted) => {
              this.hackingProgress.autoRestoreMessage = notificationServerStarted
            }, (translationId) => {
              this.hackingProgress.autoRestoreMessage = translationId
            })
          })
        }
        if (continueCodeFindIt) {
          this.challengeService.restoreProgressFindIt(encodeURIComponent(continueCodeFindIt)).subscribe(() => {
          }, (error) => {
            console.log(error)
          })
        }
        if (continueCodeFixIt) {
          this.challengeService.restoreProgressFixIt(encodeURIComponent(continueCodeFixIt)).subscribe(() => {
          }, (error) => {
            console.log(error)
          })
        }
        this.ref.detectChanges()
      })
    })
  }

  closeNotification () {
    this.hackingProgress.autoRestoreMessage = null
  }

  clearProgress () {
    this.cookieService.remove('continueCode')
    this.cookieService.remove('continueCodeFixIt')
    this.cookieService.remove('continueCodeFindIt')
    this.cookieService.remove('token')
    sessionStorage.removeItem('bid')
    sessionStorage.removeItem('itemTotal')
    localStorage.removeItem('token')
    localStorage.removeItem('displayedDifficulties')
    localStorage.removeItem('showSolvedChallenges')
    localStorage.removeItem('showDisabledChallenges')
    localStorage.removeItem('showOnlyTutorialChallenges')
    localStorage.removeItem('displayedChallengeCategories')
    this.hackingProgress.cleared = true
  }
}


/* ===== FILE: ./frontend/src/app/server-started-notification/server-started-notification.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { CookieModule, CookieService } from 'ngy-cookie'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { TranslateModule, TranslateService } from '@ngx-translate/core'
import { MatButtonModule } from '@angular/material/button'
import { MatCardModule } from '@angular/material/card'
import { type ComponentFixture, fakeAsync, TestBed, waitForAsync } from '@angular/core/testing'

import { ServerStartedNotificationComponent } from './server-started-notification.component'
import { ChallengeService } from '../Services/challenge.service'
import { SocketIoService } from '../Services/socket-io.service'
import { of, throwError } from 'rxjs'
import { EventEmitter } from '@angular/core'
import { MatIconModule } from '@angular/material/icon'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

class MockSocket {
  on (str: string, callback: any) {
    callback()
  }
}

describe('ServerStartedNotificationComponent', () => {
  let component: ServerStartedNotificationComponent
  let fixture: ComponentFixture<ServerStartedNotificationComponent>
  let challengeService: any
  let translateService: any
  let cookieService: any
  let socketIoService: any
  let mockSocket: any

  beforeEach(waitForAsync(() => {
    challengeService = jasmine.createSpyObj('ChallengeService', ['restoreProgress'])
    challengeService.restoreProgress.and.returnValue(of({}))
    translateService = jasmine.createSpyObj('TranslateService', ['get'])
    translateService.get.and.returnValue(of({}))
    translateService.onLangChange = new EventEmitter()
    translateService.onTranslationChange = new EventEmitter()
    translateService.onDefaultLangChange = new EventEmitter()
    mockSocket = new MockSocket()
    socketIoService = jasmine.createSpyObj('SocketIoService', ['socket'])
    socketIoService.socket.and.returnValue(mockSocket)

    TestBed.configureTestingModule({
      imports: [TranslateModule.forRoot(),
        CookieModule.forRoot(),
        MatCardModule,
        MatButtonModule,
        MatIconModule,
        ServerStartedNotificationComponent],
      providers: [
        { provide: ChallengeService, useValue: challengeService },
        { provide: TranslateService, useValue: translateService },
        { provide: SocketIoService, useValue: socketIoService },
        CookieService,
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()

    cookieService = TestBed.inject(CookieService)
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(ServerStartedNotificationComponent)
    component = fixture.componentInstance
    cookieService.remove('continueCode')
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should keep continue code cookie after successfully restoring progress on server start', () => {
    spyOn(mockSocket, 'on')
    cookieService.put('continueCode', 'CODE')
    component.ngOnInit()
    const callback = mockSocket.on.calls.argsFor(0)[1]
    callback()
    expect(mockSocket.on.calls.argsFor(0)[0]).toBe('server started')
    expect(cookieService.get('continueCode')).toBe('CODE')
  })

  it('should set auto-restore success-message when progress restore succeeds', () => {
    spyOn(mockSocket, 'on')
    translateService.get.and.returnValue(of('AUTO_RESTORED_PROGRESS'))
    cookieService.put('continueCode', 'CODE')
    component.ngOnInit()
    const callback = mockSocket.on.calls.argsFor(0)[1]
    callback()
    expect(mockSocket.on.calls.argsFor(0)[0]).toBe('server started')
    expect(component.hackingProgress.autoRestoreMessage).toBeDefined()
  })

  it('should translate AUTO_RESTORED_PROGRESS message', () => {
    spyOn(mockSocket, 'on')
    translateService.get.and.returnValue(of('Translation of AUTO_RESTORED_PROGRESS'))
    cookieService.put('continueCode', 'CODE')
    component.ngOnInit()
    const callback = mockSocket.on.calls.argsFor(0)[1]
    callback()
    expect(mockSocket.on.calls.argsFor(0)[0]).toBe('server started')
    expect(component.hackingProgress.autoRestoreMessage).toBe('Translation of AUTO_RESTORED_PROGRESS')
  })

  it('should log errors during automatic progress restore directly to browser console', fakeAsync(() => {
    spyOn(mockSocket, 'on')
    challengeService.restoreProgress.and.returnValue(throwError('Error'))
    cookieService.put('continueCode', 'CODE')
    console.log = jasmine.createSpy('log')
    component.ngOnInit()
    const callback = mockSocket.on.calls.argsFor(0)[1]
    callback()
    expect(mockSocket.on.calls.argsFor(0)[0]).toBe('server started')
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should set auto-restore error-message when progress restore failed', fakeAsync(() => {
    spyOn(mockSocket, 'on')
    challengeService.restoreProgress.and.returnValue(throwError('Error'))
    translateService.get.and.returnValue(of('AUTO_RESTORE_PROGRESS_FAILED'))
    cookieService.put('continueCode', 'CODE')
    component.ngOnInit()
    const callback = mockSocket.on.calls.argsFor(0)[1]
    callback()
    expect(mockSocket.on.calls.argsFor(0)[0]).toBe('server started')
    expect(component.hackingProgress.autoRestoreMessage).toBeDefined()
  }))

  it('should translate AUTO_RESTORE_PROGRESS_FAILED message including the returned error', fakeAsync(() => {
    spyOn(mockSocket, 'on')
    challengeService.restoreProgress.and.returnValue(throwError('Error'))
    translateService.get.and.returnValue(of('Translation of AUTO_RESTORE_PROGRESS_FAILED: error'))
    cookieService.put('continueCode', 'CODE')
    component.ngOnInit()
    const callback = mockSocket.on.calls.argsFor(0)[1]
    callback()
    expect(mockSocket.on.calls.argsFor(0)[0]).toBe('server started')
    expect(component.hackingProgress.autoRestoreMessage).toBe('Translation of AUTO_RESTORE_PROGRESS_FAILED: error')
  }))

  it('do nothing if continueCode cookie is not present', () => {
    spyOn(mockSocket, 'on')
    component.ngOnInit()
    const callback = mockSocket.on.calls.argsFor(0)[1]
    callback()
    expect(mockSocket.on.calls.argsFor(0)[0]).toBe('server started')
    expect(component.hackingProgress.autoRestoreMessage).toBeUndefined()
  })

  it('should remove the restore message when closing the notification', () => {
    component.closeNotification()
    expect(component.hackingProgress.autoRestoreMessage).toBeNull()
  })

  it('should remove the continue code cookie when clearing the progress', () => {
    component.clearProgress()
    expect(cookieService.get('continueCode')).toBeUndefined()
    expect(component.hackingProgress.cleared).toBe(true)
  })
})


/* ===== FILE: ./frontend/src/app/server-started-notification/server-started-notification.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->
  
<mat-card appearance="outlined" class="container primary-notification mat-elevation-z4" *ngIf="hackingProgress.autoRestoreMessage">
    <mat-card-content>
        <span translate>NOTIFICATION_SERVER_STARTED</span>: {{hackingProgress.autoRestoreMessage}}&nbsp;<button id="closeButton" mat-button (click)="closeNotification()">X</button>
        <button mat-stroked-button [disabled]="hackingProgress.cleared" (click)="clearProgress()">
        <mat-icon>delete_forever</mat-icon>
        <span *ngIf="hackingProgress.cleared" translate>RESTART_REQUIRED</span>
        <span *ngIf="!hackingProgress.cleared" translate>RESET_HACKING_PROGRESS</span>
        </button>
    </mat-card-content>
</mat-card>


/* ===== FILE: ./frontend/src/app/Models/challenge.model.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type SafeHtml } from '@angular/platform-browser'

export interface Challenge {
  name: string
  key: string
  category: string
  tags?: string
  description?: string | SafeHtml
  difficulty: 1 | 2 | 3 | 4 | 5 | 6
  hint?: string
  hintUrl?: string
  disabledEnv?: string
  solved?: boolean
  tutorialOrder?: number
  hasTutorial?: boolean
  hasSnippet?: boolean
  codingChallengeStatus?: 0 | 1 | 2
  mitigationUrl?: string
  hasCodingChallenge: boolean
}


/* ===== FILE: ./frontend/src/app/Models/backup.model.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

export interface Backup {
  version: number
  continueCode?: string
  continueCodeFindIt?: string
  continueCodeFixIt?: string
  language?: string
  banners?: { welcomeBannerStatus?: string, cookieConsentStatus?: string }
}


/* ===== FILE: ./frontend/src/app/Models/deliveryMethod.model.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

export interface DeliveryMethod {
  id: number
  name: string
  price: number
  eta: number
  icon: string
}


/* ===== FILE: ./frontend/src/app/Models/product.model.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

export interface Product {
  id: number
  name: string
  description: string
  image: string
  price: number
  points: number
}


/* ===== FILE: ./frontend/src/app/Models/review.model.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

export interface Review {
  _id: string
  message: string
  author: string
}


/* ===== FILE: ./frontend/src/app/Models/securityQuestion.model.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

export interface SecurityQuestion {
  id: number
  question: string
}


/* ===== FILE: ./frontend/src/app/saved-payment-methods/saved-payment-methods.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<mat-card appearance="outlined" class="mat-own-card mat-elevation-z6">
  <div class="mdc-card">
    <app-payment-method [allowDelete]="true"></app-payment-method>
  </div>
</mat-card>


/* ===== FILE: ./frontend/src/app/saved-payment-methods/saved-payment-methods.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateModule, TranslateService } from '@ngx-translate/core'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { MatCardModule } from '@angular/material/card'
import { MatFormFieldModule } from '@angular/material/form-field'
import { type ComponentFixture, TestBed, waitForAsync } from '@angular/core/testing'
import { MatInputModule } from '@angular/material/input'
import { ReactiveFormsModule } from '@angular/forms'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'

import { MatTableModule } from '@angular/material/table'
import { MatExpansionModule } from '@angular/material/expansion'
import { MatDividerModule } from '@angular/material/divider'
import { MatRadioModule } from '@angular/material/radio'
import { MatDialogModule } from '@angular/material/dialog'
import { SavedPaymentMethodsComponent } from './saved-payment-methods.component'
import { PaymentMethodComponent } from '../payment-method/payment-method.component'
import { EventEmitter } from '@angular/core'
import { of } from 'rxjs'
import { MatSnackBar } from '@angular/material/snack-bar'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('SavedPaymentMethodsComponent', () => {
  let component: SavedPaymentMethodsComponent
  let translateService
  let fixture: ComponentFixture<SavedPaymentMethodsComponent>
  let snackBar: any

  beforeEach(waitForAsync(() => {
    translateService = jasmine.createSpyObj('TranslateService', ['get'])
    translateService.get.and.returnValue(of({}))
    translateService.onLangChange = new EventEmitter()
    translateService.onTranslationChange = new EventEmitter()
    translateService.onDefaultLangChange = new EventEmitter()
    snackBar = jasmine.createSpyObj('MatSnackBar', ['open'])

    TestBed.configureTestingModule({
      imports: [TranslateModule.forRoot(),
        ReactiveFormsModule,
        BrowserAnimationsModule,
        MatCardModule,
        MatTableModule,
        MatFormFieldModule,
        MatInputModule,
        MatExpansionModule,
        MatDividerModule,
        MatRadioModule,
        MatDialogModule,
        SavedPaymentMethodsComponent, PaymentMethodComponent],
      providers: [
        { provide: TranslateService, useValue: translateService },
        { provide: MatSnackBar, useValue: snackBar },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(SavedPaymentMethodsComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })
})


/* ===== FILE: ./frontend/src/app/saved-payment-methods/saved-payment-methods.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Component } from '@angular/core'
import { PaymentMethodComponent } from '../payment-method/payment-method.component'
import { MatCardModule } from '@angular/material/card'

@Component({
  selector: 'app-saved-payment-methods',
  templateUrl: './saved-payment-methods.component.html',
  styleUrls: ['./saved-payment-methods.component.scss'],
  imports: [MatCardModule, PaymentMethodComponent]
})

export class SavedPaymentMethodsComponent {
}


/* ===== FILE: ./frontend/src/app/welcome/welcome.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<div></div>


/* ===== FILE: ./frontend/src/app/welcome/welcome.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateModule } from '@ngx-translate/core'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { MatDialog, MatDialogModule } from '@angular/material/dialog'
import { CookieModule, CookieService } from 'ngy-cookie'

import { type ComponentFixture, TestBed } from '@angular/core/testing'

import { WelcomeComponent } from './welcome.component'
import { of } from 'rxjs'
import { ConfigurationService } from '../Services/configuration.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('WelcomeComponent', () => {
  let component: WelcomeComponent
  let configurationService: any
  let cookieService: any
  let fixture: ComponentFixture<WelcomeComponent>
  let dialog: any

  beforeEach(() => {
    configurationService = jasmine.createSpyObj('ConfigurationService', ['getApplicationConfiguration'])
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: {} }))
    dialog = jasmine.createSpyObj('MatDialog', ['open'])
    dialog.open.and.returnValue(null)

    TestBed.configureTestingModule({
      imports: [TranslateModule.forRoot(),
        CookieModule.forRoot(),
        MatDialogModule,
        WelcomeComponent],
      providers: [
        { provide: ConfigurationService, useValue: configurationService },
        { provide: MatDialog, useValue: dialog },
        CookieService,
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()

    cookieService = TestBed.inject(CookieService)
  })

  beforeEach(() => {
    fixture = TestBed.createComponent(WelcomeComponent)
    component = fixture.componentInstance
    cookieService.remove('welcomebanner_status')
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should open the welcome banner dialog if configured to show on start', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { welcomeBanner: { showOnFirstStart: true } } }))
    component.ngOnInit()
    expect(dialog.open).toHaveBeenCalled()
  })

  it('should not open the welcome banner dialog if configured to not show on start', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { welcomeBanner: { showOnFirstStart: false } } }))
    component.ngOnInit()
    expect(dialog.open).not.toHaveBeenCalled()
  })

  it('should not open the welcome banner dialog if previously dismissed', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { welcomeBanner: { showOnFirstStart: true } } }))
    cookieService.put('welcomebanner_status', 'dismiss')
    component.ngOnInit()
    expect(dialog.open).not.toHaveBeenCalled()
  })
})


/* ===== FILE: ./frontend/src/app/welcome/welcome.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Component, type OnInit } from '@angular/core'
import { ConfigurationService } from '../Services/configuration.service'
import { MatDialog } from '@angular/material/dialog'
import { WelcomeBannerComponent } from '../welcome-banner/welcome-banner.component'
import { CookieService } from 'ngy-cookie'

@Component({
  selector: 'app-welcome',
  templateUrl: 'welcome.component.html',
  styleUrls: ['./welcome.component.scss'],
  standalone: true
})

export class WelcomeComponent implements OnInit {
  private readonly welcomeBannerStatusCookieKey = 'welcomebanner_status'

  constructor (private readonly dialog: MatDialog, private readonly configurationService: ConfigurationService, private readonly cookieService: CookieService) { }

  ngOnInit (): void {
    const welcomeBannerStatus = this.cookieService.get(this.welcomeBannerStatusCookieKey)
    if (welcomeBannerStatus !== 'dismiss') {
      this.configurationService.getApplicationConfiguration().subscribe((config: any) => {
        if (config?.application?.welcomeBanner && !config.application.welcomeBanner.showOnFirstStart) {
          return
        }
        this.dialog.open(WelcomeBannerComponent, {
          minWidth: '320px',
          width: '35%',
          position: {
            top: '50px'
          }
        })
      }, (err) => { console.log(err) })
    }
  }
}


/* ===== FILE: ./frontend/src/app/app.module.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { NgModule } from '@angular/core'
import { type HttpClient } from '@angular/common/http'
import { OverlayContainer } from '@angular/cdk/overlay'
import { TranslateHttpLoader } from '@ngx-translate/http-loader'
import { ConfigurationService } from './Services/configuration.service'

export function HttpLoaderFactory (http: HttpClient) {
  return new TranslateHttpLoader(http, './assets/i18n/', '.json')
}

@NgModule(/* TODO(standalone-migration): clean up removed NgModule class manually.
{
    declarations: [AppComponent],
    imports: [
    BrowserModule,
    Routing,
    TranslateModule.forRoot({
        loader: {
            provide: TranslateLoader,
            useFactory: HttpLoaderFactory,
            deps: [HttpClient]
        }
    }),
    CookieModule.forRoot(),
    MatPasswordStrengthModule.forRoot(),
    FlexLayoutModule,
    HttpClientModule,
    ReactiveFormsModule,
    BrowserAnimationsModule,
    GalleryModule,
    NgxTextDiffModule,
    QrCodeModule,
    FileUploadModule,
    ClipboardModule,
    MatToolbarModule,
    MatIconModule,
    FormsModule,
    MatFormFieldModule,
    MatSelectModule,
    MatButtonModule,
    MatSidenavModule,
    MatRippleModule,
    MatTableModule,
    MatPaginatorModule,
    MatCardModule,
    MatInputModule,
    MatCheckboxModule,
    MatDialogModule,
    MatDividerModule,
    MatDatepickerModule,
    MatNativeDateModule,
    MatExpansionModule,
    MatProgressBarModule,
    MatTooltipModule,
    MatMenuModule,
    MatListModule,
    MatButtonToggleModule,
    LayoutModule,
    MatGridListModule,
    MatBadgeModule,
    MatRadioModule,
    MatSnackBarModule,
    MatSliderModule,
    MatTabsModule,
    MatSlideToggleModule,
    MatChipsModule,
    MatAutocompleteModule,
    HighlightModule,
    AboutComponent,
    AdministrationComponent,
    BasketComponent,
    LoginComponent,
    NavbarComponent,
    WelcomeComponent,
    WelcomeBannerComponent,
    SearchResultComponent,
    ForgotPasswordComponent,
    RegisterComponent,
    ContactComponent,
    ChangePasswordComponent,
    ProductDetailsComponent,
    ComplaintComponent,
    ChatbotComponent,
    TrackResultComponent,
    RecycleComponent,
    QrCodeComponent,
    UserDetailsComponent,
    ServerStartedNotificationComponent,
    ChallengeSolvedNotificationComponent,
    OAuthComponent,
    TokenSaleComponent,
    NFTUnlockComponent,
    ProductReviewEditComponent,
    TwoFactorAuthEnterComponent,
    SidenavComponent,
    PrivacySecurityComponent,
    ErrorPageComponent,
    TwoFactorAuthComponent,
    DataExportComponent,
    LastLoginIpComponent,
    PrivacyPolicyComponent,
    OrderCompletionComponent,
    AddressCreateComponent,
    AddressSelectComponent,
    AddressComponent,
    SavedAddressComponent,
    PaymentComponent,
    PaymentMethodComponent,
    SavedPaymentMethodsComponent,
    AccountingComponent,
    OrderSummaryComponent,
    PurchaseBasketComponent,
    PrivacyPolicyComponent,
    ChallengeStatusBadgeComponent,
    WalletComponent,
    OrderHistoryComponent,
    DeliveryMethodComponent,
    PhotoWallComponent,
    DeluxeUserComponent,
    FeedbackDetailsComponent,
    CodeSnippetComponent,
    CodeAreaComponent,
    CodeFixesComponent,
    MatSearchBarComponent
],
    schemas: [CUSTOM_ELEMENTS_SCHEMA],
    providers: [
        {
            provide: HTTP_INTERCEPTORS,
            useClass: RequestInterceptor,
            multi: true
        },
        {
            provide: HIGHLIGHT_OPTIONS,
            useValue: {
                coreLibraryLoader: async () => await import('highlight.js/lib/core'),
                lineNumbersLoader: async () => await import('highlightjs-line-numbers.js'),
                languages: {
                    typescript: async () => await import('highlight.js/lib/languages/typescript'),
                    javascript: async () => await import('highlight.js/lib/languages/javascript'),
                    yaml: async () => await import('highlight.js/lib/languages/yaml')
                }
            }
        },
        ProductService,
        ConfigurationService,
        AdministrationService,
        SecurityQuestionService,
        DataSubjectService,
        UserService,
        SecurityAnswerService,
        CaptchaService,
        FeedbackService,
        WindowRefService,
        ProductReviewService,
        ComplaintService,
        ChatbotService,
        TrackOrderService,
        RecycleService,
        BasketService,
        ChallengeService,
        CookieService,
        AdminGuard,
        LoginGuard,
        PaymentService,
        AccountingGuard,
        DeluxeGuard,
        ImageCaptchaService,
        KeysService,
        AddressService,
        QuantityService,
        WalletService,
        OrderHistoryService,
        DeliveryService,
        PhotoWallService
    ],
    bootstrap: [AppComponent]
} */)
export class AppModule {
  constructor (public configurationService: ConfigurationService, public overlayContainer: OverlayContainer) {
    configurationService.getApplicationConfiguration().subscribe((conf) => {
      overlayContainer.getContainerElement().classList.add(conf.application.theme + '-theme')
    })
  }
}


/* ===== FILE: ./frontend/src/app/qr-code/qr-code.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<div class="qr-code">

  <header>
    <h3>{{title | translate}}</h3>
  </header>

  <div fxLayout="column" fxLayoutGap="10px">

  <mat-divider></mat-divider>

  <div class="container">
    <a [href]="url"><qr-code [value]="data" [size]="300" [errorCorrectionLevel]="'M'"></qr-code></a>
  </div>

  <small>{{address}}</small>

  </div>

  <footer>
    <button mat-raised-button mat-dialog-close class="close-dialog"><i class="fas fa-arrow-circle-left fa-lg"></i> {{'BTN_CLOSE' | translate}}</button>
  </footer>

</div>


/* ===== FILE: ./frontend/src/app/qr-code/qr-code.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { MAT_DIALOG_DATA, MatDialogModule } from '@angular/material/dialog'
import { MatDividerModule } from '@angular/material/divider'
import { type ComponentFixture, TestBed, waitForAsync } from '@angular/core/testing'

import { TranslateModule } from '@ngx-translate/core'
import { QrCodeComponent } from './qr-code.component'
import { MatButtonModule } from '@angular/material/button'
import { QrCodeModule } from 'ng-qrcode'

describe('QrCodeComponent', () => {
  let component: QrCodeComponent
  let fixture: ComponentFixture<QrCodeComponent>

  beforeEach(waitForAsync(() => {
    TestBed.configureTestingModule({
      imports: [
        TranslateModule.forRoot(),
        QrCodeModule,
        MatDividerModule,
        MatButtonModule,
        MatDialogModule,
        QrCodeComponent
      ],
      providers: [
        { provide: MAT_DIALOG_DATA, useValue: { data: 'data', url: 'url', address: 'address', title: 'title' } }
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(QrCodeComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
    component.ngOnInit()
    expect(component.title).toBe('title')
    expect(component.url).toBe('url')
    expect(component.address).toBe('address')
    expect(component.data).toBe('data')
  })
})


/* ===== FILE: ./frontend/src/app/qr-code/qr-code.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { MAT_DIALOG_DATA, MatDialogClose } from '@angular/material/dialog'
import { Component, Inject, type OnInit } from '@angular/core'
import { library } from '@fortawesome/fontawesome-svg-core'
import { faArrowCircleLeft } from '@fortawesome/free-solid-svg-icons'
import { TranslateModule } from '@ngx-translate/core'
import { MatButtonModule } from '@angular/material/button'
import { QrCodeModule } from 'ng-qrcode'
import { MatDivider } from '@angular/material/divider'
import { FlexModule } from '@angular/flex-layout/flex'

library.add(faArrowCircleLeft)

@Component({
  selector: 'app-qr-code',
  templateUrl: './qr-code.component.html',
  styleUrls: ['./qr-code.component.scss'],
  imports: [FlexModule, MatDivider, QrCodeModule, MatButtonModule, MatDialogClose, TranslateModule]
})
export class QrCodeComponent implements OnInit {
  public title!: string
  public url!: string
  public address!: string
  public data!: string
  constructor (@Inject(MAT_DIALOG_DATA) public dialogData: any) { }

  ngOnInit (): void {
    this.title = this.dialogData.title
    this.url = this.dialogData.url
    this.address = this.dialogData.address
    this.data = this.dialogData.data
  }
}


/* ===== FILE: ./frontend/src/app/app.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Component, Inject } from '@angular/core'
import { TranslateService } from '@ngx-translate/core'
import { DOCUMENT } from '@angular/common'
import { dom } from '@fortawesome/fontawesome-svg-core'
import { RouterOutlet } from '@angular/router'
import { WelcomeComponent } from './welcome/welcome.component'
import { ChallengeSolvedNotificationComponent } from './challenge-solved-notification/challenge-solved-notification.component'
import { ServerStartedNotificationComponent } from './server-started-notification/server-started-notification.component'
import { NavbarComponent } from './navbar/navbar.component'
import { SidenavComponent } from './sidenav/sidenav.component'
import { MatSidenavContainer, MatSidenav } from '@angular/material/sidenav'

dom.watch()

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.scss'],
  imports: [MatSidenavContainer, MatSidenav, SidenavComponent, NavbarComponent, ServerStartedNotificationComponent, ChallengeSolvedNotificationComponent, WelcomeComponent, RouterOutlet]
})
export class AppComponent {
  constructor (@Inject(DOCUMENT) private readonly _document: HTMLDocument, private readonly translate: TranslateService) {
    this.translate.setDefaultLang('en')
  }
}


/* ===== FILE: ./frontend/src/app/code-area/code-area.component.spec.ts ===== */

import { type ComponentFixture, TestBed } from '@angular/core/testing'
import { TranslateModule } from '@ngx-translate/core'

import { CodeAreaComponent } from './code-area.component'

describe('CodeAreaComponent', () => {
  let component: CodeAreaComponent
  let fixture: ComponentFixture<CodeAreaComponent>

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [
        TranslateModule.forRoot(),
        CodeAreaComponent
      ]
    })
      .compileComponents()
  })

  beforeEach(() => {
    fixture = TestBed.createComponent(CodeAreaComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should generate unchecked markers for each line of the code snippet', () => {
    component.code = 'Line 1\nLine2\nLine3'
    component.ngOnInit()
    expect(component.lineMarkers).toEqual([{ lineNumber: 1, marked: false }, { lineNumber: 2, marked: false }, { lineNumber: 3, marked: false }])
  })

  it('should emit selected line of code when no lines were previously selected', () => {
    component.addLine = jasmine.createSpyObj(['emit'])
    component.lineMarkers = [{ lineNumber: 1, marked: false }, { lineNumber: 2, marked: false }, { lineNumber: 3, marked: false }]
    component.selectLines(2)
    expect(component.addLine.emit).toHaveBeenCalledWith([2])
  })

  it('should emit selected line of code including previously selected lines', () => {
    component.addLine = jasmine.createSpyObj(['emit'])
    component.lineMarkers = [{ lineNumber: 1, marked: true }, { lineNumber: 2, marked: false }, { lineNumber: 3, marked: false }]
    component.selectLines(2)
    expect(component.addLine.emit).toHaveBeenCalledWith([1, 2])
  })

  it('should emit selected lines of code minus a deselected one', () => {
    component.addLine = jasmine.createSpyObj(['emit'])
    component.lineMarkers = [{ lineNumber: 1, marked: true }, { lineNumber: 2, marked: true }, { lineNumber: 3, marked: true }]
    component.selectLines(2)
    expect(component.addLine.emit).toHaveBeenCalledWith([1, 3])
  })
})


/* ===== FILE: ./frontend/src/app/code-area/code-area.component.ts ===== */

import {
  Component,
  type OnInit,
  Input,
  Output,
  EventEmitter
} from '@angular/core'
import { HighlightModule } from 'ngx-highlightjs'
import { NgFor } from '@angular/common'

interface LineMarker {
  marked: boolean
  lineNumber: number
}

@Component({
  selector: 'app-code-area',
  templateUrl: './code-area.component.html',
  styleUrls: ['./code-area.component.scss'],
  imports: [NgFor, HighlightModule]
})
export class CodeAreaComponent implements OnInit {
  private _code: string = ''
  @Input('code')
  get code (): string {
    return this._code
  }

  set code (value: string) {
    this._code = value || ''
  }

  @Input('vulnLines')
  public vulnLines: number[]

  public lineMarkers: LineMarker[]

  @Output()
    addLine = new EventEmitter<number[]>()

  public langs = ['javascript', 'typescript', 'json', 'yaml']

  ngOnInit (): void {
    this.lineMarkers = this.code.split('\n').map((line, lineIndex) => {
      return {
        lineNumber: lineIndex + 1,
        marked: false
      }
    })
  }

  selectLines (lineNumber): void {
    // need to get the marker from index lineNumber - 1 as the array index start at 0, while the lineNumbers start at 1
    const marker = this.lineMarkers[lineNumber - 1]
    marker.marked = !marker.marked

    // convert lineMarkers to array of markedLineNumber
    const markedLineNumbers: number[] = []
    for (const { marked, lineNumber } of this.lineMarkers) {
      if (marked) {
        markedLineNumbers.push(lineNumber)
      }
    }
    this.addLine.emit(markedLineNumbers)
  }
}


/* ===== FILE: ./frontend/src/app/code-area/code-area.component.html ===== */

<div id="code-area">
  <pre id="code"><div id="emphasize"><div *ngFor="let marker of lineMarkers" class="lineMarker" [id]="'line' + marker.lineNumber" (click)="selectLines(marker.lineNumber)">{{ marker.marked ? '✅' : '🔲'}}</div>
  </div><code
    [highlight]="code" [lineNumbers]="true"
    [languages]="langs"
    ></code></pre>
</div>

/* ===== FILE: ./frontend/src/app/complaint/complaint.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { environment } from '../../environments/environment'
import { ComplaintService } from '../Services/complaint.service'
import { UserService } from '../Services/user.service'
import { Component, ElementRef, type OnInit, ViewChild } from '@angular/core'
import { UntypedFormControl, Validators, FormsModule, ReactiveFormsModule } from '@angular/forms'
import { FileUploader, FileUploadModule } from 'ng2-file-upload'
import { library } from '@fortawesome/fontawesome-svg-core'
import { faBomb } from '@fortawesome/free-solid-svg-icons'
import { FormSubmitService } from '../Services/form-submit.service'
import { TranslateService, TranslateModule } from '@ngx-translate/core'
import { MatButtonModule } from '@angular/material/button'
import { MatInputModule } from '@angular/material/input'
import { MatFormFieldModule, MatLabel, MatHint, MatError } from '@angular/material/form-field'
import { NgIf } from '@angular/common'
import { MatCardModule } from '@angular/material/card'
import { FlexModule } from '@angular/flex-layout/flex'
import { MatIconModule } from '@angular/material/icon'

library.add(faBomb)

@Component({
  selector: 'app-complaint',
  templateUrl: './complaint.component.html',
  styleUrls: ['./complaint.component.scss'],
  imports: [FlexModule, MatCardModule, TranslateModule, NgIf, MatFormFieldModule, MatLabel, MatInputModule, FormsModule, ReactiveFormsModule, MatHint, MatError, FileUploadModule, MatButtonModule, MatIconModule]
})
export class ComplaintComponent implements OnInit {
  public customerControl: UntypedFormControl = new UntypedFormControl({ value: '', disabled: true }, [])
  public messageControl: UntypedFormControl = new UntypedFormControl('', [Validators.required, Validators.maxLength(160)])
  @ViewChild('fileControl', { static: true }) fileControl!: ElementRef // For controlling the DOM Element for file input.
  public fileUploadError: any = undefined // For controlling error handling related to file input.
  public uploader: FileUploader = new FileUploader({
    url: environment.hostServer + '/file-upload',
    authToken: `Bearer ${localStorage.getItem('token')}`,
    allowedMimeType: ['application/pdf', 'application/xml', 'text/xml', 'application/zip', 'application/x-zip-compressed', 'multipart/x-zip', 'application/yaml', 'application/x-yaml', 'text/yaml', 'text/x-yaml'],
    maxFileSize: 100000
  })

  public userEmail: any = undefined
  public complaint: any = undefined
  public confirmation: any

  constructor (private readonly userService: UserService, private readonly complaintService: ComplaintService, private readonly formSubmitService: FormSubmitService, private readonly translate: TranslateService) { }

  ngOnInit (): void {
    this.initComplaint()
    this.uploader.onWhenAddingFileFailed = (item, filter) => {
      this.fileUploadError = filter
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      throw new Error(`Error due to : ${filter.name}`)
    }
    this.uploader.onAfterAddingFile = () => {
      this.fileUploadError = undefined
    }
    this.uploader.onSuccessItem = () => {
      this.saveComplaint()
      this.uploader.clearQueue()
    }
    this.formSubmitService.attachEnterKeyHandler('complaint-form', 'submitButton', () => { this.save() })
  }

  initComplaint () {
    this.userService.whoAmI().subscribe((user: any) => {
      this.complaint = {}
      this.complaint.UserId = user.id
      this.userEmail = user.email
      this.customerControl.setValue(this.userEmail)
    }, (err) => {
      this.complaint = undefined
      console.log(err)
    })
  }

  save () {
    if (this.uploader.queue[0]) {
      this.uploader.queue[0].upload()
      this.fileControl.nativeElement.value = null
    } else {
      this.saveComplaint()
    }
  }

  saveComplaint () {
    this.complaint.message = this.messageControl.value
    this.complaintService.save(this.complaint).subscribe((savedComplaint: any) => {
      this.translate.get('CUSTOMER_SUPPORT_COMPLAINT_REPLY', { ref: savedComplaint.id }).subscribe((customerSupportReply) => {
        this.confirmation = customerSupportReply
      }, (translationId) => {
        this.confirmation = translationId
      })
      this.initComplaint()
      this.resetForm()
      this.fileUploadError = undefined
    }, (error) => error)
  }

  resetForm () {
    this.messageControl.setValue('')
    this.messageControl.markAsUntouched()
    this.messageControl.markAsPristine()
    this.fileControl.nativeElement.value = null
  }
}


/* ===== FILE: ./frontend/src/app/complaint/complaint.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { ComplaintService } from '../Services/complaint.service'
import { UserService } from '../Services/user.service'
import { ReactiveFormsModule } from '@angular/forms'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'
import { MatCardModule } from '@angular/material/card'
import { MatFormFieldModule } from '@angular/material/form-field'
import { FileItem, FileUploadModule } from 'ng2-file-upload'
import { TranslateModule, TranslateService } from '@ngx-translate/core'
import { MatInputModule } from '@angular/material/input'
import { MatButtonModule } from '@angular/material/button'

import { type ComponentFixture, fakeAsync, TestBed, waitForAsync } from '@angular/core/testing'
import { ComplaintComponent } from './complaint.component'
import { of, throwError } from 'rxjs'

import { provideHttpClientTesting } from '@angular/common/http/testing'
import { EventEmitter } from '@angular/core'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('ComplaintComponent', () => {
  let component: ComplaintComponent
  let fixture: ComponentFixture<ComplaintComponent>
  let userService: any
  let complaintService: any
  let translateService

  beforeEach(waitForAsync(() => {
    userService = jasmine.createSpyObj('UserService', ['whoAmI'])
    userService.whoAmI.and.returnValue(of({}))
    complaintService = jasmine.createSpyObj('ComplaintService', ['save'])
    complaintService.save.and.returnValue(of({}))
    translateService = jasmine.createSpyObj('TranslateService', ['get'])
    translateService.get.and.returnValue(of({}))
    translateService.onLangChange = new EventEmitter()
    translateService.onTranslationChange = new EventEmitter()
    translateService.onDefaultLangChange = new EventEmitter()

    TestBed.configureTestingModule({
      imports: [ReactiveFormsModule,
        FileUploadModule,
        TranslateModule.forRoot(),
        BrowserAnimationsModule,
        MatCardModule,
        MatFormFieldModule,
        MatInputModule,
        MatButtonModule,
        ComplaintComponent],
      providers: [
        { provide: UserService, useValue: userService },
        { provide: ComplaintService, useValue: complaintService },
        { provide: TranslateService, useValue: translateService },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(ComplaintComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should have customerControl as disabled', () => {
    expect(component.customerControl.disabled).toBe(true)
  })

  it('should be compulsory to provide a message', () => {
    component.messageControl.setValue('')
    expect(component.messageControl.valid).toBeFalsy()
    component.messageControl.setValue('aa')
    expect(component.messageControl.valid).toBe(true)
  })

  it('should have a message of maximum 160 characters', () => {
    let str: string = ''
    for (let i = 0; i < 161; i++) {
      str += 'a'
    }
    component.messageControl.setValue(str)
    expect(component.messageControl.valid).toBeFalsy()
    str = str.slice(1)
    component.messageControl.setValue(str)
    expect(component.messageControl.valid).toBe(true)
  })

  it('should reset form by calling resetForm', () => {
    component.messageControl.setValue('Message')
    component.resetForm()
    expect(component.messageControl.pristine).toBe(true)
    expect(component.messageControl.untouched).toBe(true)
    expect(component.messageControl.value).toBe('')
  })

  it('should miss complaint object if retrieving currently logged in user fails', fakeAsync(() => {
    userService.whoAmI.and.returnValue(throwError('Error'))
    component.ngOnInit()
    expect(component.complaint).toBeUndefined()
  }))

  it('should hold the user email of the currently logged in user', () => {
    userService.whoAmI.and.returnValue(of({ email: 'x@x.xx' }))
    component.ngOnInit()
    expect(component.userEmail).toBe('x@x.xx')
  })

  it('should hold no email if current user is not logged in', () => {
    userService.whoAmI.and.returnValue(of({}))
    component.ngOnInit()
    expect(component.userEmail).toBeUndefined()
    expect(component.customerControl.value).toBeUndefined()
  })

  it('should display support message with #id and reset complaint form on saving complaint', () => {
    complaintService.save.and.returnValue(of({ id: 42 }))
    translateService.get.and.returnValue(of('CUSTOMER_SUPPORT_COMPLAINT_REPLY'))
    component.uploader.queue[0] = null as unknown as FileItem
    component.save()
    expect(translateService.get).toHaveBeenCalledWith('CUSTOMER_SUPPORT_COMPLAINT_REPLY', { ref: 42 })
  })

  it('should begin uploading file if it has been added on saving', fakeAsync(() => {
    component.uploader.queue[0] = new FileItem(component.uploader, new File([''], 'file.pdf', { type: 'application/pdf' }), { url: '' })
    spyOn(component.uploader.queue[0], 'upload')
    component.save()
    expect(component.uploader.queue[0].upload).toHaveBeenCalled()
  }))
})


/* ===== FILE: ./frontend/src/app/complaint/complaint.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<div fxLayoutAlign="center">
  <mat-card appearance="outlined" class="mat-elevation-z6">
    <div class="mdc-card">

      <h1>{{"NAV_COMPLAIN" | translate}}</h1>

      <div class="confirmation" [hidden]="!(confirmation && !messageControl.dirty)">{{ confirmation }}</div>

      <div class="error fileUploadError" *ngIf="(fileUploadError && fileUploadError.name == 'mimeType')">{{
        "INVALID_FILE_TYPE" | translate: { type: 'PDF, ZIP' } }}
      </div>
      <div class="error fileUploadError" *ngIf="(fileUploadError && fileUploadError.name == 'fileSize')">{{
        "INVALID_FILE_SIZE" | translate: { size: '100 KB' } }}
      </div>

      <div class="form-container" id="complaint-form">

        <mat-form-field appearance="outline" color="accent">
          <mat-label >{{"LABEL_CUSTOMER" | translate }}</mat-label>
          <input [formControl]="customerControl" type="text" matInput aria-label="Text field for the mail address of the user">
        </mat-form-field>

        <mat-form-field appearance="outline" color="accent">
          <mat-label>{{"LABEL_MESSAGE" | translate}}</mat-label>
          <mat-hint>
            <i class="fas fa-exclamation-circle"></i>
            <em style="margin-left:5px;">{{ 'MAX_TEXTAREA_LENGTH' | translate: {length: '160'} }}</em>
          </mat-hint>
          <textarea #complaintMessage id="complaintMessage" [formControl]="messageControl" matAutosizeMinRows="4" matAutosizeMaxRows="4"
                    matTextareaAutosize cols="50" maxlength="160" matInput
                    placeholder="{{ 'WRITE_MESSAGE_PLACEHOLDER' | translate}}"
                    aria-label="Field for entering the complaint"></textarea>
          <mat-error *ngIf="messageControl.invalid && messageControl?.errors.required">{{"MANDATORY_MESSAGE" |
            translate}}
          </mat-error>
          <mat-hint align="end">{{complaintMessage.value?.length || 0}}/160</mat-hint>
        </mat-form-field>

        <div class="invoice">
          <label for="file">{{"LABEL_INVOICE" | translate }}<span>:</span></label>
          <input #fileControl ng2FileSelect [uploader]="uploader" id="file" type="file" accept=".pdf,.zip" style="margin-left: 10px;" aria-label="Input area for uploading a single invoice PDF or XML B2B order file or a ZIP archive containing multiple invoices or orders<!---->">
        </div>

      </div>

      <button type="submit" id="submitButton" [disabled]="messageControl.invalid || fileUploadError" (click)="save()"
              mat-raised-button color="primary" aria-label="Button to send the complaint">
        <mat-icon>
          send
        </mat-icon>
        {{'BTN_SUBMIT' | translate}}
      </button>

    </div>
  </mat-card>
</div>


/* ===== FILE: ./frontend/src/app/app.guard.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { inject, TestBed } from '@angular/core/testing'
import { AccountingGuard, AdminGuard, DeluxeGuard, LoginGuard } from './app.guard'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { RouterTestingModule } from '@angular/router/testing'
import { ErrorPageComponent } from './error-page/error-page.component'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('LoginGuard', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [RouterTestingModule.withRoutes([
        { path: '403', component: ErrorPageComponent }
      ])],
      providers: [LoginGuard, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
  })

  it('should be created', inject([LoginGuard], (guard: LoginGuard) => {
    expect(guard).toBeTruthy()
  }))

  it('should open for authenticated users', inject([LoginGuard], (guard: LoginGuard) => {
    localStorage.setItem('token', 'TOKEN')
    expect(guard.canActivate()).toBeTrue()
  }))

  it('should close for anonymous users', inject([LoginGuard], (guard: LoginGuard) => {
    localStorage.removeItem('token')
    expect(guard.canActivate()).toBeFalse()
  }))

  it('returns payload from decoding a valid JWT', inject([LoginGuard], (guard: LoginGuard) => {
    localStorage.setItem('token', 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c')
    expect(guard.tokenDecode()).toEqual({
      sub: '1234567890',
      name: 'John Doe',
      iat: 1516239022
    })
  }))

  it('returns nothing when decoding an invalid JWT', inject([LoginGuard], (guard: LoginGuard) => {
    localStorage.setItem('token', '12345.abcde')
    expect(guard.tokenDecode()).toBeNull()
  }))

  it('returns nothing when decoding an non-existing JWT', inject([LoginGuard], (guard: LoginGuard) => {
    localStorage.removeItem('token')
    expect(guard.tokenDecode()).toBeNull()
  }))
})

describe('AdminGuard', () => {
  let loginGuard: any

  beforeEach(() => {
    loginGuard = jasmine.createSpyObj('LoginGuard', ['tokenDecode', 'forbidRoute'])

    TestBed.configureTestingModule({
      imports: [RouterTestingModule.withRoutes([
        { path: '403', component: ErrorPageComponent }
      ])],
      providers: [
        AdminGuard,
        { provide: LoginGuard, useValue: loginGuard },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
  })

  it('should be created', inject([AdminGuard], (guard: AdminGuard) => {
    expect(guard).toBeTruthy()
  }))

  it('should open for admins', inject([AdminGuard], (guard: AdminGuard) => {
    loginGuard.tokenDecode.and.returnValue({ data: { role: 'admin' } })
    expect(guard.canActivate()).toBeTrue()
  }))

  it('should close for regular customers', inject([AdminGuard], (guard: AdminGuard) => {
    loginGuard.tokenDecode.and.returnValue({ data: { role: 'customer' } })
    expect(guard.canActivate()).toBeFalse()
    expect(loginGuard.forbidRoute).toHaveBeenCalled()
  }))

  it('should close for deluxe customers', inject([AdminGuard], (guard: AdminGuard) => {
    loginGuard.tokenDecode.and.returnValue({ data: { role: 'deluxe' } })
    expect(guard.canActivate()).toBeFalse()
    expect(loginGuard.forbidRoute).toHaveBeenCalled()
  }))

  it('should close for accountants', inject([AdminGuard], (guard: AdminGuard) => {
    loginGuard.tokenDecode.and.returnValue({ data: { role: 'accounting' } })
    expect(guard.canActivate()).toBeFalse()
    expect(loginGuard.forbidRoute).toHaveBeenCalled()
  }))
})

describe('AccountingGuard', () => {
  let loginGuard: any

  beforeEach(() => {
    loginGuard = jasmine.createSpyObj('LoginGuard', ['tokenDecode', 'forbidRoute'])

    TestBed.configureTestingModule({
      imports: [RouterTestingModule.withRoutes([
        { path: '403', component: ErrorPageComponent }
      ])],
      providers: [
        AccountingGuard,
        { provide: LoginGuard, useValue: loginGuard },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
  })

  it('should be created', inject([AccountingGuard], (guard: AccountingGuard) => {
    expect(guard).toBeTruthy()
  }))

  it('should open for accountants', inject([AccountingGuard], (guard: AccountingGuard) => {
    loginGuard.tokenDecode.and.returnValue({ data: { role: 'accounting' } })
    expect(guard.canActivate()).toBeTrue()
  }))

  it('should close for regular customers', inject([AccountingGuard], (guard: AccountingGuard) => {
    loginGuard.tokenDecode.and.returnValue({ data: { role: 'customer' } })
    expect(guard.canActivate()).toBeFalse()
    expect(loginGuard.forbidRoute).toHaveBeenCalled()
  }))

  it('should close for deluxe customers', inject([AccountingGuard], (guard: AccountingGuard) => {
    loginGuard.tokenDecode.and.returnValue({ data: { role: 'deluxe' } })
    expect(guard.canActivate()).toBeFalse()
    expect(loginGuard.forbidRoute).toHaveBeenCalled()
  }))

  it('should close for admins', inject([AccountingGuard], (guard: AccountingGuard) => {
    loginGuard.tokenDecode.and.returnValue({ data: { role: 'admin' } })
    expect(guard.canActivate()).toBeFalse()
    expect(loginGuard.forbidRoute).toHaveBeenCalled()
  }))
})

describe('DeluxeGuard', () => {
  let loginGuard: any

  beforeEach(() => {
    loginGuard = jasmine.createSpyObj('LoginGuard', ['tokenDecode'])

    TestBed.configureTestingModule({
      imports: [RouterTestingModule.withRoutes([
        { path: '403', component: ErrorPageComponent }
      ])],
      providers: [
        DeluxeGuard,
        { provide: LoginGuard, useValue: loginGuard },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
  })

  it('should be created', inject([DeluxeGuard], (guard: DeluxeGuard) => {
    expect(guard).toBeTruthy()
  }))

  it('should open for deluxe customers', inject([DeluxeGuard], (guard: DeluxeGuard) => {
    loginGuard.tokenDecode.and.returnValue({ data: { role: 'deluxe' } })
    expect(guard.isDeluxe()).toBeTrue()
  }))

  it('should close for regular customers', inject([DeluxeGuard], (guard: DeluxeGuard) => {
    loginGuard.tokenDecode.and.returnValue({ data: { role: 'customer' } })
    expect(guard.isDeluxe()).toBeFalse()
  }))

  it('should close for admins', inject([DeluxeGuard], (guard: DeluxeGuard) => {
    loginGuard.tokenDecode.and.returnValue({ data: { role: 'admin' } })
    expect(guard.isDeluxe()).toBeFalse()
  }))

  it('should close for accountants', inject([DeluxeGuard], (guard: DeluxeGuard) => {
    loginGuard.tokenDecode.and.returnValue({ data: { role: 'accounting' } })
    expect(guard.isDeluxe()).toBeFalse()
  }))
})


/* ===== FILE: ./frontend/src/app/error-page/error-page.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<mat-card appearance="outlined" class="warn-notification mat-elevation-z6">
  <div class="mdc-card">
    <div class="mat-headline-2"><i class="fas fa-hand-paper"></i> 403</div>
    <span class="mat-subtitle-1">{{error}}</span>
  </div>
</mat-card>


/* ===== FILE: ./frontend/src/app/error-page/error-page.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type ComponentFixture, TestBed, waitForAsync } from '@angular/core/testing'
import { MatCardModule } from '@angular/material/card'

import { ErrorPageComponent } from './error-page.component'
import { ActivatedRoute } from '@angular/router'
import { TranslateModule } from '@ngx-translate/core'

describe('ErrorPageComponent', () => {
  let component: ErrorPageComponent
  let fixture: ComponentFixture<ErrorPageComponent>

  beforeEach(waitForAsync(() => {
    TestBed.configureTestingModule({
      imports: [
        TranslateModule.forRoot(),
        MatCardModule,
        ErrorPageComponent
      ],
      providers: [
        {
          provide: ActivatedRoute,
          useValue: { snapshot: { queryParams: { error: 'UNAUTHORIZED_PAGE_ACCESS_ERROR' } } }
        }
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(ErrorPageComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })
})


/* ===== FILE: ./frontend/src/app/error-page/error-page.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateService } from '@ngx-translate/core'
import { Component, type OnInit } from '@angular/core'
import { ActivatedRoute } from '@angular/router'
import { library } from '@fortawesome/fontawesome-svg-core'
import { faUserSlash, faHandPaper } from '@fortawesome/free-solid-svg-icons'
import { MatCardModule } from '@angular/material/card'

library.add(faUserSlash, faHandPaper)

@Component({
  selector: 'app-error-page',
  templateUrl: './error-page.component.html',
  styleUrls: ['./error-page.component.scss'],
  imports: [MatCardModule]
})
export class ErrorPageComponent implements OnInit {
  public error: string | null = null

  constructor (private readonly route: ActivatedRoute, private readonly translate: TranslateService) {
  }

  ngOnInit (): void {
    const errorKey = this.route.snapshot.queryParams.error
    if (errorKey) {
      this.translate.get(errorKey).subscribe((errorMessage) => {
        this.error = errorMessage
      }, (translationId) => {
        this.error = translationId
      })
    }
  }
}


/* ===== FILE: ./frontend/src/app/register/register.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { LoginComponent } from '../login/login.component'
import { SecurityAnswerService } from '../Services/security-answer.service'
import { UserService } from '../Services/user.service'
import { SecurityQuestionService } from '../Services/security-question.service'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { type ComponentFixture, fakeAsync, flush, TestBed, tick, waitForAsync } from '@angular/core/testing'
import { RegisterComponent } from './register.component'
import { ReactiveFormsModule } from '@angular/forms'
import { RouterTestingModule } from '@angular/router/testing'
import { Location } from '@angular/common'
import { TranslateModule } from '@ngx-translate/core'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'
import { MatButtonModule } from '@angular/material/button'
import { MatSelectModule } from '@angular/material/select'
import { MatInputModule } from '@angular/material/input'
import { MatFormFieldModule } from '@angular/material/form-field'
import { MatCardModule } from '@angular/material/card'
import { MatIconModule } from '@angular/material/icon'
import { of, throwError } from 'rxjs'
import { MatCheckboxModule } from '@angular/material/checkbox'
import { MatSnackBarModule } from '@angular/material/snack-bar'
import { MatTooltipModule } from '@angular/material/tooltip'
import { MatSlideToggleModule } from '@angular/material/slide-toggle'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('RegisterComponent', () => {
  let component: RegisterComponent
  let fixture: ComponentFixture<RegisterComponent>
  let securityAnswerService: any
  let securityQuestionService: any
  let userService: any
  let location: Location

  beforeEach(waitForAsync(() => {
    securityAnswerService = jasmine.createSpyObj('SecurityAnswerService', ['save'])
    securityAnswerService.save.and.returnValue(of({}))
    securityQuestionService = jasmine.createSpyObj('SecurityQuestionService', ['find'])
    securityQuestionService.find.and.returnValue(of([{}]))
    userService = jasmine.createSpyObj('UserService', ['save'])
    userService.save.and.returnValue(of({}))
    TestBed.configureTestingModule({
      imports: [RouterTestingModule.withRoutes([
        { path: 'login', component: LoginComponent }
      ]),
      TranslateModule.forRoot(),
      ReactiveFormsModule,
      BrowserAnimationsModule,
      MatCardModule,
      MatFormFieldModule,
      MatCheckboxModule,
      MatInputModule,
      MatSelectModule,
      MatButtonModule,
      MatIconModule,
      MatSnackBarModule,
      MatTooltipModule,
      MatIconModule,
      MatSlideToggleModule,
      RegisterComponent, LoginComponent],
      providers: [
        { provide: SecurityAnswerService, useValue: securityAnswerService },
        { provide: SecurityQuestionService, useValue: securityQuestionService },
        { provide: UserService, useValue: userService },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()

    location = TestBed.inject(Location)
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(RegisterComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should be compulsory to provid email', () => {
    component.emailControl.setValue('')
    expect(component.emailControl.valid).toBeFalsy()
  })

  it('email field should be of proper format', () => {
    component.emailControl.setValue('email')
    expect(component.emailControl.valid).toBeFalsy()
    component.emailControl.setValue('x@x.xx')
    expect(component.emailControl.valid).toBe(true)
  })

  it('should be compulsory to provide password', () => {
    component.passwordControl.setValue('')
    expect(component.passwordControl.valid).toBeFalsy()
  })

  it('password should have at least five characters', () => {
    component.passwordControl.setValue('aaaa')
    expect(component.passwordControl.valid).toBeFalsy()
    component.passwordControl.setValue('aaaaa')
    expect(component.passwordControl.valid).toBe(true)
  })

  it('password should not be more than 20 characters', () => {
    let password: string = ''
    for (let i = 0; i < 41; i++) {
      password += 'a'
    }
    component.passwordControl.setValue(password)
    expect(component.passwordControl.valid).toBeFalsy()
    password = password.slice(1)
    component.passwordControl.setValue(password)
    expect(component.passwordControl.valid).toBe(true)
  })

  it('should be compulsory to repeat the password', () => {
    component.passwordControl.setValue('a')
    component.repeatPasswordControl.setValue('')
    expect(component.repeatPasswordControl.valid).toBeFalsy()
    component.repeatPasswordControl.setValue('a')
    expect(component.repeatPasswordControl.valid).toBe(true)
  })

  it('password and repeat password should be the same', () => {
    const password: string = 'aaaaa'
    const passwordRepeat: string = 'aaaaa'
    component.passwordControl.setValue(password)
    component.repeatPasswordControl.setValue('bbbbb')
    expect(component.repeatPasswordControl.valid).toBeFalsy()
    component.repeatPasswordControl.setValue(passwordRepeat)
    expect(component.repeatPasswordControl.valid).toBe(true)
  })

  it('redirects to login page after user registration', fakeAsync(() => {
    userService.save.and.returnValue(of({ id: 1, question: 'Wat is?' }))
    securityAnswerService.save.and.returnValue(of({}))
    component.securityQuestions = [{ id: 1, question: 'Wat is?' }]
    component.emailControl.setValue('x@x.xx')
    component.passwordControl.setValue('password')
    component.repeatPasswordControl.setValue('password')
    component.securityQuestionControl.setValue(1)
    component.securityAnswerControl.setValue('Answer')
    const user = { email: 'x@x.xx', password: 'password', passwordRepeat: 'password', securityQuestion: { id: 1, question: 'Wat is?' }, securityAnswer: 'Answer' }
    const securityAnswerObject = { UserId: 1, answer: 'Answer', SecurityQuestionId: 1 }
    component.save()
    tick()
    expect(userService.save.calls.argsFor(0)[0]).toEqual(user)
    expect(securityAnswerService.save.calls.argsFor(0)[0]).toEqual(securityAnswerObject)
    expect(location.path()).toBe('/login')
    fixture.destroy()
    flush()
  }))

  it('loading secret questions', () => {
    securityQuestionService.find.and.returnValue(of([{ id: 1, question: 'WTF?' }, { id: 2, question: 'WAT?' }]))
    component.ngOnInit()
    expect(component.securityQuestions.length).toBe(2)
    expect(component.securityQuestions[0].question).toBe('WTF?')
    expect(component.securityQuestions[1].question).toBe('WAT?')
  })

  it('should hold nothing when no secret questions exists', () => {
    securityQuestionService.find.and.returnValue(of(undefined))
    component.ngOnInit()
    expect(component.securityQuestions).toBeUndefined()
  })

  it('should log error from backend API on failing to get security questions', fakeAsync(() => {
    securityQuestionService.find.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.ngOnInit()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should log error on saving user', fakeAsync(() => {
    userService.save.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.save()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))
})


/* ===== FILE: ./frontend/src/app/register/register.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<div fxLayoutAlign="center">
  <mat-card appearance="outlined" class="mat-elevation-z6">
    <div class="mdc-card">

      <h1 translate>TITLE_REGISTRATION</h1>

      <div class="error" ng-if="error">{{ error }}</div>

      <div class="form-container" id="registration-form">

        <mat-form-field appearance="outline" color="accent">
          <mat-label translate>LABEL_EMAIL</mat-label>
          <input id="emailControl" [formControl]="emailControl" (focus)="this.error=null" type="text" matInput
                aria-label="Email address field">
          <mat-error *ngIf="emailControl.invalid && emailControl.errors.required" translate>MANDATORY_EMAIL</mat-error>
          <mat-error *ngIf="emailControl.invalid && emailControl.errors.email" translate>INVALID_EMAIL</mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" color="accent">
          <mat-label translate>LABEL_PASSWORD</mat-label>
          <input #password id="passwordControl" [formControl]="passwordControl" (focus)="this.error=null" type="password"
                matInput aria-label="Field for the password">
          <mat-hint translate>
            <i class="fas fa-exclamation-circle"></i>
            <em style="margin-left:5px;" translate>{{ 'INVALID_PASSWORD_LENGTH' | translate: {length: '5-40'} }}</em>
          </mat-hint>
          <mat-hint align="end">{{password.value?.length || 0}}/20</mat-hint>
          <mat-error *ngIf="passwordControl.invalid && passwordControl.errors.required" translate>MANDATORY_PASSWORD
          </mat-error>
          <mat-error
            *ngIf="passwordControl.invalid && (passwordControl.errors.minlength || passwordControl.errors.maxlength)"
            translate [translateParams]="{length: '5-40'}">INVALID_PASSWORD_LENGTH
          </mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" color="accent">
          <mat-label translate>LABEL_PASSWORD_REPEAT</mat-label>
          <input #repeatPassword id="repeatPasswordControl" [formControl]="repeatPasswordControl"
                (focus)="this.error=null" type="password" matInput aria-label="Field to confirm the password">
          <mat-hint align="end">{{repeatPassword.value?.length || 0}}/40</mat-hint>
          <mat-error *ngIf="repeatPasswordControl.invalid && repeatPasswordControl.errors.required" translate>
            MANDATORY_PASSWORD_REPEAT
          </mat-error>
          <mat-error *ngIf="repeatPasswordControl.invalid && repeatPasswordControl.errors.notSame" translate>
            PASSWORDS_NOT_MATCHING
          </mat-error>
        </mat-form-field>

        <mat-slide-toggle #passwordInfoToggle [color]="passwordStrength.color">{{'SHOW_PASSWORD_ADVICE' | translate}}</mat-slide-toggle>
        <app-password-strength #passwordStrength [password]="password.value"></app-password-strength>
        <app-password-strength-info *ngIf="passwordInfoToggle.checked" [passwordComponent]="passwordStrength"
                                    [lowerCaseCriteriaMsg]="'LOWER_CASE_CRITERIA_MSG' | translate"
                                    [upperCaseCriteriaMsg]="'UPPER_CASE_CRITERIA_MSG'| translate"
                                    [digitsCriteriaMsg]="'DIGITS_CRITERIA_MSG'| translate"
                                    [specialCharsCriteriaMsg]="'SPECIAL_CHARS_CRITERIA_MSG' | translate"
                                    [minCharsCriteriaMsg]="'MIN_CHARS_CRITERIA_MSG' | translate:{value: 8}">
        </app-password-strength-info>

        <div class="security-container">

          <mat-form-field color="accent" appearance="outline">
            <mat-label>
              {{'LABEL_SECURITY_QUESTION' | translate}}
            </mat-label>
            <mat-select [formControl]="securityQuestionControl" placeholder="" [(value)]="selected"
                        (focus)="this.error=null" name="securityQuestion"
                        aria-label="Selection list for the security question">
              <mat-option *ngFor="let question of securityQuestions" [value]="question.id" class="mat-body">
                {{question.question}}
              </mat-option>
            </mat-select>
            <mat-hint translate>
              <i class="fas fa-exclamation-circle"></i>
              <em style="margin-left:5px;" translate>CANNOT_BE_CHANGED_LATER</em>
            </mat-hint>
            <mat-error *ngIf="securityQuestionControl.invalid && securityQuestionControl.errors.required" translate>
              MANDATORY_SECURITY_QUESTION
            </mat-error>
          </mat-form-field>

          <mat-form-field appearance="outline" color="accent">
            <mat-label translate>SECURITY_ANSWER</mat-label>
            <input id="securityAnswerControl" [formControl]="securityAnswerControl" (focus)="this.error=null" type="text"
                  matInput [placeholder]="'SECURITY_ANSWER_PLACEHOLDER' | translate"
                  aria-label="Field for the answer to the security question">
            <mat-error *ngIf="securityAnswerControl.invalid && securityAnswerControl.errors.required" translate>
              MANDATORY_SECURITY_ANSWER
            </mat-error>
          </mat-form-field>
        </div>

        <button type="submit"
                id="registerButton"
                mat-raised-button color="primary"
                [disabled]="emailControl.invalid || passwordControl.invalid || repeatPasswordControl.invalid || securityQuestionControl.invalid || securityAnswerControl.invalid"
                (click)="save()"
                aria-label="Button to complete the registration">
          <mat-icon>person_add</mat-icon>
          {{'BTN_REGISTER' | translate}}
        </button>

        <div id="alreadyACustomerLink">
          <a class="primary-link" routerLink="/login" translate>ALREADY_A_CUSTOMER</a>
        </div>
      </div>
    </div>
  </mat-card>
</div>


/* ===== FILE: ./frontend/src/app/register/register.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { SecurityAnswerService } from '../Services/security-answer.service'
import { UserService } from '../Services/user.service'
import { type AbstractControl, UntypedFormControl, Validators, FormsModule, ReactiveFormsModule } from '@angular/forms'
import { Component, NgZone, type OnInit } from '@angular/core'
import { SecurityQuestionService } from '../Services/security-question.service'
import { Router, RouterLink } from '@angular/router'
import { library } from '@fortawesome/fontawesome-svg-core'
import { MatSnackBar } from '@angular/material/snack-bar'

import { faExclamationCircle, faUserPlus } from '@fortawesome/free-solid-svg-icons'
import { FormSubmitService } from '../Services/form-submit.service'
import { SnackBarHelperService } from '../Services/snack-bar-helper.service'
import { TranslateService, TranslateModule } from '@ngx-translate/core'
import { type SecurityQuestion } from '../Models/securityQuestion.model'
import { MatButtonModule } from '@angular/material/button'
import { MatOption } from '@angular/material/core'
import { MatSelect } from '@angular/material/select'
import { PasswordStrengthComponent } from '../password-strength/password-strength.component'
import { PasswordStrengthInfoComponent } from '../password-strength-info/password-strength-info.component'
import { MatSlideToggle } from '@angular/material/slide-toggle'
import { NgIf, NgFor } from '@angular/common'
import { MatInputModule } from '@angular/material/input'
import { MatFormFieldModule, MatLabel, MatError, MatHint } from '@angular/material/form-field'
import { MatCardModule } from '@angular/material/card'
import { FlexModule } from '@angular/flex-layout/flex'
import { MatIconModule } from '@angular/material/icon'

library.add(faUserPlus, faExclamationCircle)

@Component({
  selector: 'app-register',
  templateUrl: './register.component.html',
  styleUrls: ['./register.component.scss'],
  imports: [FlexModule, MatCardModule, TranslateModule, MatFormFieldModule, MatLabel, MatInputModule, FormsModule, ReactiveFormsModule, NgIf, MatError, MatHint, MatSlideToggle, PasswordStrengthComponent, PasswordStrengthInfoComponent, MatSelect, NgFor, MatOption, MatButtonModule, RouterLink, MatIconModule]
})
export class RegisterComponent implements OnInit {
  public emailControl: UntypedFormControl = new UntypedFormControl('', [Validators.required, Validators.email])
  public passwordControl: UntypedFormControl = new UntypedFormControl('', [Validators.required, Validators.minLength(5), Validators.maxLength(40)])
  public repeatPasswordControl: UntypedFormControl = new UntypedFormControl('', [Validators.required, matchValidator(this.passwordControl)])
  public securityQuestionControl: UntypedFormControl = new UntypedFormControl('', [Validators.required])
  public securityAnswerControl: UntypedFormControl = new UntypedFormControl('', [Validators.required])
  public securityQuestions!: SecurityQuestion[]
  public selected?: number
  public error: string | null = null

  constructor (private readonly securityQuestionService: SecurityQuestionService,
    private readonly userService: UserService,
    private readonly securityAnswerService: SecurityAnswerService,
    private readonly router: Router,
    private readonly formSubmitService: FormSubmitService,
    private readonly translateService: TranslateService,
    private readonly snackBar: MatSnackBar,
    private readonly snackBarHelperService: SnackBarHelperService,
    private readonly ngZone: NgZone) { }

  ngOnInit (): void {
    this.securityQuestionService.find(null).subscribe((securityQuestions: any) => {
      this.securityQuestions = securityQuestions
    }, (err) => { console.log(err) })

    this.formSubmitService.attachEnterKeyHandler('registration-form', 'registerButton', () => { this.save() })
  }

  save () {
    const user = {
      email: this.emailControl.value,
      password: this.passwordControl.value,
      passwordRepeat: this.repeatPasswordControl.value,
      securityQuestion: this.securityQuestions.find((question) => question.id === this.securityQuestionControl.value),
      securityAnswer: this.securityAnswerControl.value
    }

    this.userService.save(user).subscribe((response: any) => {
      this.securityAnswerService.save({
        UserId: response.id,
        answer: this.securityAnswerControl.value,
        SecurityQuestionId: this.securityQuestionControl.value
      }).subscribe(() => {
        this.ngZone.run(async () => await this.router.navigate(['/login']))
        this.snackBarHelperService.open('CONFIRM_REGISTER')
      })
    }, (err) => {
      console.log(err)
      if (err.error?.errors) {
        const error = err.error.errors[0]
        if (error.message) {
          // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
          this.error = error.message[0].toUpperCase() + error.message.slice(1)
        } else {
          this.error = error
        }
      }
    })
  }
}

function matchValidator (passwordControl: AbstractControl) {
  return function matchOtherValidate (repeatPasswordControl: UntypedFormControl) {
    const password = passwordControl.value
    const passwordRepeat = repeatPasswordControl.value
    if (password !== passwordRepeat) {
      return { notSame: true }
    }
    return null
  }
}


/* ===== FILE: ./frontend/src/app/code-snippet/code-snippet.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { CodeSnippetService, type CodeSnippet } from '../Services/code-snippet.service'
import { CodeFixesService } from '../Services/code-fixes.service'
import { CookieService } from 'ngy-cookie'
import { ChallengeService } from '../Services/challenge.service'
import { VulnLinesService, type result } from '../Services/vuln-lines.service'
import { Component, Inject, type OnInit } from '@angular/core'

import { MAT_DIALOG_DATA, MatDialogTitle, MatDialogContent, MatDialogActions, MatDialogClose } from '@angular/material/dialog'
import { UntypedFormControl, FormsModule } from '@angular/forms'
import { ConfigurationService } from '../Services/configuration.service'
import { type ThemePalette } from '@angular/material/core'
import { MatIconButton, MatButtonModule } from '@angular/material/button'
import { MatInputModule } from '@angular/material/input'
import { MatFormFieldModule, MatLabel } from '@angular/material/form-field'
import { ExtendedModule } from '@angular/flex-layout/extended'
import { MatCardModule } from '@angular/material/card'
import { CodeFixesComponent } from '../code-fixes/code-fixes.component'
import { MatIconModule } from '@angular/material/icon'
import { TranslateModule } from '@ngx-translate/core'
import { CodeAreaComponent } from '../code-area/code-area.component'
import { NgIf, NgFor } from '@angular/common'
import { FlexModule } from '@angular/flex-layout/flex'
import { MatTabGroup, MatTab, MatTabLabel } from '@angular/material/tabs'

enum ResultState {
  Undecided,
  Right,
  Wrong,
}

export interface Solved {
  findIt: boolean
  fixIt: boolean
}

export interface RandomFixes {
  fix: string
  index: number
}

@Component({
  selector: 'code-snippet',
  templateUrl: './code-snippet.component.html',
  styleUrls: ['./code-snippet.component.scss'],
  host: { class: 'code-snippet' },
  imports: [MatDialogTitle, MatDialogContent, MatTabGroup, MatTab, FlexModule, NgIf, CodeAreaComponent, TranslateModule, MatTabLabel, MatIconModule, CodeFixesComponent, MatDialogActions, MatCardModule, ExtendedModule, MatFormFieldModule, MatLabel, MatInputModule, NgFor, FormsModule, MatIconButton, MatButtonModule, MatDialogClose]
})
export class CodeSnippetComponent implements OnInit {
  public snippet: CodeSnippet = null
  public fixes: string [] = null
  public selectedLines: number[]
  public selectedFix: number = 0
  public tab: UntypedFormControl = new UntypedFormControl(0)
  public lock: ResultState = ResultState.Undecided
  public result: ResultState = ResultState.Undecided
  public hint: string = null
  public explanation: string = null
  public solved: Solved = { findIt: false, fixIt: false }
  public showFeedbackButtons: boolean = true
  public randomFixes: RandomFixes[] = []

  constructor (@Inject(MAT_DIALOG_DATA) public dialogData: any, private readonly configurationService: ConfigurationService, private readonly codeSnippetService: CodeSnippetService, private readonly vulnLinesService: VulnLinesService, private readonly codeFixesService: CodeFixesService, private readonly challengeService: ChallengeService, private readonly cookieService: CookieService) { }

  ngOnInit (): void {
    this.configurationService.getApplicationConfiguration().subscribe((config) => {
      this.showFeedbackButtons = config.challenges.showFeedbackButtons
    }, (err) => { console.log(err) })

    this.codeSnippetService.get(this.dialogData.key).subscribe((snippet) => {
      this.snippet = snippet
      this.solved.findIt = false
      if (this.dialogData.codingChallengeStatus >= 1) {
        this.result = ResultState.Right
        this.lock = ResultState.Right
        this.solved.findIt = true
      }
    }, (err) => {
      this.snippet = { snippet: err.error }
    })
    this.codeFixesService.get(this.dialogData.key).subscribe((fixes) => {
      this.fixes = fixes.fixes
      if (this.fixes) {
        this.shuffle()
      }
      this.solved.fixIt = this.dialogData.codingChallengeStatus >= 2
    }, () => {
      this.fixes = null
    })
  }

  addLine = (lines: number[]) => {
    this.selectedLines = lines
  }

  setFix = (fix: number) => {
    this.selectedFix = fix
    this.explanation = null
  }

  changeFix (event: Event) {
    this.setFix(parseInt((event.target as HTMLSelectElement).value, 10))
  }

  toggleTab = (event: number) => {
    this.tab.setValue(event)
    this.result = ResultState.Undecided
    if (event === 0) {
      if (this.solved.findIt) this.result = ResultState.Right
    }
    if (event === 1) {
      if (this.solved.fixIt) this.result = ResultState.Right
    }
  }

  checkFix = () => {
    this.codeFixesService.check(this.dialogData.key, this.randomFixes[this.selectedFix].index).subscribe((verdict) => {
      this.setVerdict(verdict.verdict)
      this.explanation = verdict.explanation
    })
  }

  checkLines = () => {
    this.vulnLinesService.check(this.dialogData.key, this.selectedLines).subscribe((verdict: result) => {
      this.setVerdict(verdict.verdict)
      this.hint = verdict.hint
    })
  }

  lockIcon (): string {
    if (this.fixes === null) {
      return 'lock'
    }
    switch (this.lock) {
      case ResultState.Right:
        return 'lock_open'
      case ResultState.Wrong:
        return 'lock'
      case ResultState.Undecided:
        return 'lock'
    }
  }

  lockColor (): ThemePalette {
    switch (this.lockIcon()) {
      case 'lock_open':
        return 'accent'
      case 'lock':
        return 'warn'
    }
  }

  shuffle () {
    this.randomFixes = this.fixes
      .map((fix, index) => ({ fix, index, sort: Math.random() }))
      .sort((a, b) => a.sort - b.sort)
      .map(({ fix, index }) => ({ fix, index }))
  }

  setVerdict = (verdict: boolean) => {
    if (this.result === ResultState.Right) return
    if (verdict) {
      if (this.tab.value === 0) {
        this.solved.findIt = true
        this.challengeService.continueCodeFindIt().subscribe((continueCode) => {
          if (!continueCode) {
            throw (new Error('Received invalid continue code from the server!'))
          }
          const expires = new Date()
          expires.setFullYear(expires.getFullYear() + 1)
          this.cookieService.put('continueCodeFindIt', continueCode, { expires })
        }, (err) => { console.log(err) })
      } else {
        this.solved.fixIt = true
        this.challengeService.continueCodeFixIt().subscribe((continueCode) => {
          if (!continueCode) {
            throw (new Error('Received invalid continue code from the server!'))
          }
          const expires = new Date()
          expires.setFullYear(expires.getFullYear() + 1)
          this.cookieService.put('continueCodeFixIt', continueCode, { expires })
        }, (err) => { console.log(err) })
      }
      this.result = ResultState.Right
      this.lock = ResultState.Right
      import('../../confetti').then(module => {
        module.shootConfetti()
      })
        .then(() => {
          if (this.tab.value === 0 && this.fixes !== null) this.toggleTab(1)
        })
    } else {
      this.result = ResultState.Wrong
    }
  }

  resultIcon (): string {
    switch (this.result) {
      case ResultState.Right:
        return 'check'
      case ResultState.Wrong:
        return 'clear'
      default:
        return 'send'
    }
  }

  resultColor (): ThemePalette {
    switch (this.resultIcon()) {
      case 'check':
        return 'accent'
      case 'clear':
        return 'warn'
    }
  }
}


/* ===== FILE: ./frontend/src/app/code-snippet/code-snippet.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateModule } from '@ngx-translate/core'
import { MAT_DIALOG_DATA, MatDialogModule, MatDialogRef } from '@angular/material/dialog'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { MatDividerModule } from '@angular/material/divider'
import { type ComponentFixture, TestBed, waitForAsync } from '@angular/core/testing'

import { CodeSnippetComponent } from './code-snippet.component'
import { CodeSnippetService } from '../Services/code-snippet.service'
import { CookieModule, CookieService } from 'ngy-cookie'
import { ConfigurationService } from '../Services/configuration.service'
import { of, throwError } from 'rxjs'
import { CodeFixesService } from '../Services/code-fixes.service'
import { VulnLinesService } from '../Services/vuln-lines.service'
import { ChallengeService } from '../Services/challenge.service'
import { NoopAnimationsModule } from '@angular/platform-browser/animations'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('CodeSnippetComponent', () => {
  let component: CodeSnippetComponent
  let fixture: ComponentFixture<CodeSnippetComponent>
  let configurationService: any
  let cookieService: any
  let codeSnippetService: any
  let codeFixesService: any
  let vulnLinesService: any
  let challengeService: any

  beforeEach(waitForAsync(() => {
    configurationService = jasmine.createSpyObj('ConfigurationService', ['getApplicationConfiguration'])
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: {}, challenges: {} }))
    cookieService = jasmine.createSpyObj('CookieService', ['put', 'hasKey'])
    codeSnippetService = jasmine.createSpyObj('CodeSnippetService', ['get', 'check'])
    codeSnippetService.get.and.returnValue(of({}))
    codeFixesService = jasmine.createSpyObj('CodeFixesService', ['get', 'check'])
    codeFixesService.get.and.returnValue(of({}))
    vulnLinesService = jasmine.createSpyObj('VulnLinesService', ['check'])
    challengeService = jasmine.createSpyObj('ChallengeService', ['continueCodeFindIt', 'continueCodeFixIt'])
    challengeService.continueCodeFindIt.and.returnValue(of('continueCodeFindIt'))
    challengeService.continueCodeFixIt.and.returnValue(of('continueCodeFixIt'))

    TestBed.configureTestingModule({
      imports: [NoopAnimationsModule,
        CookieModule.forRoot(),
        TranslateModule.forRoot(),
        MatDividerModule,
        MatDialogModule,
        CodeSnippetComponent],
      providers: [
        { provide: MatDialogRef, useValue: {} },
        { provide: MAT_DIALOG_DATA, useValue: { dialogData: {} } },
        { provide: ConfigurationService, useValue: configurationService },
        { provide: CookieService, useValue: cookieService },
        { provide: CodeSnippetService, useValue: codeSnippetService },
        { provide: CodeFixesService, useValue: codeFixesService },
        { provide: VulnLinesService, useValue: vulnLinesService },
        { provide: ChallengeService, useValue: challengeService },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(CodeSnippetComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should log the error on retrieving configuration', () => {
    configurationService.getApplicationConfiguration.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.ngOnInit()
    expect(console.log).toHaveBeenCalledWith('Error')
  })

  it('should set the retrieved snippet', () => {
    codeSnippetService.get.and.returnValue(of({ snippet: 'Snippet' }))
    component.ngOnInit()
    expect(component.snippet).toEqual({ snippet: 'Snippet' })
  })

  it('Default status and icons should reflect both challenge phases yet unsolved', () => {
    component.ngOnInit()
    expect(component.result).toBe(0)
    expect(component.lock).toBe(0)
    expect(component.solved.findIt).toBeFalse()
  })

  it('should set status and icons for solved "Find It" phase', () => {
    component.dialogData.codingChallengeStatus = 1
    component.ngOnInit()
    expect(component.result).toBe(1)
    expect(component.lock).toBe(1)
    expect(component.solved.findIt).toBeTrue()
  })

  it('should set an error on snippet retrieval as the snippet', () => {
    codeSnippetService.get.and.returnValue(throwError({ error: 'Error' }))
    component.ngOnInit()
    expect(component.snippet).toEqual({ snippet: 'Error' })
  })

  it('should set empty fixes on error during fixes retrieval', () => {
    codeFixesService.get.and.returnValue(throwError('Error'))
    component.ngOnInit()
    expect(component.fixes).toBeNull()
  })

  it('selected code lines are set in component', () => {
    component.selectedLines = [42]
    component.addLine([1, 3, 5])
    expect(component.selectedLines).toEqual([1, 3, 5])
  })

  it('selected code fix is set in component', () => {
    component.selectedFix = 42
    component.setFix(1)
    expect(component.selectedFix).toBe(1)
  })

  it('selecting a code fix clears previous explanation', () => {
    component.explanation = 'Wrong answer!'
    component.setFix(1)
    expect(component.explanation).toBeNull()
  })

  it('lock icon is red and "locked" when no fixes are available', () => {
    component.fixes = null
    expect(component.lockIcon()).toBe('lock')
    expect(component.lockColor()).toBe('warn')
  })

  it('lock icon is red and "locked" by default', () => {
    component.fixes = ['Fix1', 'Fix2', 'Fix3']
    component.lock = 0
    expect(component.lockIcon()).toBe('lock')
    expect(component.lockColor()).toBe('warn')
  })

  it('lock icon is red and "locked" when "Find It" phase is unsolved', () => {
    component.fixes = ['Fix1', 'Fix2', 'Fix3']
    component.lock = 2
    expect(component.lockIcon()).toBe('lock')
    expect(component.lockColor()).toBe('warn')
  })

  it('lock icon is green and "lock_open" when "Find It" phase is in solved', () => {
    component.fixes = ['Fix1', 'Fix2', 'Fix3']
    component.lock = 1
    expect(component.lockIcon()).toBe('lock_open')
    expect(component.lockColor()).toBe('accent')
  })

  it('result icon is "send" when choice is not yet submitted', () => {
    component.result = 0
    expect(component.resultIcon()).toBe('send')
  })

  it('result icon is red "clear" when wrong answer has been submitted', () => {
    component.result = 2
    expect(component.resultIcon()).toBe('clear')
    expect(component.resultColor()).toBe('warn')
  })

  it('result icon is green "check" when right answer has been submitted', () => {
    component.result = 1
    expect(component.resultIcon()).toBe('check')
    expect(component.resultColor()).toBe('accent')
  })

  it('correctly submitted vulnerable lines toggle positive verdict for "Find It" phase', () => {
    component.tab.setValue(0)
    vulnLinesService.check.and.returnValue(of({ verdict: true }))
    component.checkLines()
    expect(component.solved.findIt).toBeTrue()
  })

  xit('correctly submitted vulnerable lines toggle tab to "Fix It" if code fixes exist', waitForAsync(() => {
    component.tab.setValue(0)
    component.fixes = ['Fix1', 'Fix2', 'Fix3']
    vulnLinesService.check.and.returnValue(of({ verdict: true }))
    component.checkLines()
    expect(component.tab.value).toBe(1)
  }))

  it('correctly submitted fix toggles positive verdict for "Fix It" phase', () => {
    component.tab.setValue(1)
    component.randomFixes = [{ fix: 'Fix 1', index: 0 }]
    codeFixesService.check.and.returnValue(of({ verdict: true }))
    component.checkFix()
    expect(component.solved.fixIt).toBeTrue()
  })

  it('should remember the original order of available code fix options when shuffling', () => {
    component.fixes = ['Fix 1', 'Fix 2', 'Fix 3']
    component.shuffle()
    expect(component.randomFixes).toContain({ fix: 'Fix 1', index: 0 })
    expect(component.randomFixes).toContain({ fix: 'Fix 2', index: 1 })
    expect(component.randomFixes).toContain({ fix: 'Fix 3', index: 2 })
  })
})


/* ===== FILE: ./frontend/src/app/code-snippet/code-snippet.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->
<h2 mat-dialog-title>{{'TITLE_CODING_CHALLENGE' | translate}}: {{dialogData.name}}</h2>
<mat-dialog-content>
  <mat-tab-group mat-stretch-tabs [selectedIndex]="tab.value" (selectedIndexChange)="toggleTab($event)">
    <mat-tab>
      <ng-template mat-tab-label>
        <span class="tab-header-text">{{'TAB_FIND_IT' | translate}}</span>
        <mat-icon class="materaial-icons-outlined" [color]="lockColor()">{{lockIcon()}}</mat-icon>
      </ng-template>
      @if (snippet !== null) {
        <app-code-area [code]="snippet?.snippet" [vulnLines]="snippet?.vulnLines" (addLine)="addLine($event)"></app-code-area>
      } @else {
        <pre><code translate>LOADING_CODE_SNIPPET</code></pre>
      }
    </mat-tab>
    <mat-tab [disabled]="lockIcon() === 'lock'">
      <ng-template mat-tab-label>
        <span class="tab-header-text">{{'TAB_FIX_IT' | translate}}</span>
        <mat-icon class="materaial-icons-outlined" [color]="lockColor()">{{lockIcon()}}</mat-icon>
      </ng-template>
      <app-code-fixes *ngIf="snippet !== null && fixes !== null" [snippet]="snippet?.snippet" [fixes]="fixes"
        [randomFixes]="randomFixes" [selectedFix]="selectedFix"></app-code-fixes>
    </mat-tab>
  </mat-tab-group>
</mat-dialog-content>
<mat-dialog-actions>
  <mat-card appearance="outlined" *ngIf="hint && tab.value === 0" class="primary-notification">
    <div class="mdc-card">{{hint}}</div>
  </mat-card>
  <mat-card appearance="outlined" *ngIf="explanation && tab.value === 1"
    [class]="resultColor() === 'warn' ? 'warn-notification' : 'accent-notification'">
    <div class="mdc-card">{{explanation}}</div>
  </mat-card>
  <div class="button-row">
    @if (tab.value === 0) {
      <!-- empty div to still have the space-between work -->
      <!-- size of the div is fixed to 78.25px which is the height of the select. this ensures the layout doesn't jump when switching tabs -->
      <div style="height: 78.25px;"></div>
    } @else {
      <mat-form-field *ngIf="tab.value === 1" appearance="fill">
        <mat-label translate>LABEL_CORRECT_FIX</mat-label>
        <select matNativeControl (change)="changeFix($event)">
          <option *ngFor="let fix of randomFixes; index as i" [value]="i" [selected]="selectedFix === i">Fix {{ i+1 }}
          </option>
        </select>
      </mat-form-field>
    }

    <div class="button-group">
      <a *ngIf="this.showFeedbackButtons && this.solved.fixIt"
        [href]="'https://docs.google.com/forms/d/e/1FAIpQLSdaNEuz0dzFA2sexCa0AJ4QOb2OYdEL04eQOLFD2Y4T-BW6ag/viewform?usp=pp_url&entry.384948954=' + dialogData.name + '&entry.435235279=Coding+Challenge&entry.1734944650=Yes'"
        target="_blank">
        <button mat-icon-button><mat-icon color="accent">thumb_up</mat-icon></button>
      </a>
      <a *ngIf="this.showFeedbackButtons && this.solved.fixIt"
        [href]="'https://docs.google.com/forms/d/e/1FAIpQLSdaNEuz0dzFA2sexCa0AJ4QOb2OYdEL04eQOLFD2Y4T-BW6ag/viewform?usp=pp_url&entry.384948954=' + dialogData.name + '&entry.435235279=Coding+Challenge&entry.1734944650=No'"
        target="_blank">
        <button mat-icon-button><mat-icon color="warn">thumb_down</mat-icon></button>
      </a>

      <button mat-stroked-button mat-dialog-close class="close-dialog buttons" aria-label="Close Dialog"
        [mat-dialog-close]="solved" id="findItCloseButton">
        <mat-icon>close</mat-icon>
        <span>{{'BTN_CLOSE' | translate}}</span>
      </button>

      <button *ngIf="tab.value === 0" mat-stroked-button (click)="checkLines()" [disabled]="this.solved.findIt"
        id="findItSubmitButton">
        <span>{{'BTN_SUBMIT' | translate}}</span>
        <mat-icon [color]="resultColor()">
          {{ resultIcon() }}
        </mat-icon>
      </button>

      <button *ngIf="tab.value === 1" mat-stroked-button (click)="checkFix()" [disabled]="this.solved.fixIt"
        id="fixItSubmitButton">
        <span>{{'BTN_SUBMIT' | translate}}</span>
        <mat-icon [color]="resultColor()">
          {{ resultIcon() }}
        </mat-icon>
      </button>
    </div>
  </div>
</mat-dialog-actions>

/* ===== FILE: ./frontend/src/app/app.guard.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type CanActivate, Router } from '@angular/router'
import * as jwtDecode from 'jwt-decode'
import { roles } from './roles'
import { Injectable, NgZone } from '@angular/core'

@Injectable()
export class LoginGuard implements CanActivate {
  constructor (private readonly router: Router, private readonly ngZone: NgZone) {}

  canActivate () {
    if (localStorage.getItem('token')) {
      return true
    } else {
      this.forbidRoute('UNAUTHORIZED_ACCESS_ERROR')
      return false
    }
  }

  forbidRoute (error = 'UNAUTHORIZED_PAGE_ACCESS_ERROR') {
    this.ngZone.run(async () => await this.router.navigate(['403'], {
      skipLocationChange: true,
      queryParams: { error }
    }))
  }

  tokenDecode () {
    let payload: any = null
    const token = localStorage.getItem('token')
    if (token) {
      try {
        payload = jwtDecode(token)
      } catch (err) {
        console.log(err)
      }
    }
    return payload
  }
}

@Injectable()
export class AdminGuard implements CanActivate {
  constructor (private readonly loginGuard: LoginGuard) {}

  canActivate () {
    const payload = this.loginGuard.tokenDecode()
    if (payload?.data && payload.data.role === roles.admin) {
      return true
    } else {
      this.loginGuard.forbidRoute()
      return false
    }
  }
}

@Injectable()
export class AccountingGuard implements CanActivate {
  constructor (private readonly loginGuard: LoginGuard) {}

  canActivate () {
    const payload = this.loginGuard.tokenDecode()
    if (payload?.data && payload.data.role === roles.accounting) {
      return true
    } else {
      this.loginGuard.forbidRoute()
      return false
    }
  }
}

@Injectable()
export class DeluxeGuard {
  constructor (private readonly loginGuard: LoginGuard) {}

  isDeluxe () {
    const payload = this.loginGuard.tokenDecode()
    return payload?.data && payload.data.role === roles.deluxe
  }
}


/* ===== FILE: ./frontend/src/app/forgot-password/forgot-password.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { UserService } from '../Services/user.service'
import { SecurityQuestionService } from '../Services/security-question.service'
import { type AbstractControl, UntypedFormControl, Validators, FormsModule, ReactiveFormsModule } from '@angular/forms'
import { Component } from '@angular/core'
import { library } from '@fortawesome/fontawesome-svg-core'
import { faSave } from '@fortawesome/free-solid-svg-icons'
import { faEdit } from '@fortawesome/free-regular-svg-icons'
import { type SecurityQuestion } from '../Models/securityQuestion.model'
import { TranslateService, TranslateModule } from '@ngx-translate/core'
import { MatButtonModule } from '@angular/material/button'
import { PasswordStrengthComponent } from '../password-strength/password-strength.component'
import { PasswordStrengthInfoComponent } from '../password-strength-info/password-strength-info.component'
import { MatSlideToggle } from '@angular/material/slide-toggle'
import { NgIf } from '@angular/common'
import { MatTooltip } from '@angular/material/tooltip'
import { MatIconModule } from '@angular/material/icon'
import { MatInputModule } from '@angular/material/input'
import { MatFormFieldModule, MatLabel, MatSuffix, MatError, MatHint } from '@angular/material/form-field'
import { MatCardModule } from '@angular/material/card'
import { FlexModule } from '@angular/flex-layout/flex'

library.add(faSave, faEdit)

@Component({
  selector: 'app-forgot-password',
  templateUrl: './forgot-password.component.html',
  styleUrls: ['./forgot-password.component.scss'],
  imports: [FlexModule, MatCardModule, TranslateModule, MatFormFieldModule, MatLabel, MatInputModule, FormsModule, ReactiveFormsModule, MatIconModule, MatSuffix, MatTooltip, NgIf, MatError, MatHint, MatSlideToggle, PasswordStrengthComponent, PasswordStrengthInfoComponent, MatButtonModule]
})
export class ForgotPasswordComponent {
  public emailControl: UntypedFormControl = new UntypedFormControl('', [Validators.required, Validators.email])
  public securityQuestionControl: UntypedFormControl = new UntypedFormControl({ disabled: true, value: '' }, [Validators.required])
  public passwordControl: UntypedFormControl = new UntypedFormControl({ disabled: true, value: '' }, [Validators.required, Validators.minLength(5)])
  public repeatPasswordControl: UntypedFormControl = new UntypedFormControl({ disabled: true, value: '' }, [Validators.required, matchValidator(this.passwordControl)])
  public securityQuestion?: string
  public error?: string
  public confirmation?: string
  public timeoutDuration = 1000
  private timeout

  constructor (private readonly securityQuestionService: SecurityQuestionService, private readonly userService: UserService, private readonly translate: TranslateService) { }

  findSecurityQuestion () {
    clearTimeout(this.timeout)
    this.timeout = setTimeout(() => {
      this.securityQuestion = undefined
      if (this.emailControl.value) {
        this.securityQuestionService.findBy(this.emailControl.value).subscribe((securityQuestion: SecurityQuestion) => {
          if (securityQuestion) {
            this.securityQuestion = securityQuestion.question
            this.securityQuestionControl.enable()
            this.passwordControl.enable()
            this.repeatPasswordControl.enable()
          } else {
            this.securityQuestionControl.disable()
            this.passwordControl.disable()
            this.repeatPasswordControl.disable()
          }
        },
        (error) => error
        )
      } else {
        this.securityQuestionControl.disable()
        this.passwordControl.disable()
        this.repeatPasswordControl.disable()
      }
    }, this.timeoutDuration)
  }

  resetPassword () {
    this.userService.resetPassword({
      email: this.emailControl.value,
      answer: this.securityQuestionControl.value,
      new: this.passwordControl.value,
      repeat: this.repeatPasswordControl.value
    }).subscribe(() => {
      this.error = undefined
      this.translate.get('PASSWORD_SUCCESSFULLY_CHANGED').subscribe((passwordSuccessfullyChanged) => {
        this.confirmation = passwordSuccessfullyChanged
      }, (translationId) => {
        this.confirmation = translationId
      })
      this.resetForm()
    }, (error) => {
      this.error = error.error
      this.confirmation = undefined
      this.resetErrorForm()
    })
  }

  resetForm () {
    this.emailControl.setValue('')
    this.emailControl.markAsPristine()
    this.emailControl.markAsUntouched()
    this.securityQuestionControl.setValue('')
    this.securityQuestionControl.markAsPristine()
    this.securityQuestionControl.markAsUntouched()
    this.passwordControl.setValue('')
    this.passwordControl.markAsPristine()
    this.passwordControl.markAsUntouched()
    this.repeatPasswordControl.setValue('')
    this.repeatPasswordControl.markAsPristine()
    this.repeatPasswordControl.markAsUntouched()
  }

  resetErrorForm () {
    this.emailControl.markAsPristine()
    this.emailControl.markAsUntouched()
    this.securityQuestionControl.setValue('')
    this.securityQuestionControl.markAsPristine()
    this.securityQuestionControl.markAsUntouched()
    this.passwordControl.setValue('')
    this.passwordControl.markAsPristine()
    this.passwordControl.markAsUntouched()
    this.repeatPasswordControl.setValue('')
    this.repeatPasswordControl.markAsPristine()
    this.repeatPasswordControl.markAsUntouched()
  }
}

function matchValidator (passwordControl: AbstractControl) {
  return function matchOtherValidate (repeatPasswordControl: UntypedFormControl) {
    const password = passwordControl.value
    const passwordRepeat = repeatPasswordControl.value
    if (password !== passwordRepeat) {
      return { notSame: true }
    }
    return null
  }
}


/* ===== FILE: ./frontend/src/app/forgot-password/forgot-password.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<div fxLayoutAlign="center">
  <mat-card appearance="outlined" class="mat-elevation-z6">
    <div class="mdc-card">

      <h1 translate>TITLE_FORGOT_PASSWORD</h1>

      <div class="confirmation"
          [hidden]="!(confirmation && !emailControl.dirty && !securityQuestionControl.dirty && !passwordControl.dirty && !repeatPasswordControl.dirty)">
        {{ confirmation }}
      </div>

      <div class="error"
          [hidden]="!(error && !emailControl.dirty && !securityQuestionControl.dirty && !passwordControl.dirty && !repeatPasswordControl.dirty)">
        {{ error }}
      </div>

      <div class="form-container">

        <mat-form-field appearance="outline" color="accent">
          <mat-label translate>LABEL_EMAIL</mat-label>
          <input id="email" [formControl]="emailControl" (ngModelChange)="findSecurityQuestion()"
                type="email" matInput placeholder="Enter your email" aria-label="Email address field">
          <mat-icon matSuffix matTooltip="{{ 'MANDATORY_EMAIL' | translate  }}"
                    matTooltipPosition=right aria-label="Please enter your email address to proceed">help_outline
          </mat-icon>
          <mat-error *ngIf="emailControl.invalid && emailControl.errors.required" translate>MANDATORY_EMAIL</mat-error>
          <mat-error *ngIf="emailControl.invalid && emailControl.errors.email" translate>INVALID_EMAIL</mat-error>
        </mat-form-field>

      </div>

      <div class="form-container" id="forgot-form">

        <mat-form-field appearance="outline" color="accent">
          <mat-label translate>LABEL_SECURITY_QUESTION</mat-label>
          <input id="securityAnswer" [formControl]="securityQuestionControl" type="password" matInput
                placeholder="{{ securityQuestion }}"
                aria-label="Field for the answer to the security question">
          <mat-icon matSuffix matTooltip="{{ 'MANDATORY_SECURITY_ANSWER' | translate  }}"
                    matTooltipPosition=right aria-label="Please answer your selected security question">help_outline
          </mat-icon>
          <mat-error *ngIf="securityQuestionControl.invalid && securityQuestionControl.errors.required" translate>
            MANDATORY_SECURITY_ANSWER
          </mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" color="accent">
          <mat-label translate>LABEL_NEW_PASSWORD</mat-label>
          <input #password id="newPassword" [formControl]="passwordControl" type="password" matInput placeholder=""
                aria-label="Field for New Password">
          <mat-hint translate>
            <i class="fas fa-exclamation-circle"></i>
            <em style="margin-left:5px;" translate>{{ 'INVALID_PASSWORD_LENGTH' | translate: {length: '5-40'} }}</em>
          </mat-hint>
          <mat-hint align="end">{{password.value?.length || 0}}/20</mat-hint>
          <mat-error *ngIf="passwordControl.invalid && passwordControl.errors.required" translate>MANDATORY_NEW_PASSWORD
          </mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" color="accent">
          <mat-label translate>LABEL_REPEAT_NEW_PASSWORD</mat-label>
          <input #repeatPassword id="newPasswordRepeat" [formControl]="repeatPasswordControl" type="password" matInput
                placeholder=""
                aria-label="Field to confirm the new password">
          <mat-hint align="end">{{repeatPassword.value?.length || 0}}/20</mat-hint>
          <mat-error *ngIf="repeatPasswordControl.invalid && repeatPasswordControl.errors.required" translate>
            MANDATORY_PASSWORD_REPEAT
          </mat-error>
          <mat-error *ngIf="repeatPasswordControl.invalid && repeatPasswordControl.errors.notSame" translate>
            PASSWORDS_NOT_MATCHING
          </mat-error>
          <mat-error *ngIf="repeatPasswordControl.invalid && (repeatPasswordControl?.errors.minlength || repeatPasswordControl?.errors.maxlength)" translate
                    [translateParams]="{length: '5-40'}">INVALID_PASSWORD_LENGTH
          </mat-error>
        </mat-form-field>

        <mat-slide-toggle #passwordInfoToggle [color]="passwordStrength.color">{{'SHOW_PASSWORD_ADVICE' | translate}}</mat-slide-toggle>
        <app-password-strength #passwordStrength [password]="password.value"></app-password-strength>
        <div class="advice-container">
          <app-password-strength-info *ngIf="passwordInfoToggle.checked" [passwordComponent]="passwordStrength"
                                      [lowerCaseCriteriaMsg]="'LOWER_CASE_CRITERIA_MSG' | translate"
                                      [upperCaseCriteriaMsg]="'UPPER_CASE_CRITERIA_MSG'| translate"
                                      [digitsCriteriaMsg]="'DIGITS_CRITERIA_MSG'| translate"
                                      [specialCharsCriteriaMsg]="'SPECIAL_CHARS_CRITERIA_MSG' | translate"
                                      [minCharsCriteriaMsg]="'MIN_CHARS_CRITERIA_MSG' | translate:{value: 8}">
          </app-password-strength-info>
        </div>
      </div>

      <button type="submit" id="resetButton"
              [disabled]="emailControl.invalid || securityQuestionControl.invalid || passwordControl.invalid || repeatPasswordControl.invalid || repeatPasswordControl.disabled"
              (click)="resetPassword()" mat-raised-button color="primary" aria-label="Button to confirm the changes">
        <i class="far fa-edit fa-lg" aria-hidden="true"></i>
        {{'BTN_CHANGE' | translate}}
      </button>

    </div>
  </mat-card>
</div>


/* ===== FILE: ./frontend/src/app/forgot-password/forgot-password.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateModule } from '@ngx-translate/core'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { ReactiveFormsModule } from '@angular/forms'
import { type ComponentFixture, fakeAsync, flush, TestBed, tick, waitForAsync } from '@angular/core/testing'
import { ForgotPasswordComponent } from './forgot-password.component'
import { SecurityQuestionService } from '../Services/security-question.service'

import { BrowserAnimationsModule } from '@angular/platform-browser/animations'
import { MatButtonModule } from '@angular/material/button'
import { MatInputModule } from '@angular/material/input'
import { MatFormFieldModule } from '@angular/material/form-field'
import { MatCardModule } from '@angular/material/card'
import { UserService } from 'src/app/Services/user.service'
import { of, throwError } from 'rxjs'
import { MatTooltipModule } from '@angular/material/tooltip'
import { MatIconModule } from '@angular/material/icon'
import { MatSlideToggleModule } from '@angular/material/slide-toggle'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('ForgotPasswordComponent', () => {
  let component: ForgotPasswordComponent
  let fixture: ComponentFixture<ForgotPasswordComponent>
  let securityQuestionService: any
  let userService: any

  beforeEach(waitForAsync(() => {
    securityQuestionService = jasmine.createSpyObj('SecurityQuestionService', ['findBy'])
    securityQuestionService.findBy.and.returnValue(of({}))
    userService = jasmine.createSpyObj('UserService', ['resetPassword'])
    userService.resetPassword.and.returnValue(of({}))

    TestBed.configureTestingModule({
      imports: [TranslateModule.forRoot(),
        ReactiveFormsModule,
        BrowserAnimationsModule,
        MatCardModule,
        MatFormFieldModule,
        MatInputModule,
        MatButtonModule,
        MatTooltipModule,
        MatIconModule,
        MatSlideToggleModule,
        ForgotPasswordComponent],
      providers: [
        { provide: SecurityQuestionService, useValue: securityQuestionService },
        { provide: UserService, useValue: userService },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(ForgotPasswordComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should be compulsory to fill the email field', () => {
    component.emailControl.setValue('')
    expect(component.emailControl.valid).toBeFalsy()
  })

  it('should hold a valid email in the email field', () => {
    component.emailControl.setValue('aa')
    expect(component.emailControl.valid).toBeFalsy()
    component.emailControl.setValue('a@a')
    expect(component.emailControl.valid).toBe(true)
  })

  it('should be compulsory to answer to the security question', fakeAsync(() => {
    component.emailControl.setValue('a@a')
    tick(component.timeoutDuration)
    component.securityQuestionControl.setValue('')
    expect(component.securityQuestionControl.valid).toBeFalsy()
    component.securityQuestionControl.setValue('Answer')
    expect(component.securityQuestionControl.valid).toBe(true)
    flush()
  }))

  it('should be compulsory to fill the password field', () => {
    component.passwordControl.setValue('')
    expect(component.passwordControl.valid).toBeFalsy()
  })

  it('should have a password length of at least five characters', fakeAsync(() => {
    component.emailControl.setValue('a@a')
    tick(component.timeoutDuration)
    component.passwordControl.setValue('aaa')
    expect(component.passwordControl.valid).toBeFalsy()
    component.passwordControl.setValue('aaaaa')
    expect(component.passwordControl.valid).toBe(true)
    flush()
  }))

  it('should allow password length of more than twenty characters', fakeAsync(() => {
    component.emailControl.setValue('a@a')
    tick(component.timeoutDuration)
    component.passwordControl.setValue('aaaaaaaaaaaaaaaaaaaaa')
    expect(component.passwordControl.valid).toBe(true)
    flush()
  }))

  it('should be compulsory to repeat the password', fakeAsync(() => {
    component.emailControl.setValue('a@a')
    tick(component.timeoutDuration)
    component.passwordControl.setValue('a')
    component.repeatPasswordControl.setValue('')
    expect(component.repeatPasswordControl.valid).toBeFalsy()
    component.repeatPasswordControl.setValue('a')
    expect(component.repeatPasswordControl.valid).toBe(true)
    flush()
  }))

  it('should reset form on calling resetForm', () => {
    component.emailControl.setValue('email')
    component.securityQuestionControl.setValue('security question')
    component.passwordControl.setValue('password')
    component.repeatPasswordControl.setValue('repeat password')
    component.resetForm()
    expect(component.emailControl.pristine).toBe(true)
    expect(component.emailControl.untouched).toBe(true)
    expect(component.emailControl.value).toBe('')
    expect(component.securityQuestionControl.pristine).toBe(true)
    expect(component.securityQuestionControl.untouched).toBe(true)
    expect(component.securityQuestionControl.value).toBe('')
    expect(component.passwordControl.pristine).toBe(true)
    expect(component.passwordControl.untouched).toBe(true)
    expect(component.passwordControl.value).toBe('')
    expect(component.repeatPasswordControl.pristine).toBe(true)
    expect(component.repeatPasswordControl.untouched).toBe(true)
    expect(component.repeatPasswordControl.value).toBe('')
  })

  it('should clear form and show confirmation after changing password', () => {
    userService.resetPassword.and.returnValue(of({}))
    spyOn(component, 'resetForm')
    component.resetPassword()
    expect(component.confirmation).toBeDefined()
    expect(component.resetForm).toHaveBeenCalled()
  })

  it('should clear form and gracefully handle error on password change', fakeAsync(() => {
    userService.resetPassword.and.returnValue(throwError({ error: 'Error' }))
    spyOn(component, 'resetErrorForm')
    component.resetPassword()
    expect(component.error).toBe('Error')
    expect(component.resetErrorForm).toHaveBeenCalled()
  }))

  it('should find the security question of a user with a known email address', fakeAsync(() => {
    securityQuestionService.findBy.and.returnValue(of({ question: 'What is your favorite test tool?' }))
    component.emailControl.setValue('known@user.test')
    tick(component.timeoutDuration)
    component.findSecurityQuestion()
    expect(component.securityQuestion).toBe('What is your favorite test tool?')
    flush()
  }))

  it('should not find the security question for an email address not bound to a user', () => {
    securityQuestionService.findBy.and.returnValue(of({}))
    component.emailControl.setValue('unknown@user.test')
    component.findSecurityQuestion()
    expect(component.securityQuestion).toBeUndefined()
  })

  it('should not have a security question when lookup by email address failed', fakeAsync(() => {
    securityQuestionService.findBy.and.returnValue(throwError('Error'))
    component.emailControl.setValue('some@user.test')
    tick(component.timeoutDuration)
    component.findSecurityQuestion()
    expect(component.securityQuestion).toBeUndefined()
    flush()
  }))

  it('should find not attempt to find security question for empty email address', () => {
    component.emailControl.setValue('')
    component.findSecurityQuestion()
    expect(securityQuestionService.findBy).not.toHaveBeenCalled()
  })
})


/* ===== FILE: ./frontend/src/app/order-summary/order-summary.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->
<mat-card appearance="outlined" fxLayout="row" fxLayout.lt-md="column" fxLayoutGap="20px" class=" container mat-elevation-z6 mat-own-card" >
  <div class="mdc-card" fxLayout="row" fxLayout.lt-md="column" fxLayoutGap="20px">
    <div fxLayout="column" fxLayoutGap="20px" fxFlex="50" fxFlex.lt-md="100%">
            <div fxLayout="row" fxLayoutGap="20px" fxLayout.lt-md="column" *ngIf="address && paymentMethod">       
          <!-- Delivery Address Card -->
          <mat-card appearance="outlined" class="mat-elevation-z0" fxFlex="60" fxFlex.lt-md="100%">
            <div fxFlex="1 1 auto" class="mdc-card">
              <div><b>{{"LABEL_DELIVERY_ADDRESS" | translate}}</b></div>
              <div>{{address?.fullName}}</div>
              <div>{{address?.streetAddress}}, {{address?.city}}, {{address?.state}}, {{address?.zipCode}}</div>
              <div>{{address?.country}}</div>
              <div><span>{{"PHONE_NUMBER" | translate}}</span> {{address?.mobileNum}}</div>
            </div>
          </mat-card>
          <!-- Payment Method Card -->
          <mat-card appearance="outlined" class="mat-elevation-z0" fxFlex="40" fxFlex.lt-md="100%" *ngIf="paymentMethod !== 'wallet'; else walletPayment">
            <div class="mdc-card">
              <div><b >{{"PAYMENT_METHOD" | translate}}</b></div>
              <div><span >{{"CARD_ENDING_IN" | translate}}</span> {{paymentMethod?.cardNum}}</div>
              <div><span >{{"CARD_HOLDER" | translate}}"</span> {{paymentMethod?.fullName}}</div>
            </div>
          </mat-card>
  
          <!-- Digital Wallet (Fallback) -->
          <ng-template #walletPayment>
            <mat-card appearance="outlined" class="mat-elevation-z0" fxFlex="40" fxFlex.lt-md="100%">
              <div class="mdc-card">
                <div><b >{{"PAYMENT_METHOD" | translate}}</b></div>
                <div><span >{{"DIGITAL_WALLET" | translate}}</span></div>
              </div>
            </mat-card>
          </ng-template>
        </div>
        <!-- Purchase Basket -->
      <app-purchase-basket id="app-purchase-basket" [allowEdit]="false" [totalPrice]="false" 
         (emitTotal)="getMessage($event)"></app-purchase-basket>
      </div> 
      <!-- Order Summary Card -->
      <div fxFlex="50" fxFlex.lt-md="100%">
        <mat-card appearance="outlined" class="mat-elevation-z0" fxFlexFill>
          <div class="mdc-card">
            <div class="order-summary" >{{"ORDER_SUMMARY" | translate}}</div>
            <table class="mat-table">
              <tr class="mat-row">
                <td class="mat-cell label" >{{"ITEMS" | translate}}</td>
                <td class="mat-cell price">{{ itemTotal?.toFixed(2) }}&curren;</td>
              </tr>
              <tr class="mat-row">
                <td class="mat-cell label" >{{"DELIVERY" | translate}}</td>
                <td class="mat-cell price">{{ deliveryPrice.toFixed(2) }}&curren;</td>
              </tr>
              <tr class="mat-row">
                <td class="mat-cell label" >{{"PROMOTION" | translate}}</td>
                <td class="mat-cell price">{{ promotionalDiscount.toFixed(2) }}&curren;</td>
              </tr>
              <tr class="mat-row">
                <td class="mat-footer-cell label" >{{"LABEL_TOTAL_PRICE" | translate}}</td>
              <td class="mat-footer-cell price">{{ (itemTotal + deliveryPrice - promotionalDiscount)?.toFixed(2)
                }}&curren;
              </td>
              </tr>
            </table>
            <!-- Checkout Button -->
            <button mat-raised-button mat-button class="btn btn-pay" color="primary" aria-label="Complete your purchase"
                    id="checkoutButton" (click)="placeOrder()">
              <mat-icon>
                {{"monetization_on" | translate}}
              </mat-icon>
              <span >{{"PLACE_ORDER_AND_PAY" | translate}}</span>
            </button>
            <!-- Bonus Points -->
            <div class="bonus-points">{{ "CHECKOUT_FOR_BONUS_POINTS" | translate:{ bonus: bonus } }}</div>
          </div>
        </mat-card>
      </div>

    </div>
  </mat-card>
  

/* ===== FILE: ./frontend/src/app/order-summary/order-summary.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Component, NgZone, type OnInit } from '@angular/core'
import { AddressService } from '../Services/address.service'
import { PaymentService } from '../Services/payment.service'
import { BasketService } from '../Services/basket.service'
import { Router } from '@angular/router'
import { DeliveryService } from '../Services/delivery.service'
import { SnackBarHelperService } from '../Services/snack-bar-helper.service'
import { MatIconModule } from '@angular/material/icon'
import { MatButtonModule } from '@angular/material/button'
import { PurchaseBasketComponent } from '../purchase-basket/purchase-basket.component'
import { TranslateModule } from '@ngx-translate/core'
import { NgIf } from '@angular/common'
import { FlexModule } from '@angular/flex-layout/flex'
import { MatCardModule } from '@angular/material/card'

@Component({
  selector: 'app-order-summary',
  templateUrl: './order-summary.component.html',
  styleUrls: ['./order-summary.component.scss'],
  imports: [MatCardModule, FlexModule, NgIf, TranslateModule, PurchaseBasketComponent, MatButtonModule, MatIconModule]
})
export class OrderSummaryComponent implements OnInit {
  public bonus = 0
  public itemTotal = 0
  public deliveryPrice = 0
  public promotionalDiscount = 0
  public address: any
  public paymentMethod: any
  constructor (private readonly router: Router, private readonly addressService: AddressService, private readonly paymentService: PaymentService, private readonly basketService: BasketService, private readonly deliveryService: DeliveryService, private readonly ngZone: NgZone, private readonly snackBarHelperService: SnackBarHelperService) { }

  ngOnInit (): void {
    this.deliveryService.getById(sessionStorage.getItem('deliveryMethodId')).subscribe((method) => {
      this.deliveryPrice = method.price
    })

    this.addressService.getById(sessionStorage.getItem('addressId')).subscribe((address) => {
      this.address = address
    }, (error) => { console.log(error) })

    if (sessionStorage.getItem('paymentId') !== 'wallet') {
      this.paymentService.getById(sessionStorage.getItem('paymentId')).subscribe((card) => {
        card.cardNum = String(card.cardNum).substring(String(card.cardNum).length - 4)
        this.paymentMethod = card
      }, (err) => { console.log(err) })
    } else if (sessionStorage.getItem('paymentId') === 'wallet') {
      this.paymentMethod = 'wallet'
    }
  }

  getMessage (total) {
    this.itemTotal = total[0]
    this.promotionalDiscount = sessionStorage.getItem('couponDiscount') ? (parseFloat(sessionStorage.getItem('couponDiscount')) / 100) * this.itemTotal : 0
    this.bonus = total[1]
  }

  placeOrder () {
    const orderDetails = {
      paymentId: sessionStorage.getItem('paymentId'),
      addressId: sessionStorage.getItem('addressId'),
      deliveryMethodId: sessionStorage.getItem('deliveryMethodId')
    }
    this.basketService.checkout(Number(sessionStorage.getItem('bid')), btoa(sessionStorage.getItem('couponDetails')), orderDetails).subscribe((orderConfirmationId) => {
      sessionStorage.removeItem('paymentId')
      sessionStorage.removeItem('addressId')
      sessionStorage.removeItem('deliveryMethodId')
      sessionStorage.removeItem('couponDetails')
      sessionStorage.removeItem('couponDiscount')
      this.basketService.updateNumberOfCartItems()
      this.ngZone.run(async () => await this.router.navigate(['/order-completion', orderConfirmationId]))
    }, (err) => {
      console.log(err)
      this.snackBarHelperService.open(err.error?.error.message, 'errorBar')
    })
  }
}


/* ===== FILE: ./frontend/src/app/order-summary/order-summary.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateModule } from '@ngx-translate/core'
import { MatInputModule } from '@angular/material/input'
import { type ComponentFixture, fakeAsync, TestBed, waitForAsync } from '@angular/core/testing'
import { MatCardModule } from '@angular/material/card'
import { MatTableModule } from '@angular/material/table'
import { MatButtonModule } from '@angular/material/button'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { ReactiveFormsModule } from '@angular/forms'
import { MatButtonToggleModule } from '@angular/material/button-toggle'
import { OrderSummaryComponent } from './order-summary.component'
import { PurchaseBasketComponent } from '../purchase-basket/purchase-basket.component'
import { RouterTestingModule } from '@angular/router/testing'
import { BasketService } from '../Services/basket.service'
import { AddressService } from '../Services/address.service'
import { of } from 'rxjs/internal/observable/of'
import { throwError } from 'rxjs'
import { PaymentService } from '../Services/payment.service'
import { OrderCompletionComponent } from '../order-completion/order-completion.component'
import { MatIconModule } from '@angular/material/icon'
import { MatTooltipModule } from '@angular/material/tooltip'
import { DeliveryService } from '../Services/delivery.service'
import { DeluxeGuard } from '../app.guard'
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('OrderSummaryComponent', () => {
  let component: OrderSummaryComponent
  let fixture: ComponentFixture<OrderSummaryComponent>
  let basketService: any
  let addressService: any
  let paymentService: any
  let deliveryService: any
  let deluxeGuard
  let snackBar: any

  beforeEach(waitForAsync(() => {
    addressService = jasmine.createSpyObj('AddressService', ['getById'])
    addressService.getById.and.returnValue(of([]))
    basketService = jasmine.createSpyObj('BasketService', ['checkout', 'find', 'updateNumberOfCartItems'])
    basketService.find.and.returnValue(of({ Products: [] }))
    basketService.checkout.and.returnValue(of({}))
    basketService.updateNumberOfCartItems.and.returnValue(of({}))
    paymentService = jasmine.createSpyObj('PaymentService', ['getById'])
    paymentService.getById.and.returnValue(of([]))
    deliveryService = jasmine.createSpyObj('DeliveryService', ['getById'])
    deliveryService.getById.and.returnValue(of({ price: 10 }))
    deluxeGuard = jasmine.createSpyObj('', ['isDeluxe'])
    deluxeGuard.isDeluxe.and.returnValue(false)
    snackBar = jasmine.createSpyObj('MatSnackBar', ['open'])

    TestBed.configureTestingModule({
      imports: [RouterTestingModule.withRoutes([
        { path: 'order-completion', component: OrderCompletionComponent }
      ]),
      TranslateModule.forRoot(),
      BrowserAnimationsModule,
      ReactiveFormsModule,
      MatInputModule,
      MatCardModule,
      MatTableModule,
      MatButtonModule,
      MatButtonToggleModule,
      MatIconModule,
      MatTooltipModule,
      MatSnackBarModule,
      OrderSummaryComponent, PurchaseBasketComponent, OrderCompletionComponent],
      providers: [
        { provide: BasketService, useValue: basketService },
        { provide: AddressService, useValue: addressService },
        { provide: PaymentService, useValue: paymentService },
        { provide: DeliveryService, useValue: deliveryService },
        { provide: DeluxeGuard, useValue: deluxeGuard },
        { provide: MatSnackBar, useValue: snackBar },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(OrderSummaryComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should log errors from address service directly to browser console', fakeAsync(() => {
    addressService.getById.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.ngOnInit()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should log errors from payment service directly to browser console', fakeAsync(() => {
    sessionStorage.setItem('paymentId', '1')
    paymentService.getById.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.ngOnInit()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should hold address on ngOnInit', () => {
    addressService.getById.and.returnValue(of({ address: 'address' }))
    component.ngOnInit()
    expect(component.address).toEqual({ address: 'address' })
  })

  it('should hold delivery price on ngOnInit', () => {
    deliveryService.getById.and.returnValue(of({ price: 10 }))
    component.ngOnInit()
    expect(component.deliveryPrice).toEqual(10)
  })

  it('should hold card on ngOnInit when paymentId is initialized to an id', () => {
    sessionStorage.setItem('paymentId', '1')
    paymentService.getById.and.returnValue(of({ cardNum: '************1234' }))
    component.ngOnInit()
    expect(component.paymentMethod).toEqual({ cardNum: '1234' })
  })

  it('should be wallet on ngOnInit when paymentId is initialized to wallet', () => {
    sessionStorage.setItem('paymentId', 'wallet')
    component.ngOnInit()
    expect(component.paymentMethod).toEqual('wallet')
  })

  it('should store prices on calling getMessage', () => {
    sessionStorage.setItem('couponDiscount', '70')
    component.getMessage([100, 1])
    expect(component.itemTotal).toBe(100)
    expect(component.promotionalDiscount).toBe(70)
    expect(component.bonus).toBe(1)
  })

  it('should remove session details from session storage', () => {
    basketService.checkout.and.returnValue(of({ orderConfirmationId: '1234123412341234' }))
    spyOn(sessionStorage, 'removeItem')
    component.placeOrder()
    expect(sessionStorage.removeItem).toHaveBeenCalledWith('paymentId')
    expect(sessionStorage.removeItem).toHaveBeenCalledWith('addressId')
    expect(sessionStorage.removeItem).toHaveBeenCalledWith('deliveryMethodId')
    expect(sessionStorage.removeItem).toHaveBeenCalledWith('couponDetails')
    expect(sessionStorage.removeItem).toHaveBeenCalledWith('couponDiscount')
  })
})


/* ===== FILE: ./frontend/src/app/address/address.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Component, EventEmitter, Input, type OnInit, Output, NgZone } from '@angular/core'
import { AddressService } from '../Services/address.service'
import { MatTableDataSource, MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow } from '@angular/material/table'
import { library } from '@fortawesome/fontawesome-svg-core'
import { faEdit, faTrashAlt } from '@fortawesome/free-regular-svg-icons/'
import { TranslateService, TranslateModule } from '@ngx-translate/core'
import { Router, RouterLink } from '@angular/router'
import { SnackBarHelperService } from '../Services/snack-bar-helper.service'
import { SelectionModel } from '@angular/cdk/collections'
import { MatIconModule } from '@angular/material/icon'
import { MatIconButton, MatButtonModule } from '@angular/material/button'
import { MatRadioButton } from '@angular/material/radio'
import { FlexModule } from '@angular/flex-layout/flex'
import { NgIf } from '@angular/common'
import { MatCardModule } from '@angular/material/card'

library.add(faEdit, faTrashAlt)

@Component({
  selector: 'app-address',
  templateUrl: './address.component.html',
  styleUrls: ['./address.component.scss'],
  imports: [MatCardModule, NgIf, TranslateModule, MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell, FlexModule, MatCellDef, MatCell, MatRadioButton, MatIconButton, RouterLink, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow, MatButtonModule, MatIconModule]
})
export class AddressComponent implements OnInit {
  @Output() emitSelection = new EventEmitter()
  @Input('allowEdit') public allowEdit: boolean = false
  @Input('addNewAddressDiv') public addNewAddressDiv: boolean = true
  @Input('showNextButton') public showNextButton: boolean = false
  public addressId: any = undefined
  public displayedColumns = ['Name', 'Address', 'Country']
  selection = new SelectionModel<Element>(false, [])
  public storedAddresses: any[]
  public dataSource
  public confirmation: any
  public error: any
  public addressExist: boolean = false

  constructor (private readonly addressService: AddressService, private readonly translate: TranslateService,
    private readonly router: Router, private readonly ngZone: NgZone, private readonly snackBarHelperService: SnackBarHelperService) { }

  ngOnInit (): void {
    if (this.allowEdit) {
      this.displayedColumns.push('Edit', 'Remove')
    } else {
      this.displayedColumns.unshift('Selection')
    }
    this.load()
  }

  load () {
    this.addressService.get().subscribe((addresses) => {
      this.addressExist = addresses.length
      this.storedAddresses = addresses
      this.dataSource = new MatTableDataSource<Element>(this.storedAddresses)
    }, (err) => {
      this.snackBarHelperService.open(err.error?.error, 'errorBar')
      console.log(err)
    })
  }

  emitSelectionToParent (id: number) {
    if (this.selection.hasValue()) {
      this.emitSelection.emit(id)
      this.addressId = id
    } else {
      this.emitSelection.emit(undefined)
      this.addressId = undefined
    }
  }

  chooseAddress () {
    sessionStorage.setItem('addressId', this.addressId)
    this.ngZone.run(async () => await this.router.navigate(['/delivery-method']))
  }

  deleteAddress (id: number) {
    this.addressService.del(id).subscribe(() => {
      this.error = null
      this.translate.get('ADDRESS_REMOVED').subscribe((addressRemoved) => {
        this.snackBarHelperService.open(addressRemoved, 'confirmBar')
      }, (translationId) => {
        this.snackBarHelperService.open(translationId, 'confirmBar')
      })
      this.load()
    }, (err) => {
      this.snackBarHelperService.open(err.error?.error, 'errorBar')
      console.log(err)
    })
  }
}


/* ===== FILE: ./frontend/src/app/address/address.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<mat-card appearance="outlined" [class.div-boundary]="!addNewAddressDiv" class="mat-elevation-z6">
  <div class="mdc-card">
    <h1  *ngIf="showNextButton">{{"TITLE_SELECT_ADDRESS" | translate}}</h1>
    <h1  *ngIf="!showNextButton">{{"MY_SAVED_ADRESSES" | translate}}</h1>
    <mat-table [dataSource]="dataSource" *ngIf="addressExist">
      <ng-container matColumnDef="Selection">
        <mat-header-cell *matHeaderCellDef fxFlex="20%"></mat-header-cell>
        <mat-cell *matCellDef="let element; let row" fxFlex="20%">
          <mat-radio-button (click)="emitSelectionToParent(element.id)" [checked]="selection.isSelected(row)"
                            (change)="$event ? selection.toggle(row) : null"></mat-radio-button>
        </mat-cell>
      </ng-container>
      <ng-container matColumnDef="Name">
        <mat-header-cell *matHeaderCellDef style="display: none;"></mat-header-cell>
        <mat-cell *matCellDef="let element" fxFlex="20%">{{ element?.fullName }}
        </mat-cell>
      </ng-container>
      <ng-container matColumnDef="Address">
        <mat-header-cell *matHeaderCellDef style="display: none;"></mat-header-cell>
        <mat-cell *matCellDef="let element" fxFlex="40%"> {{element?.streetAddress}}, {{element?.city}},
          {{element?.state}}, {{element?.zipCode}}
        </mat-cell>
      </ng-container>
      <ng-container matColumnDef="Country">
        <mat-header-cell *matHeaderCellDef style="display: none;"></mat-header-cell>
        <mat-cell *matCellDef="let element" fxFlex="20%">{{ element?.country }}</mat-cell>
      </ng-container>
      <ng-container matColumnDef="Edit">
        <mat-header-cell *matHeaderCellDef style="display: none;"></mat-header-cell>
        <mat-cell *matCellDef="let element" fxflex="10%">
          <button mat-icon-button routerLink='/address/edit/{{ element.id }}'><i class="far fa-edit"></i></button>
        </mat-cell>
      </ng-container>
      <ng-container matColumnDef="Remove">
        <mat-header-cell *matHeaderCellDef style="display: none;"></mat-header-cell>
        <mat-cell *matCellDef="let element" fxflex="10%">
          <button mat-icon-button (click)="deleteAddress(element.id)"><i class="far fa-trash-alt"></i></button>
        </mat-cell>
      </ng-container>

      <mat-header-row *matHeaderRowDef="displayedColumns"></mat-header-row>
      <mat-row *matRowDef="let row; columns: displayedColumns; let element"
              (click)="selection.toggle(row); emitSelectionToParent(element.id)"></mat-row>

    </mat-table>
    <div style="margin-top: 20px;" *ngIf="addNewAddressDiv">
      <button mat-raised-button mat-button class="btn btn-new-address" color="primary" aria-label="Add a new address"
              routerLink="/address/create">
        <mat-icon>
          add
        </mat-icon>
        <span>{{"ADD_NEW_ADDRESS" | translate}}</span>
      </button>
    </div>
    <button mat-raised-button mat-button class="btn btn-next" color="primary"
            aria-label="Proceed to payment selection" [disabled]="addressId === undefined" (click)="chooseAddress()"
            *ngIf="showNextButton">
      <mat-icon>
        navigate_next
      </mat-icon>
      <span translate>{{"LABEL_CONTINUE" | translate}}</span>
    </button>
  </div>
</mat-card>



/* ===== FILE: ./frontend/src/app/address/address.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { provideHttpClientTesting } from '@angular/common/http/testing'
import { MatCardModule } from '@angular/material/card'
import { MatFormFieldModule } from '@angular/material/form-field'
import { type ComponentFixture, fakeAsync, TestBed, waitForAsync } from '@angular/core/testing'
import { AddressComponent } from './address.component'
import { MatInputModule } from '@angular/material/input'
import { ReactiveFormsModule } from '@angular/forms'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'

import { of, throwError } from 'rxjs'
import { RouterTestingModule } from '@angular/router/testing'
import { AddressService } from '../Services/address.service'
import { AddressCreateComponent } from '../address-create/address-create.component'
import { MatTableModule } from '@angular/material/table'
import { MatExpansionModule } from '@angular/material/expansion'
import { MatDividerModule } from '@angular/material/divider'
import { MatRadioModule } from '@angular/material/radio'
import { MatDialogModule } from '@angular/material/dialog'
import { MatIconModule } from '@angular/material/icon'
import { MatTooltipModule } from '@angular/material/tooltip'
import { MatSnackBar } from '@angular/material/snack-bar'
import { TranslateModule, TranslateService } from '@ngx-translate/core'
import { EventEmitter } from '@angular/core'
import { DeliveryMethodComponent } from '../delivery-method/delivery-method.component'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('AddressComponent', () => {
  let component: AddressComponent
  let fixture: ComponentFixture<AddressComponent>
  let addressService
  let snackBar: any
  let translateService

  beforeEach(waitForAsync(() => {
    addressService = jasmine.createSpyObj('AddressService', ['get', 'del'])
    addressService.get.and.returnValue(of([]))
    addressService.del.and.returnValue(of({}))
    translateService = jasmine.createSpyObj('TranslateService', ['get'])
    translateService.get.and.returnValue(of({}))
    translateService.onLangChange = new EventEmitter()
    translateService.onTranslationChange = new EventEmitter()
    translateService.onDefaultLangChange = new EventEmitter()
    snackBar = jasmine.createSpyObj('MatSnackBar', ['open'])
    snackBar.open.and.returnValue(null)

    TestBed.configureTestingModule({
      imports: [RouterTestingModule.withRoutes([
        { path: 'delivery-method', component: DeliveryMethodComponent }
      ]),
      TranslateModule.forRoot(),
      ReactiveFormsModule,
      BrowserAnimationsModule,
      MatCardModule,
      MatTableModule,
      MatFormFieldModule,
      MatInputModule,
      MatExpansionModule,
      MatDividerModule,
      MatRadioModule,
      MatDialogModule,
      MatIconModule,
      MatTooltipModule,
      AddressComponent, AddressCreateComponent],
      providers: [
        { provide: AddressService, useValue: addressService },
        { provide: TranslateService, useValue: translateService },
        { provide: MatSnackBar, useValue: snackBar },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(AddressComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should hold no addresses when get API call fails', () => {
    addressService.get.and.returnValue(throwError('Error'))
    component.ngOnInit()
    fixture.detectChanges()
    expect(component.storedAddresses).toEqual([])
  })

  it('should log error from get address API call directly to browser console', fakeAsync(() => {
    addressService.get.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.ngOnInit()
    fixture.detectChanges()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should log error from delete address API call directly to browser console', fakeAsync(() => {
    addressService.del.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.deleteAddress(1)
    fixture.detectChanges()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should delete an address on calling deleteAddress', fakeAsync(() => {
    addressService.get.and.returnValue(of([]))
    addressService.del.and.returnValue(of([]))
    component.deleteAddress(1)
    spyOn(component, 'load')
    expect(addressService.del).toHaveBeenCalled()
    expect(addressService.get).toHaveBeenCalled()
  }))

  it('should store address id in session storage', () => {
    component.addressId = 1
    spyOn(sessionStorage, 'setItem')
    component.chooseAddress()
    expect(sessionStorage.setItem).toHaveBeenCalledWith('addressId', 1 as any)
  })
})


/* ===== FILE: ./frontend/src/app/saved-address/saved-address.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateModule } from '@ngx-translate/core'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { MatCardModule } from '@angular/material/card'
import { MatFormFieldModule } from '@angular/material/form-field'
import { type ComponentFixture, TestBed, waitForAsync } from '@angular/core/testing'
import { MatInputModule } from '@angular/material/input'
import { ReactiveFormsModule } from '@angular/forms'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'

import { MatTableModule } from '@angular/material/table'
import { MatExpansionModule } from '@angular/material/expansion'
import { MatDividerModule } from '@angular/material/divider'
import { MatRadioModule } from '@angular/material/radio'
import { MatDialogModule } from '@angular/material/dialog'
import { SavedAddressComponent } from './saved-address.component'
import { AddressComponent } from '../address/address.component'
import { RouterTestingModule } from '@angular/router/testing'
import { MatIconModule } from '@angular/material/icon'
import { MatTooltipModule } from '@angular/material/tooltip'
import { MatSnackBar } from '@angular/material/snack-bar'
import { MatCheckboxModule } from '@angular/material/checkbox'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('SavedAddressComponent', () => {
  let component: SavedAddressComponent
  let fixture: ComponentFixture<SavedAddressComponent>
  let snackBar: any

  beforeEach(waitForAsync(() => {
    TestBed.configureTestingModule({
      imports: [RouterTestingModule,
        TranslateModule.forRoot(),
        ReactiveFormsModule,
        BrowserAnimationsModule,
        MatCardModule,
        MatTableModule,
        MatFormFieldModule,
        MatInputModule,
        MatExpansionModule,
        MatDividerModule,
        MatRadioModule,
        MatDialogModule,
        MatIconModule,
        MatTooltipModule,
        MatCheckboxModule,
        SavedAddressComponent, AddressComponent],
      providers: [{ provide: MatSnackBar, useValue: snackBar }, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(SavedAddressComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })
})


/* ===== FILE: ./frontend/src/app/saved-address/saved-address.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<div class="main-wrapper">
    <app-address [allowEdit]="true"></app-address>
</div>


/* ===== FILE: ./frontend/src/app/saved-address/saved-address.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Component } from '@angular/core'
import { AddressComponent } from '../address/address.component'

@Component({
  selector: 'app-saved-address',
  templateUrl: './saved-address.component.html',
  styleUrls: ['./saved-address.component.scss'],
  imports: [AddressComponent]
})

export class SavedAddressComponent {
}


/* ===== FILE: ./frontend/src/app/product-details/product-details.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<mat-dialog-content>

  <div class="container" fxLayout="column">
    <div fxLayout="row" fxLayout.lt-sm="column" fxLayoutGap="20px">
      <div fxFlex="noshrink">
        <img class="img-thumbnail" [src]="'assets/public/images/products/'+data.productData.image" alt={{data.productData.name}}>
      </div>

      <div>
        <h1>{{data.productData.name}}</h1>
        <div [innerHTML]="data.productData.description"></div>
        <br/>
        <div>
          <p class="item-price">{{data.productData.price}}&curren;</p>
          <div *ngIf="data.productData.points > 0" matTooltip="{{'LABEL_BONUS' | translate}}"
               aria-label="Bonus points when buying the product">
            <span class="fa-2x fa-layers fa-fw">
            <i class="fas fa-crown"></i>
            <span class="fa-layers-counter fa-layers-bottom-left fa-2x warn-notification" style="font-size: 47px;">{{ data.productData.points }}</span>
          </span>
          </div>
        </div>
      </div>
    </div>

    <mat-divider class="detail-divider"></mat-divider>
    <button mat-button style="height: 0; position: absolute;">
      <!-- 'absorbs' the auto-focus behavior -->
    </button>
    <mat-expansion-panel class="mat-elevation-z0" aria-label="Expand for Reviews">
      <mat-expansion-panel-header>
        <mat-panel-title>
          <span style="margin-right: 5px;" translate>LABEL_REVIEWS</span> <span>({{(reviews$| async)?.length}})</span>
        </mat-panel-title>
      </mat-expansion-panel-header>
      <button mat-button style="height: 0; position: absolute;">
        <!-- 'absorbs' the auto-focus behavior -->
      </button>
      <div *ngIf="(reviews$| async)?.length >= 1; else emptyResult">
        <div *ngFor="let review of reviews$|async" class="comment">
          <div fxLayout="row">
            <div class="review-text"
                 (click)="review.author !== 'Anonymous' && review.author === author && editReview(review)"
                 matTooltipDisabled="{{review.author !== author}}" matTooltip="{{'LABEL_EDIT_REVIEW' | translate}}"
                 matTooltipPosition="right">
              <cite>{{review.author}}</cite>
              <p>{{ review.message }}</p>
            </div>
            <div class="like-container">
              <button mat-icon-button (click)="likeReview(review)" [disabled]="review.liked || !isLoggedIn()"
                      class="rw-button" aria-label="Rate a helpful review">
                    <mat-icon>thumb_up</mat-icon>
                    <span
                      class="like-counter accent-notification">{{ review.likesCount }}</span>
              </button>
            </div>
          </div>
        </div>
      </div>

      <ng-template #emptyResult>
        <div>
            <span class="noResultText" translate>
            EMPTY_REVIEW_LIST
            </span>
        </div>
      </ng-template>
    </mat-expansion-panel>

      <mat-divider class="detail-divider"></mat-divider>

      <h4 [style.display]="isLoggedIn() ? 'block' : 'none' " translate>WRITE_REVIEW</h4>
      <mat-form-field appearance="outline" color="accent"
                      [style.display]="isLoggedIn() ? 'block' : 'none' " floatLabel="always">
        <mat-label >{{"LABEL_REVIEW" | translate}}</mat-label>
        <mat-hint>
          <i class="fas fa-exclamation-circle"></i>
          <em style="margin-left:5px;">{{ 'MAX_TEXTAREA_LENGTH' | translate: {length: '160'} }}</em>
        </mat-hint>
        <textarea [formControl]="reviewControl" #textPut cols="50" matInput
                  placeholder="{{'WRITE_REVIEW_PLACEHOLDER' | translate}}"
                  matTextareaAutosize matAutosizeMinRows="2" maxlength="160"
                  matAutosizeMaxRows="4" aria-label="Text field to review a product"
                  ></textarea>
        <mat-hint align="end">{{textPut.value?.length || 0}}/160</mat-hint>
      </mat-form-field>

      <mat-dialog-actions align="end" class="dialogAction">
        <button mat-stroked-button mat-dialog-close class="close-dialog buttons" aria-label="Close Dialog">
          <mat-icon>
            close
          </mat-icon>
          <span>  {{'BTN_CLOSE' | translate}}</span>
        </button>

        <button type="submit" id="submitButton" [disabled]="!textPut.value.trim()" mat-raised-button color="primary"
                (click)="addReview(textPut)" style="margin-left: 5px;"
                aria-label="Send the review" class="buttons"
                [style.display]="isLoggedIn() ? 'flex' : 'none' ">
          <mat-icon>
            send
          </mat-icon>
          <span>
            {{'BTN_SUBMIT' | translate}}
          </span>
        </button>
      </mat-dialog-actions>
  </div>
</mat-dialog-content>


/* ===== FILE: ./frontend/src/app/product-details/product-details.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateModule } from '@ngx-translate/core'
import { ProductReviewEditComponent } from '../product-review-edit/product-review-edit.component'
import { By } from '@angular/platform-browser'
import { MatDividerModule } from '@angular/material/divider'
import { UserService } from '../Services/user.service'
import { ProductReviewService } from '../Services/product-review.service'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'
import { MatButtonModule } from '@angular/material/button'
import { MatInputModule } from '@angular/material/input'
import { MatFormFieldModule } from '@angular/material/form-field'
import { MAT_DIALOG_DATA, MatDialog, MatDialogModule } from '@angular/material/dialog'
import { MatBadgeModule } from '@angular/material/badge'
import { type ComponentFixture, fakeAsync, flush, TestBed, waitForAsync } from '@angular/core/testing'
import { MatTooltipModule } from '@angular/material/tooltip'
import { MatIconModule } from '@angular/material/icon'
import { MatExpansionModule } from '@angular/material/expansion'

import { ProductDetailsComponent } from './product-details.component'
import { of, throwError } from 'rxjs'
import { ReactiveFormsModule } from '@angular/forms'
import { MatSnackBarModule } from '@angular/material/snack-bar'
import { type Product } from '../Models/product.model'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('ProductDetailsComponent', () => {
  let component: ProductDetailsComponent
  let fixture: ComponentFixture<ProductDetailsComponent>
  let userService: any
  let productReviewService: any
  let dialog: any
  let dialogRefMock

  beforeEach(waitForAsync(() => {
    userService = jasmine.createSpyObj('UserService', ['whoAmI'])
    userService.whoAmI.and.returnValue(of({}))
    productReviewService = jasmine.createSpyObj('ProductReviewService', ['get', 'create'])
    productReviewService.get.and.returnValue(of([]))
    productReviewService.create.and.returnValue(of({}))
    dialog = jasmine.createSpyObj('Dialog', ['open'])
    dialogRefMock = {
      afterClosed: () => of({})
    }
    dialog.open.and.returnValue(dialogRefMock)

    TestBed.configureTestingModule({
      imports: [TranslateModule.forRoot(),
        ReactiveFormsModule,
        BrowserAnimationsModule,
        MatDialogModule,
        MatFormFieldModule,
        MatInputModule,
        MatButtonModule,
        MatDividerModule,
        MatBadgeModule,
        MatIconModule,
        MatTooltipModule,
        MatExpansionModule,
        MatSnackBarModule,
        ProductDetailsComponent],
      providers: [
        { provide: UserService, useValue: userService },
        { provide: ProductReviewService, useValue: productReviewService },
        { provide: MatDialog, useValue: dialog },
        { provide: MAT_DIALOG_DATA, useValue: { productData: {} } },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(ProductDetailsComponent)
    component = fixture.componentInstance
    fixture.autoDetectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should post anonymous review if no user email is returned', () => {
    component.data = { productData: { id: 42 } as Product }
    userService.whoAmI.and.returnValue(of({}))
    component.ngOnInit()
    const textArea: HTMLTextAreaElement = fixture.debugElement.query(By.css('textarea')).nativeElement
    textArea.value = 'Great product!'
    const buttonDe = fixture.debugElement.query(By.css('#submitButton'))
    buttonDe.triggerEventHandler('click', null)
    const reviewObject = { message: 'Great product!', author: 'Anonymous' }
    expect(productReviewService.create.calls.count()).toBe(1)
    expect(productReviewService.create.calls.argsFor(0)[0]).toBe(42)
    expect(productReviewService.create.calls.argsFor(0)[1]).toEqual(reviewObject)
  })

  it('should post review with user email as author', () => {
    component.data = { productData: { id: 42 } as Product }
    userService.whoAmI.and.returnValue(of({ email: 'horst@juice-sh.op' }))
    component.ngOnInit()
    const textArea: HTMLTextAreaElement = fixture.debugElement.query(By.css('textarea')).nativeElement
    textArea.value = 'Great product!'
    const buttonDe = fixture.debugElement.query(By.css('#submitButton'))
    buttonDe.triggerEventHandler('click', null)
    const reviewObject = { message: 'Great product!', author: 'horst@juice-sh.op' }
    expect(productReviewService.create.calls.count()).toBe(1)
    expect(productReviewService.create.calls.argsFor(0)[0]).toBe(42)
    expect(productReviewService.create.calls.argsFor(0)[1]).toEqual(reviewObject)
  })

  it('should log errors when retrieving user directly to browser console', fakeAsync(() => {
    component.data = { productData: { id: 42 } as Product }
    userService.whoAmI.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.ngOnInit()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should log errors when posting review directly to browser console', fakeAsync(() => {
    component.data = { productData: { id: 42 } as Product }
    userService.whoAmI.and.returnValue(of({}))
    productReviewService.create.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.ngOnInit()
    const textArea: HTMLTextAreaElement = fixture.debugElement.query(By.css('textarea')).nativeElement
    textArea.value = 'Great product!'
    const buttonDe = fixture.debugElement.query(By.css('#submitButton'))
    buttonDe.triggerEventHandler('click', null)
    expect(console.log).toHaveBeenCalledWith('Error')
    fixture.destroy()
    flush()
  }))

  it('should refresh reviews after posting a review', () => {
    component.data = { productData: { id: 42 } as Product }
    productReviewService.create.and.returnValue(of({}))
    productReviewService.get.and.returnValue(of([{ id: '42', message: 'Review 1', author: 'Anonymous' }]))
    userService.whoAmI.and.returnValue(of({}))
    component.ngOnInit()
    const textArea: HTMLTextAreaElement = fixture.debugElement.query(By.css('textarea')).nativeElement
    textArea.value = 'Great product!'
    const buttonDe = fixture.debugElement.query(By.css('#submitButton'))
    buttonDe.triggerEventHandler('click', null)
    expect(productReviewService.create).toHaveBeenCalled()
    expect(productReviewService.get).toHaveBeenCalled()
  })

  it('should open a modal dialog with review editor', () => {
    component.data = { productData: { id: 42 } as Product }
    userService.whoAmI.and.returnValue(of({ email: 'horst@juice-sh.op' }))
    productReviewService.get.and.returnValue(of([{ id: '42', message: 'Great product!', author: 'horst@juice-sh.op' }]))
    component.ngOnInit()
    fixture.detectChanges()
    const buttonDe = fixture.debugElement.query(By.css('div.review-text'))
    buttonDe.triggerEventHandler('click', null)
    expect(dialog.open.calls.count()).toBe(1)
    expect(dialog.open.calls.argsFor(0)[0]).toBe(ProductReviewEditComponent)
    expect(dialog.open.calls.argsFor(0)[1].data).toEqual({ reviewData: { id: '42', message: 'Great product!', author: 'horst@juice-sh.op' } })
  })

  it('should refresh reviews of product after editing a review', () => {
    component.data = { productData: { id: 42 } as Product }
    userService.whoAmI.and.returnValue(of({ email: 'horst@juice-sh.op' }))
    productReviewService.get.and.returnValue(of([{ id: '42', message: 'Great product!', author: 'horst@juice-sh.op' }]))
    component.ngOnInit()
    fixture.detectChanges()
    const buttonDe = fixture.debugElement.query(By.css('div.review-text'))
    buttonDe.triggerEventHandler('click', null)
    expect(productReviewService.get).toHaveBeenCalledWith(42)
  })
})


/* ===== FILE: ./frontend/src/app/product-details/product-details.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { ProductReviewEditComponent } from '../product-review-edit/product-review-edit.component'
import { UserService } from '../Services/user.service'
import { ProductReviewService } from '../Services/product-review.service'
import { Component, Inject, type OnDestroy, type OnInit } from '@angular/core'
import { MAT_DIALOG_DATA, MatDialog, MatDialogContent, MatDialogActions, MatDialogClose } from '@angular/material/dialog'
import { library } from '@fortawesome/fontawesome-svg-core'
import { faArrowCircleLeft, faCrown, faPaperPlane, faThumbsUp, faUserEdit } from '@fortawesome/free-solid-svg-icons'
import { UntypedFormControl, Validators, FormsModule, ReactiveFormsModule } from '@angular/forms'
import { MatSnackBar } from '@angular/material/snack-bar'
import { SnackBarHelperService } from '../Services/snack-bar-helper.service'
import { type Review } from '../Models/review.model'
import { type Product } from '../Models/product.model'
import { MatInputModule } from '@angular/material/input'
import { MatFormFieldModule, MatLabel, MatHint } from '@angular/material/form-field'
import { MatIconModule } from '@angular/material/icon'
import { TranslateModule } from '@ngx-translate/core'
import { MatExpansionPanel, MatExpansionPanelHeader, MatExpansionPanelTitle } from '@angular/material/expansion'
import { MatButtonModule, MatIconButton } from '@angular/material/button'
import { MatDivider } from '@angular/material/divider'
import { MatTooltip } from '@angular/material/tooltip'
import { NgIf, NgFor, AsyncPipe } from '@angular/common'
import { FlexModule } from '@angular/flex-layout/flex'

library.add(faPaperPlane, faArrowCircleLeft, faUserEdit, faThumbsUp, faCrown)

@Component({
  selector: 'app-product-details',
  templateUrl: './product-details.component.html',
  styleUrls: ['./product-details.component.scss'],
  imports: [MatDialogContent, FlexModule, NgIf, MatTooltip, MatDivider, MatButtonModule, MatExpansionPanel, MatExpansionPanelHeader, MatExpansionPanelTitle, TranslateModule, NgFor, MatIconButton, MatIconModule, MatFormFieldModule, MatLabel, MatHint, MatInputModule, FormsModule, ReactiveFormsModule, MatDialogActions, MatDialogClose, AsyncPipe]
})
export class ProductDetailsComponent implements OnInit, OnDestroy {
  public author: string = 'Anonymous'
  public reviews$: any
  public userSubscription: any
  public reviewControl: UntypedFormControl = new UntypedFormControl('', [Validators.maxLength(160)])
  constructor (private readonly dialog: MatDialog,
    @Inject(MAT_DIALOG_DATA) public data: { productData: Product }, private readonly productReviewService: ProductReviewService,
    private readonly userService: UserService, private readonly snackBar: MatSnackBar, private readonly snackBarHelperService: SnackBarHelperService) { }

  ngOnInit (): void {
    this.data.productData.points = Math.round(this.data.productData.price / 10)
    this.reviews$ = this.productReviewService.get(this.data.productData.id)
    this.userSubscription = this.userService.whoAmI().subscribe((user: any) => {
      if (user?.email) {
        this.author = user.email
      } else {
        this.author = 'Anonymous'
      }
    }, (err) => { console.log(err) })
  }

  ngOnDestroy () {
    if (this.userSubscription) {
      this.userSubscription.unsubscribe()
    }
  }

  addReview (textPut: HTMLTextAreaElement) {
    const review = { message: textPut.value, author: this.author }

    textPut.value = ''
    this.productReviewService.create(this.data.productData.id, review).subscribe(() => {
      this.reviews$ = this.productReviewService.get(this.data.productData.id)
    }, (err) => { console.log(err) })
    this.snackBarHelperService.open('CONFIRM_REVIEW_SAVED')
  }

  editReview (review: Review) {
    this.dialog.open(ProductReviewEditComponent, {
      width: '500px',
      height: 'max-content',
      data: {
        reviewData: review
      }
    }).afterClosed().subscribe(() => (this.reviews$ = this.productReviewService.get(this.data.productData.id)))
  }

  likeReview (review: Review) {
    this.productReviewService.like(review._id).subscribe(() => {
      console.log('Liked ' + review._id)
    })
    setTimeout(() => (this.reviews$ = this.productReviewService.get(this.data.productData.id)), 200)
  }

  isLoggedIn () {
    return localStorage.getItem('token')
  }
}


/* ===== FILE: ./frontend/src/app/web3-sandbox/web3-sandbox.module.ts ===== */

import { NgModule, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core'
import { CommonModule } from '@angular/common'
import { ReactiveFormsModule, FormsModule } from '@angular/forms'
import { RouterModule, type Routes } from '@angular/router'
import { ConfigurationService } from '../Services/configuration.service'
import { OverlayContainer } from '@angular/cdk/overlay'
import { MatCardModule } from '@angular/material/card'
import { MatInputModule } from '@angular/material/input'
import { MatButtonModule } from '@angular/material/button'
import { MatSnackBarModule } from '@angular/material/snack-bar'

import { Web3SandboxComponent } from './web3-sandbox.component'
import { CodemirrorModule } from '@ctrl/ngx-codemirror'
import 'codemirror/mode/javascript/javascript'
import 'codemirror/mode/markdown/markdown'
import 'codemirror-solidity/solidity'
import { TranslateModule } from '@ngx-translate/core'

const routes: Routes = [
  {
    path: '',
    component: Web3SandboxComponent
  }
]

@NgModule({
  imports: [
    CodemirrorModule,
    CommonModule,
    RouterModule.forChild(routes),
    TranslateModule,
    FormsModule,
    ReactiveFormsModule,
    MatButtonModule,
    MatCardModule,
    MatInputModule,
    MatSnackBarModule,
    Web3SandboxComponent
  ],
  schemas: [CUSTOM_ELEMENTS_SCHEMA]
})
export class Web3SandboxModule {
  constructor (
    public configurationService: ConfigurationService,
    public overlayContainer: OverlayContainer
  ) {
    configurationService.getApplicationConfiguration().subscribe((conf) => {
      overlayContainer
        .getContainerElement()
        .classList.add(conf.application.theme + '-theme')
    })
  }
}


/* ===== FILE: ./frontend/src/app/web3-sandbox/web3-sandbox.component.html ===== */

<div class="sandbox-container mat-elevation-z6">
  <div class="sandbox-container_body">
    <div class="sandbox-container_body_left">
      <div class="editor-title">{{"TITLE_CONTRACT_EDITOR" | translate}}</div>
      <ngx-codemirror
        [(ngModel)]="code"
        [options]="editorOptions"
      ></ngx-codemirror>
    </div>
    <div class="sandbox-container_body_right">
      <div class="playground-wallet">
        <div class="metamask-button">
          <button
            mat-raised-button
            color="accent"
            type="button"
            (click)="handleAuth()"
          >
            <span *ngIf="!session">{{"BTN_CONNECT_METAMASK" | translate}}</span>
            <span *ngIf="session"
              >{{ userData.address.substring(0, 6) }}...{{
                userData.address.slice(-6)
              }}</span
            >
          </button>
        </div>
      </div>
      <h2 translate>TITLE_WEB3_SANDBOX</h2>
      <ul>
        <li translate>EXPLANATION_SMART_CONTRACT_DEPLOYMENT</li>
        <li translate>EXPLANATION_GWEI_VALUE_POST_COMPILATION</li>
      </ul>
      <mat-form-field appearance="outline" color="accent">
        <mat-label>{{ "LABEL_SELECT_COMPILER_VERSION" | translate}}</mat-label>
        <select matNativeControl [(ngModel)]="selectedCompilerVersion">
          <option *ngFor="let version of compilerVersions" [value]="version">
            {{ version }}
          </option>
        </select>
      </mat-form-field>
      <button
        type="button"
        mat-raised-button
        (click)="compileAndFetchContracts(code)"
      >
        <mat-icon>build</mat-icon>
        {{ "BTN_COMPILE_CONTRACT" | translate}}
      </button>
      <div *ngIf="compilerErrors.length > 0" class="error-container mat-elevation-z6">
        <h4>Compiler Errors:</h4>
        <ul>
          <li class="error" *ngFor="let error of compilerErrors">
            {{ error.formattedMessage }}
          </li>
        </ul>
      </div>
      <div *ngIf="compiledContracts">
        <h3 class="contracts-title">{{ "TITLE_CONTRACT_DEPLOYMENT" | translate}}</h3>
        <div class="form-fields-container">
          <mat-form-field
            class="contract-selector"
            appearance="outline"
            color="accent"
          >
            <mat-label>{{ "LABEL_COMPILED_CONTRACTS" | translate}}</mat-label>
            <select matNativeControl [(ngModel)]="selectedContractName">
              <option
                *ngFor="let contractName of contractNames"
                [value]="contractName"
              >
                {{ contractName }}
              </option>
            </select>
          </mat-form-field>
          <mat-form-field
            class="gwei-input"
            appearance="outline"
            color="accent"
          >
            <mat-label>{{ "GWEI_VALUE_FOR_SENDING_ETH" | translate }}</mat-label>
            <input
              matInput
              type="number"
              [(ngModel)]="commonGweiValue"
            />
          </mat-form-field>
        </div>
        <button
          mat-raised-button
          type="button"
          (click)="deploySelectedContract()"
        >
          <mat-icon>link</mat-icon>
          {{ "BTN_DEPLOY_SELECTED_CONTRACT" | translate}}
        </button>
      </div>
      <div class="deployedaddresstext" *ngIf="deployedContractAddress">
        {{ "LABEL_CONTRACT_ADDRESS" | translate }} {{ deployedContractAddress }}
      </div>
      <div class="invokecontainer mat-elevation-z6" *ngIf="deployedContractAddress">
        <h3 translate>TITLE_INTERACT_WITH_CONTRACT</h3>
        <div *ngFor="let func of contractFunctions">
          <div class="function-container">
            <ng-container *ngIf="func.inputs.length > 0; else noInputs">
              <div class="functionwtext-container">
                <button
                  mat-raised-button
                  type="button"
                  (click)="invokeFunction(func)"
                >
                  <mat-icon>call_to_action</mat-icon>
                  {{ "BTN_INVOKE" | translate}} {{ func.name }}
                </button>
                <mat-form-field appearance="outline" color="accent">
                  <textarea
                    matAutosizeMinRows="4"
                    matAutosizeMaxRows="4"
                    matTextareaAutosize
                    matInput
                    placeholder="({{ func.inputHints }})"
                    [(ngModel)]="func.inputValues"
                  ></textarea>
                </mat-form-field>
              </div>
              <div class="invoke-output" *ngIf="func.outputValue !== ''">
                {{ "LABEL_OUTPUT_FOR" | translate }} {{ func.name }}: {{ func.outputValue }}
              </div>
            </ng-container>
            <ng-template #noInputs>
              <div>
                <button
                  mat-raised-button
                  type="button"
                  (click)="invokeFunction(func)"
                >
                  <mat-icon>call_to_action</mat-icon>
                  {{ "BTN_INVOKE" | translate}} {{ func.name }}
                </button>
                <div class="invoke-output" *ngIf="func.outputValue !== ''">
                  {{ "LABEL_OUTPUT_FOR" | translate }} {{ func.name }}: {{ func.outputValue }}
                </div>
              </div>
            </ng-template>
          </div>
        </div>
        <div class="output-container mat-elevation-z6">
          <div *ngIf="invokeOutput !== ''">{{ "LABEL_OUTPUT" | translate}}: {{ invokeOutput }}</div>
        </div>
      </div>
    </div>
  </div>
  <img src="assets/public/images/padding/11px.png"/>
</div>


/* ===== FILE: ./frontend/src/app/web3-sandbox/web3-sandbox.component.ts ===== */

import { Component, ChangeDetectorRef } from '@angular/core'
import { KeysService } from '../Services/keys.service'
import { SnackBarHelperService } from '../Services/snack-bar-helper.service'
import { getDefaultProvider, ethers } from 'ethers'
import {
  createClient,
  connect,
  disconnect,
  getAccount,
  InjectedConnector
} from '@wagmi/core'
import {
  solidityCompiler
} from 'solidity-browser-compiler'
import { MatInputModule } from '@angular/material/input'
import { MatFormFieldModule, MatLabel } from '@angular/material/form-field'
import { TranslateModule } from '@ngx-translate/core'
import { NgIf, NgFor } from '@angular/common'
import { MatButtonModule } from '@angular/material/button'
import { FormsModule } from '@angular/forms'
import { CodemirrorModule } from '@ctrl/ngx-codemirror'
import { MatIconModule } from '@angular/material/icon'

// eslint-disable-next-line @typescript-eslint/no-unused-vars
const client = createClient({
  autoConnect: true,
  provider: getDefaultProvider()
})
const { ethereum } = window
const compilerReleases = {
  '0.8.21': 'soljson-v0.8.21+commit.d9974bed.js',
  '0.8.9': 'soljson-v0.8.9+commit.e5eed63a.js',
  '0.7.6': 'soljson-v0.7.6+commit.7338295f.js',
  '0.6.12': 'soljson-v0.6.12+commit.27d51765.js',
  '0.5.17': 'soljson-v0.5.17+commit.d19bba13.js',
  '0.4.26': 'soljson-v0.4.26+commit.4563c3fc.js',
  '0.3.6': 'soljson-v0.3.6+commit.3fc68da5.js',
  '0.2.2': 'soljson-v0.2.2+commit.ef92f566.js',
  '0.1.7': 'soljson-v0.1.7+commit.b4e666cc.js'
}
@Component({
  selector: 'app-web3-sandbox',
  templateUrl: './web3-sandbox.component.html',
  styleUrls: ['./web3-sandbox.component.scss'],
  imports: [CodemirrorModule, FormsModule, MatButtonModule, MatIconModule, NgIf, TranslateModule, MatFormFieldModule, MatLabel, MatInputModule, NgFor]
})
export class Web3SandboxComponent {
  constructor (
    private readonly keysService: KeysService,
    private readonly snackBarHelperService: SnackBarHelperService,
    private readonly changeDetectorRef: ChangeDetectorRef
  ) {}

  ngOnInit (): void {
    this.handleAuth()
    window.ethereum.on('chainChanged', this.handleChainChanged.bind(this))
  }

  userData: object
  session = false
  metamaskAddress = ''
  selectedContractName: string
  compiledContracts = []
  deployedContractAddress = ''
  contractNames = []
  commonGweiValue: number = 0
  contractFunctions = []
  invokeOutput = ''
  selectedCompilerVersion: string = '0.8.21'
  compilerVersions: string[] = Object.keys(compilerReleases)
  compilerErrors = []

  code: string = `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.14;

contract HelloWorld {
    function get()public pure returns (string memory){
        return 'Hello Contracts';
    }
}`
  editorOptions = {
    mode: 'text/x-solidity',
    theme: 'dracula',
    lineNumbers: true,
    lineWrapping: true
  }

  async compileAndFetchContracts (code: string) {
    try {
      this.deployedContractAddress = ''
      const selectedVersion = compilerReleases[
        this.selectedCompilerVersion
      ] as string

      if (!selectedVersion) {
        console.error('Selected compiler version not found.')
        return
      }

      const compilerInput = {
        version: `https://binaries.soliditylang.org/bin/${selectedVersion}`,
        contractBody: code
      }
      const output = await solidityCompiler(compilerInput)
      if (output.errors && output.errors.length > 0 && !output.contracts) {
        this.compiledContracts = null
        console.log(output.errors)
        this.compilerErrors.push(...output.errors)
      } else {
        this.compilerErrors = []
        console.log('output', output)
        this.compiledContracts = output.contracts.Compiled_Contracts
        this.contractNames = Object.keys(this.compiledContracts)
        this.selectedContractName = this.contractNames[0]
      }
    } catch (error) {
      console.error('Error compiling contracts:', error)
    }
  }

  async deploySelectedContract () {
    if (!this.session) {
      this.snackBarHelperService.open('PLEASE_CONNECT_WEB3_WALLET', 'errorBar')
      return
    }
    try {
      const selectedContractName = this.selectedContractName
      const selectedContract = this.compiledContracts[selectedContractName]

      if (!selectedContract) {
        console.error('Selected contract not found.')
        return
      }

      const provider = new ethers.providers.Web3Provider(window.ethereum)
      const signer = provider.getSigner()

      const contractBytecode = selectedContract.evm.bytecode.object
      const contractAbi = selectedContract.abi

      const factory = new ethers.ContractFactory(
        contractAbi,
        contractBytecode,
        signer
      )
      const transactionOptions: ethers.PayableOverrides = {}
      if (this.commonGweiValue > 0) {
        transactionOptions.value = ethers.utils.parseUnits(
          this.commonGweiValue.toString(),
          'gwei'
        )
      }
      const contract = await factory.deploy(transactionOptions)
      await contract.deployed()
      this.deployedContractAddress = contract.address

      this.contractFunctions = contractAbi
        .filter((item) => item.type === 'function')
        .map((func) => {
          const inputHints =
            func.inputs.length > 0
              ? this.getInputHints(func.inputs)
              : 'No inputs'
          return {
            ...func,
            inputValues: '',
            outputValue: '',
            inputHints
          }
        })

      console.log(this.contractFunctions)
    } catch (error) {
      console.error('Error deploying contract:', error)
    }
  }

  getInputHints (inputs: Array<{ name: string, type: string }>): string {
    return inputs.map((input) => `${input.name}: ${input.type}`).join(', ')
  }

  parseInputValue (value: string, type: string) {
    if (type === 'bool') {
      return value.toLowerCase() === 'true'
    } else {
      return value
    }
  }

  async invokeFunction (func) {
    if (!this.session) {
      this.snackBarHelperService.open('PLEASE_CONNECT_WEB3_WALLET', 'errorBar')
      return
    }
    try {
      const selectedContract =
        this.compiledContracts[this.selectedContractName]

      const provider = new ethers.providers.Web3Provider(window.ethereum)
      const signer = provider.getSigner()
      const contract = new ethers.Contract(
        this.deployedContractAddress,
        selectedContract.abi,
        signer
      )

      const inputs =
        func.inputValues.trim() !== ''
          ? func.inputValues.split(',').map((value, index) => {
            const inputType = func.inputs[index].type
            return this.parseInputValue(value.trim(), inputType)
          })
          : []
      const transactionOptions: ethers.PayableOverrides = {}
      if (this.commonGweiValue > 0) {
        transactionOptions.value = ethers.utils.parseUnits(
          this.commonGweiValue.toString(),
          'gwei'
        )
      }
      const transaction = await contract.functions[func.name](
        ...inputs,
        transactionOptions
      )
      console.log(transaction)

      if (
        func.outputs.length > 0 &&
        (func.stateMutability === 'view' || func.stateMutability === 'pure')
      ) {
        console.log('hello')
        const outputValue = transaction[0].toString()
        const updatedFunc = this.contractFunctions.find(
          (f) => f.name === func.name
        )
        if (updatedFunc) {
          updatedFunc.outputValue = outputValue
          const index = this.contractFunctions.indexOf(func)
          if (index !== -1) {
            this.contractFunctions[index] = updatedFunc
          }
        }
        console.log(func.outputValue)
      }
      console.log('Invoked:', transaction)
    } catch (error) {
      console.error('Error invoking function', error)
      const updatedFunc = this.contractFunctions.find(
        (f) => f.name === func.name
      )
      if (updatedFunc) {
        updatedFunc.outputValue = error.message
        const index = this.contractFunctions.indexOf(func)
        if (index !== -1) {
          this.contractFunctions[index] = updatedFunc
        }
      }
    }
  }

  async handleChainChanged (chainId: string) {
    await this.handleAuth()
  }

  async handleAuth () {
    try {
      const { isConnected } = getAccount()

      if (isConnected) {
        await disconnect()
      }
      if (!window.ethereum) {
        this.snackBarHelperService.open('PLEASE_INSTALL_WEB3_WALLET', 'errorBar')
        return
      }

      const provider = await connect({ connector: new InjectedConnector() })
      this.metamaskAddress = provider.account
      this.userData = {
        address: provider.account,
        chain: provider.chain.id,
        network: 'evm'
      }
      await ethereum.request({
        method: 'wallet_addEthereumChain',
        params: [
          {
            chainId: '0xaa36a7',
            chainName: 'Sepolia Test Network',
            nativeCurrency: {
              name: 'SepoliaETH',
              symbol: 'ETH',
              decimals: 18
            },
            rpcUrls: ['https://ethereum-sepolia.blockpi.network/v1/rpc/public'],
            blockExplorerUrls: ['https://sepolia.etherscan.io/']
          }
        ]
      })
      const targetChainId = '11155111'
      const currentChainId = String(provider.chain?.id)

      if (provider && currentChainId !== targetChainId) {
        this.session = false
        this.snackBarHelperService.open('PLEASE_CONNECT_TO_SEPOLIA_NETWORK', 'errorBar')
      } else {
        console.log('Should show ethereum chain now')
        this.session = true
      }
      console.log('session', this.session)
      this.changeDetectorRef.detectChanges()
    } catch (err) {
      console.log('An error occurred')
    }
  }
}


/* ===== FILE: ./frontend/src/app/track-result/track-result.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { ActivatedRoute } from '@angular/router'
import { MatTableDataSource, MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow } from '@angular/material/table'
import { Component, type OnInit } from '@angular/core'
import { TrackOrderService } from '../Services/track-order.service'
import { DomSanitizer } from '@angular/platform-browser'
import { library } from '@fortawesome/fontawesome-svg-core'
import { faHome, faSync, faTruck, faTruckLoading, faWarehouse } from '@fortawesome/free-solid-svg-icons'
import { ExtendedModule } from '@angular/flex-layout/extended'
import { FlexModule } from '@angular/flex-layout/flex'
import { NgIf } from '@angular/common'
import { TranslateModule } from '@ngx-translate/core'
import { MatCardModule } from '@angular/material/card'

library.add(faWarehouse, faSync, faTruckLoading, faTruck, faHome)

export enum Status {
  New,
  Packing,
  Transit,
  Delivered
}

@Component({
  selector: 'app-track-result',
  templateUrl: './track-result.component.html',
  styleUrls: ['./track-result.component.scss'],
  imports: [MatCardModule, TranslateModule, NgIf, FlexModule, MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, ExtendedModule, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow]
})
export class TrackResultComponent implements OnInit {
  public displayedColumns = ['product', 'price', 'quantity', 'total price']
  public dataSource = new MatTableDataSource()
  public orderId?: string
  public results: any = {}
  public status: Status = Status.New
  public Status = Status
  constructor (private readonly route: ActivatedRoute, private readonly trackOrderService: TrackOrderService, private readonly sanitizer: DomSanitizer) {}

  ngOnInit (): void {
    this.orderId = this.route.snapshot.queryParams.id
    this.trackOrderService.find(this.orderId).subscribe((results) => {
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      this.results.orderNo = this.sanitizer.bypassSecurityTrustHtml(`<code>${results.data[0].orderId}</code>`)
      this.results.email = results.data[0].email
      this.results.totalPrice = results.data[0].totalPrice
      this.results.products = results.data[0].products
      this.results.eta = results.data[0].eta !== undefined ? results.data[0].eta : '?'
      this.results.bonus = results.data[0].bonus
      this.dataSource.data = this.results.products
      if (results.data[0].delivered) {
        this.status = Status.Delivered
      } else if (this.route.snapshot.data.type) {
        this.status = Status.New
      } else if (this.results.eta > 2) {
        this.status = Status.Packing
      } else {
        this.status = Status.Transit
      }
    })
  }
}


/* ===== FILE: ./frontend/src/app/track-result/track-result.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
-->


<mat-card appearance="outlined" class="mat-elevation-z6 mat-own-card">
  <div class="mdc-card">
    <h1><span translate>TITLE_SEARCH_RESULTS</span> - <span [innerHtml]="results.orderNo"></span></h1>
    <div style="text-align: center;">
      <h3 translate>LABEL_EXPECTED_DELIVERY</h3>
      <div class="container-fluid well">
        <div class="row fa-4x">
          <span *ngIf="status === Status.New"><i class="fas fa-warehouse confirmation"></i></span>
          <span *ngIf="status !== Status.New"><i class="fas fa-warehouse"></i></span>
          <span *ngIf="status === Status.Packing"><i class="fas fa-truck-loading confirmation"></i></span>
          <span *ngIf="status !== Status.Packing"><i class="fas fa-truck-loading"></i></span>
          <span *ngIf="status === Status.Transit"><i class="fas fa-truck confirmation"></i></span>
          <span *ngIf="status !== Status.Transit"><i class="fas fa-truck"></i></span>
          <span class="fa-layers fa-fw" *ngIf="status === Status.Delivered">
            <span><i class="fas fa-home confirmation"></i></span>
            <span class="fa-layers-counter accent-notification" style="width: max-content">{{results.eta}} {{'LABEL_DAYS' | translate}}</span>
          </span>
          <span class="fa-layers fa-fw" *ngIf="status !== Status.Delivered">
            <span><i class="fas fa-home"></i></span>
            <span class="fa-layers-counter accent-notification" style="width: max-content">{{results.eta}} {{'LABEL_DAYS' | translate}}</span>
          </span>
        </div>
      </div>
    </div>
    <div class="table-wrapper" fxLayoutAlign="center">
      <div class="table-heading heading">
        <h2 translate>LABEL_PRODUCT_ORDERED</h2>
      </div>
    </div>
    
    <div class="mdc-table" fxLayoutAlign="center">
      <mat-table class="mat-elevation-z0" #table [dataSource]="dataSource">
        
        <ng-container matColumnDef="product">
          <mat-header-cell *matHeaderCellDef translate>LABEL_PRODUCT</mat-header-cell>
          <mat-cell class="product-name" *matCellDef="let product"> {{product.name}}</mat-cell>
        </ng-container>
        
        <ng-container matColumnDef="price">
          <mat-header-cell *matHeaderCellDef fxShow fxHide.lt-md translate>LABEL_PRICE</mat-header-cell>
          <mat-cell class="product-price" *matCellDef="let product" fxShow fxHide.lt-md> {{product.price}}&curren;</mat-cell>
        </ng-container>
        
        <ng-container matColumnDef="quantity">
          <mat-header-cell *matHeaderCellDef translate>LABEL_QUANTITY</mat-header-cell>
          <mat-cell class="product-quantity" *matCellDef="let product"> {{product.quantity}}</mat-cell>
        </ng-container>
        
        
        <ng-container matColumnDef="total price">
          <mat-header-cell *matHeaderCellDef translate>LABEL_TOTAL_PRICE</mat-header-cell>
          <mat-cell class="product-total" *matCellDef="let product"> {{product.total}}&curren;</mat-cell>
        </ng-container>
        
        <mat-header-row *matHeaderRowDef="displayedColumns"></mat-header-row>
        <mat-row *matRowDef="let row; columns: displayedColumns;"></mat-row>
      </mat-table>
    </div>
    <div class="bonus-container">
      <h2 translate [translateParams]="{'bonus': results.bonus}">BONUS_POINTS_EARNED</h2>
      <p>(<span [innerHtml]="'BONUS_FOR_FUTURE_PURCHASES' | translate"></span>)</p>
    </div>
    
  </div>
</mat-card>


/* ===== FILE: ./frontend/src/app/track-result/track-result.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { provideHttpClientTesting } from '@angular/common/http/testing'
import { type ComponentFixture, TestBed, waitForAsync } from '@angular/core/testing'
import { TranslateModule } from '@ngx-translate/core'
import { Status, TrackResultComponent } from './track-result.component'
import { MatTableModule } from '@angular/material/table'
import { MatCardModule } from '@angular/material/card'
import { RouterTestingModule } from '@angular/router/testing'
import { TrackOrderService } from '../Services/track-order.service'
import { DomSanitizer } from '@angular/platform-browser'
import { of } from 'rxjs'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('TrackResultComponent', () => {
  let component: TrackResultComponent
  let fixture: ComponentFixture<TrackResultComponent>
  let trackOrderService: any
  let sanitizer: any

  beforeEach(waitForAsync(() => {
    trackOrderService = jasmine.createSpyObj('TrackOrderService', ['find'])
    trackOrderService.find.and.returnValue(of({ data: [{ }] }))
    sanitizer = jasmine.createSpyObj('DomSanitizer', ['bypassSecurityTrustHtml', 'sanitize'])
    sanitizer.bypassSecurityTrustHtml.and.callFake((args: any) => args)
    sanitizer.sanitize.and.returnValue({})

    TestBed.configureTestingModule({
      imports: [TranslateModule.forRoot(),
        RouterTestingModule,
        MatCardModule,
        MatTableModule,
        TrackResultComponent],
      providers: [
        { provide: TrackOrderService, useValue: trackOrderService },
        { provide: DomSanitizer, useValue: sanitizer },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(TrackResultComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should consider order number as trusted HTML', () => {
    component.orderId = '<a src="link">Link</a>'
    trackOrderService.find.and.returnValue(of({ data: [{ orderId: component.orderId }] }))
    component.ngOnInit()

    expect(sanitizer.bypassSecurityTrustHtml).toHaveBeenCalledWith('<code><a src="link">Link</a></code>')
  })

  it('should set "delivered" status for delivered orders', () => {
    trackOrderService.find.and.returnValue(of({ data: [{ delivered: true }] }))
    component.ngOnInit()

    expect(component.status).toBe(Status.Delivered)
  })

  it('should set "packing" status for undelivered orders with ETA over 2 days', () => {
    trackOrderService.find.and.returnValue(of({ data: [{ eta: 3 }] }))
    component.ngOnInit()

    expect(component.status).toBe(Status.Packing)
  })

  it('should set "transit" status for undelivered orders with ETA under 3 days', () => {
    trackOrderService.find.and.returnValue(of({ data: [{ eta: 2 }] }))
    component.ngOnInit()

    expect(component.status).toBe(Status.Transit)
  })
})


/* ===== FILE: ./frontend/src/app/wallet/wallet.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<mat-card appearance="outlined" class="mat-elevation-z6">
  <div class="mdc-card">

    <div class="header_container">
      <h1>{{"DIGITAL_WALLET" | translate}}</h1>
      <a href="/#/wallet-web3">{{"LINK_TRY_OUT_NEW_CRYPTO_WALLET" | translate}}</a>
    </div>

    <h3>{{"LABEL_ADD_MONEY" | translate}}</h3>
    <p>
      <b>
        <span translate>{{"LABEL_WALLET_BALANCE"  | translate}}</span>
        <span class="confirmation"> {{ balance }}</span>
      </b>
    </p>
    <mat-form-field appearance="outline" color="accent">
      <mat-label>{{'LABEL_AMOUNT' | translate}}</mat-label>
      <input [formControl]="balanceControl" type="number" matInput aria-label="Enter an amount">
      <mat-error *ngIf="balanceControl.invalid && balanceControl.errors.required">
        {{"MANDATORY_AMOUNT"| translate}}
      </mat-error>
      <mat-error *ngIf="balanceControl.invalid && (balanceControl.errors.min || balanceControl.errors.max)">
        {{"AMOUNT_LIMIT" | translate}}
      </mat-error>
    </mat-form-field>

    <button type="submit" id="submitButton" (click)="continue()" [disabled]="balanceControl.invalid"
            mat-raised-button color="primary" aria-label="Button to continue to payment">
     <mat-icon>
      monetization_on
    </mat-icon>
      {{'BTN_DEPOSIT' | translate}}
    </button>
  </div>
</mat-card>


/* ===== FILE: ./frontend/src/app/wallet/wallet.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Component, NgZone, type OnInit } from '@angular/core'
import { WalletService } from '../Services/wallet.service'
import { UntypedFormControl, Validators, FormsModule, ReactiveFormsModule } from '@angular/forms'
import { Router } from '@angular/router'
import { MatButtonModule } from '@angular/material/button'
import { NgIf } from '@angular/common'
import { MatInputModule } from '@angular/material/input'
import { MatFormFieldModule, MatLabel, MatError } from '@angular/material/form-field'
import { TranslateModule } from '@ngx-translate/core'
import { MatCardModule } from '@angular/material/card'
import { MatIconModule } from '@angular/material/icon'

@Component({
  selector: 'app-wallet',
  templateUrl: './wallet.component.html',
  styleUrls: ['./wallet.component.scss'],
  imports: [MatCardModule, TranslateModule, MatFormFieldModule, MatLabel, FormsModule, MatInputModule, ReactiveFormsModule, NgIf, MatError, MatButtonModule, MatIconModule]
})
export class WalletComponent implements OnInit {
  public balance: string
  public balanceControl: UntypedFormControl = new UntypedFormControl('', [Validators.required, Validators.min(10), Validators.max(1000)])

  constructor (private readonly router: Router, private readonly walletService: WalletService, private readonly ngZone: NgZone) { }

  ngOnInit (): void {
    this.walletService.get().subscribe((balance) => {
      this.balance = parseFloat(balance).toFixed(2)
    }, (err) => {
      console.log(err)
    })
  }

  continue () {
    sessionStorage.setItem('walletTotal', this.balanceControl.value)
    this.ngZone.run(async () => await this.router.navigate(['/payment', 'wallet']))
  }
}


/* ===== FILE: ./frontend/src/app/wallet/wallet.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateModule, TranslateService } from '@ngx-translate/core'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { MatCardModule } from '@angular/material/card'
import { MatFormFieldModule } from '@angular/material/form-field'
import { type ComponentFixture, fakeAsync, TestBed, waitForAsync } from '@angular/core/testing'
import { MatInputModule } from '@angular/material/input'
import { ReactiveFormsModule } from '@angular/forms'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'

import { of, throwError } from 'rxjs'
import { RouterTestingModule } from '@angular/router/testing'
import { MatGridListModule } from '@angular/material/grid-list'
import { WalletComponent } from './wallet.component'
import { WalletService } from '../Services/wallet.service'
import { EventEmitter } from '@angular/core'
import { MatSnackBar } from '@angular/material/snack-bar'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('WalletComponent', () => {
  let component: WalletComponent
  let fixture: ComponentFixture<WalletComponent>
  let walletService
  let translateService
  let snackBar: any

  beforeEach(waitForAsync(() => {
    walletService = jasmine.createSpyObj('AddressService', ['get', 'put'])
    walletService.get.and.returnValue(of({}))
    walletService.put.and.returnValue(of({}))
    translateService = jasmine.createSpyObj('TranslateService', ['get'])
    translateService.get.and.returnValue(of({}))
    translateService.onLangChange = new EventEmitter()
    translateService.onTranslationChange = new EventEmitter()
    translateService.onDefaultLangChange = new EventEmitter()
    snackBar = jasmine.createSpyObj('MatSnackBar', ['open'])

    TestBed.configureTestingModule({
      imports: [RouterTestingModule,
        TranslateModule.forRoot(),
        ReactiveFormsModule,
        BrowserAnimationsModule,
        MatCardModule,
        MatFormFieldModule,
        MatInputModule,
        MatGridListModule,
        WalletComponent],
      providers: [
        { provide: WalletService, useValue: walletService },
        { provide: TranslateService, useValue: translateService },
        { provide: MatSnackBar, useValue: snackBar },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(WalletComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should be compulsory to provide amount', () => {
    component.balanceControl.setValue('')
    expect(component.balanceControl.valid).toBeFalsy()
  })

  it('amount should be in the range [10, 1000]', () => {
    component.balanceControl.setValue(-1)
    expect(component.balanceControl.valid).toBeFalsy()
    component.balanceControl.setValue(10000000000)
    expect(component.balanceControl.valid).toBeFalsy()
    component.balanceControl.setValue(10)
    expect(component.balanceControl.valid).toBe(true)
    component.balanceControl.setValue(1000)
    expect(component.balanceControl.valid).toBe(true)
  })

  it('should hold balance returned by backend API', () => {
    walletService.get.and.returnValue(of(100))
    component.ngOnInit()
    fixture.detectChanges()
    expect(component.balance).toBe('100.00')
  })

  it('should log error while getting balance from backend API directly to browser console', fakeAsync(() => {
    walletService.get.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.ngOnInit()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))
})


/* ===== FILE: ./frontend/src/app/wallet-web3/wallet-web3.module.ts ===== */

import { NgModule, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core'
import { CommonModule } from '@angular/common'
import { ReactiveFormsModule, FormsModule } from '@angular/forms'
import { RouterModule, type Routes } from '@angular/router'
import { ConfigurationService } from '../Services/configuration.service'
import { OverlayContainer } from '@angular/cdk/overlay'
import { MatCardModule } from '@angular/material/card'
import { MatInputModule } from '@angular/material/input'
import { MatButtonModule } from '@angular/material/button'
import { MatSnackBarModule } from '@angular/material/snack-bar'

import { WalletWeb3Component } from './wallet-web3.component'
import { TranslateModule } from '@ngx-translate/core'

const routes: Routes = [
  {
    path: '',
    component: WalletWeb3Component
  }
]

@NgModule({
  imports: [
    CommonModule,
    RouterModule.forChild(routes),
    TranslateModule,
    FormsModule,
    ReactiveFormsModule,
    MatButtonModule,
    MatCardModule,
    MatInputModule,
    MatSnackBarModule,
    WalletWeb3Component
  ],
  schemas: [CUSTOM_ELEMENTS_SCHEMA]
})
export class WalletWeb3Module {
  constructor (
    public configurationService: ConfigurationService,
    public overlayContainer: OverlayContainer
  ) {
    configurationService.getApplicationConfiguration().subscribe((conf) => {
      overlayContainer
        .getContainerElement()
        .classList.add(conf.application.theme + '-theme')
    })
  }
}


/* ===== FILE: ./frontend/src/app/wallet-web3/wallet-web3.component.html ===== */

<mat-card appearance="outlined" class="mat-elevation-z6">
  <div class="mdc-card">
    <div class="header_container">
      <h1>{{"TITLE_CRYPTO_WALLET" | translate}}</h1>
      <div class="metamask-button">
        <button
          mat-raised-button
          color="accent"
          type="button"
          (click)="handleAuth()"
        >
          <mat-icon>
            account_balance_wallet
          </mat-icon>
          <span *ngIf="!session">{{"BTN_CONNECT_METAMASK" | translate}}</span>
          <span *ngIf="session"
            >{{ userData.address.substring(0, 6) }}...{{
              userData.address.slice(-6)
            }}</span
          >
        </button>
      </div>
    </div>
    <p>
      <b>
        <span>{{"LABEL_WALLET_BALANCE" | translate}}</span>
        <span class="confirmation"> {{ walletBalance }} ETH</span>
      </b>
    </p>
    <div>
      <mat-form-field style="width: 100%" color="accent" appearance="outline">
        <mat-label>{{'LABEL_AMOUNT' | translate}}</mat-label>
        <input
          matInput
          [placeholder]="'ENTER_ETHER_AMOUNT' | translate"
          type="number"
          id="inputAmount"
          [(ngModel)]="inputAmount"
          aria-label="Text field for the withdrawal amount"
        />
      </mat-form-field>
      <h5 class="error">{{ errorMessage }}</h5>
    </div>
    <div class="dwbutton_container">
      <button
        type="submit"
        class="deposit_withdraw_button"
        mat-raised-button
        color="primary"
        aria-label="Button to deposit"
        (click)="depositETH()"
      >
        <mat-icon>monetization_on</mat-icon>
        {{'BTN_DEPOSIT' | translate}}
      </button>
      <button
        type="submit"
        class="deposit_withdraw_button"
        mat-raised-button
        color="warning"
        aria-label="Button to withdraw"
        (click)="withdrawETH()"
      >
        <mat-icon>local_atm</mat-icon>
        {{'BTN_WITHDRAW' | translate}}
      </button>
    </div>
  </div>
</mat-card>


/* ===== FILE: ./frontend/src/app/wallet-web3/wallet-web3.component.ts ===== */

import { Component, ChangeDetectorRef } from '@angular/core'
import { KeysService } from '../Services/keys.service'
import { SnackBarHelperService } from '../Services/snack-bar-helper.service'
import { web3WalletABI } from '../../assets/public/ContractABIs'
import { getDefaultProvider, ethers } from 'ethers'
import {
  createClient,
  connect,
  disconnect,
  getAccount,
  InjectedConnector
} from '@wagmi/core'
import { MatIconModule } from '@angular/material/icon'
import { FormsModule } from '@angular/forms'
import { MatInputModule } from '@angular/material/input'
import { MatFormFieldModule, MatLabel } from '@angular/material/form-field'
import { TranslateModule } from '@ngx-translate/core'
import { NgIf } from '@angular/common'
import { MatButtonModule } from '@angular/material/button'
import { MatCardModule } from '@angular/material/card'
const { ethereum } = window
const BankAddress = '0x413744D59d31AFDC2889aeE602636177805Bd7b0'
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const client = createClient({
  autoConnect: true,
  provider: getDefaultProvider()
})

@Component({
  selector: 'app-wallet-web3',
  templateUrl: './wallet-web3.component.html',
  styleUrls: ['./wallet-web3.component.scss'],
  imports: [MatCardModule, MatButtonModule, NgIf, TranslateModule, MatFormFieldModule, MatLabel, MatInputModule, FormsModule, MatIconModule]
})
export class WalletWeb3Component {
  constructor (
    private readonly keysService: KeysService,
    private readonly snackBarHelperService: SnackBarHelperService,
    private readonly changeDetectorRef: ChangeDetectorRef
  ) {}

  userData: object
  session = false
  walletBalance = '0'
  myBEEBalance = 0
  inputAmount: number = null
  successResponse = false
  mintButtonDisabled = true
  challengeSolved = false
  errorMessage = ''
  metamaskAddress = ''
  ngOnInit (): void {
    this.handleAuth()
    window.ethereum.on('chainChanged', this.handleChainChanged.bind(this))
  }

  async handleChainChanged (chainId: string) {
    await this.handleAuth()
  }

  async depositETH () {
    try {
      const provider = new ethers.providers.Web3Provider(window.ethereum)
      const signer = provider.getSigner()

      const contract = new ethers.Contract(BankAddress, web3WalletABI, signer)
      const depositAmount = this.inputAmount.toString()
      const transaction = await contract.ethdeposit(this.metamaskAddress, {
        value: ethers.utils.parseEther(depositAmount)
      })
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      const txConfirmation = await transaction.wait()
      this.getUserEthBalance()
    } catch (error) {
      this.errorMessage = error.message
    }
  }

  async withdrawETH () {
    try {
      const provider = new ethers.providers.Web3Provider(window.ethereum)
      const signer = provider.getSigner()

      const contract = new ethers.Contract(BankAddress, web3WalletABI, signer)
      const withdrawalAmount = this.inputAmount.toString()
      const transaction = await contract.withdraw(
        ethers.utils.parseEther(withdrawalAmount)
      )
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      const txConfirmation = await transaction.wait()
      this.getUserEthBalance()
    } catch (error) {
      this.errorMessage = error.message
    }
  }

  async getUserEthBalance () {
    try {
      const provider = new ethers.providers.Web3Provider(window.ethereum)
      const signer = provider.getSigner()
      const contract = new ethers.Contract(BankAddress, web3WalletABI, signer)
      const userBalance = await contract.balanceOf(this.metamaskAddress)
      const formattedBalance = ethers.utils.formatEther(userBalance)
      this.walletBalance = formattedBalance
    } catch (error) {
      this.errorMessage = error.message
    }
  }

  async handleAuth () {
    try {
      const { isConnected } = getAccount()

      if (isConnected) {
        await disconnect()
      }
      if (!window.ethereum) {
        this.snackBarHelperService.open('PLEASE_INSTALL_WEB3_WALLET', 'errorBar')
        return
      }

      const provider = await connect({ connector: new InjectedConnector() })
      this.metamaskAddress = provider.account
      this.keysService.walletAddressSend(this.metamaskAddress).subscribe(
        (response) => {
          if (response.success) {
            this.successResponse = response.status
            this.mintButtonDisabled = true
          }
        },
        (error) => {
          console.error(error)
        }
      )
      this.userData = {
        address: provider.account,
        chain: provider.chain.id,
        network: 'evm'
      }
      await ethereum.request({
        method: 'wallet_addEthereumChain',
        params: [
          {
            chainId: '0xaa36a7',
            chainName: 'Sepolia Test Network',
            nativeCurrency: {
              name: 'SepoliaETH',
              symbol: 'ETH',
              decimals: 18
            },
            rpcUrls: ['https://ethereum-sepolia.blockpi.network/v1/rpc/public'],
            blockExplorerUrls: ['https://sepolia.etherscan.io/']
          }
        ]
      })
      const targetChainId = '11155111'
      const currentChainId = String(provider.chain?.id)

      if (provider && currentChainId !== targetChainId) {
        this.session = false
        this.snackBarHelperService.open('PLEASE_CONNECT_TO_SEPOLIA_NETWORK', 'errorBar')
      } else {
        this.session = true
        this.getUserEthBalance()
      }
      this.changeDetectorRef.detectChanges()
    } catch (err) {
      console.log(err)
    }
  }
}


/* ===== FILE: ./frontend/src/app/token-sale/token-sale.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type ComponentFixture, fakeAsync, TestBed, waitForAsync } from '@angular/core/testing'
import { TranslateModule } from '@ngx-translate/core'
import { TokenSaleComponent } from './token-sale.component'
import { of, throwError } from 'rxjs'
import { ConfigurationService } from '../Services/configuration.service'
import { MatCardModule } from '@angular/material/card'
import { MatButtonModule } from '@angular/material/button'

describe('TokenSaleComponent', () => {
  let component: TokenSaleComponent
  let fixture: ComponentFixture<TokenSaleComponent>
  let configurationService: any

  beforeEach(waitForAsync(() => {
    configurationService = jasmine.createSpyObj('ConfigurationService', ['getApplicationConfiguration'])
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { } }))
    TestBed.configureTestingModule({
      imports: [
        TranslateModule.forRoot(),
        MatCardModule,
        MatButtonModule,
        TokenSaleComponent
      ],
      providers: [
        { provide: ConfigurationService, useValue: configurationService }
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(TokenSaleComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should set altcoinName as obtained from configuration', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { altcoinName: 'Coin' } }))
    component.ngOnInit()
    expect(component.altcoinName).toBe('Coin')
  })

  it('should log error on failure in retrieving configuration from backend', fakeAsync(() => {
    configurationService.getApplicationConfiguration.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.ngOnInit()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))
})


/* ===== FILE: ./frontend/src/app/token-sale/token-sale.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

  <mat-card appearance="outlined">
    <div class="mdc-card container" fxLayout="row" fxLayout.lt-md="column" fxLayoutGap="20px">

      <div class="whitepaper-container offer-container" fxFlexAlign="center">

        <mat-card-header>
          <mat-card-title>
            {{'TITLE_TOKENSALE' | translate}}
          </mat-card-title>
          <mat-card-subtitle [innerHtml]="'SECTION_ICO' | translate:{juicycoin: altcoinName}"></mat-card-subtitle>
        </mat-card-header>
        <div class="divider"></div>
        <mat-card appearance="outlined" class="mat-elevation-z6">
          <div class="mdc-card">
            <h4>{{'SECTION_WHITEPAPER' | translate}} <small style="margin-left: 10px;">(<span>{{"WHITEPAPER_REFERENCES" | translate}}</span>)</small></h4>
            <div class="whitepaper-buttons">
              <a href="https://ponzico.win/ponzico.pdf" target="_blank" rel="noopener noreferrer"><button mat-raised-button color="accent"><i class="fas fa-university fa-lg"></i> PonzICO Whitepaper</button></a>
              <a href="https://www.sec.gov/investor/alerts/ia_virtualcurrencies.pdf" target="_blank" rel="noopener noreferrer"><button mat-raised-button color="accent"><i class="fas fa-graduation-cap fa-lg"></i> PonziCoin Whitepaper</button></a>
            </div>
          </div>
        </mat-card>
        <div class="offer-box">
          <h3>{{"SECTION_SALES_PITCH" | translate }}</h3>
          <p class="text-justify">
            Lorem ipsum dolor sit amet <strong><i class='fab fa-bitcoin'></i> {{altcoinName}}</strong>, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.

            <span >{{"GIVE_US_ALL_YOUR_MONEY" | translate }}</span>

            Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi. Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat.

            <span >{{"GIVE_US_ALL_YOUR_MONEY" | translate }}</span>

            Ut wisi enim ad minim veniam, quis <strong><i class='fab fa-bitcoin'></i> {{altcoinName}}</strong> nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat. Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi.

            <span >{{"GIVE_US_ALL_YOUR_MONEY" | translate }}</span>

            Nam liber tempor cum soluta nobis eleifend option congue nihil imperdiet doming id quod mazim placerat facer possim assum. Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat.

            <span >{{"GIVE_US_ALL_YOUR_MONEY" | translate }}</span>

            Duis autem vel eum <strong><i class='fab fa-bitcoin'></i> {{altcoinName}}</strong> iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis.

            <span >{{"GIVE_US_ALL_YOUR_MONEY" | translate }}</span>

            At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, At accusam aliquyam diam diam dolore dolores duo eirmod eos erat, et nonumy sed tempor et et invidunt justo labore Stet clita ea et gubergren, kasd magna no rebum. sanctus sea sed takimata ut vero voluptua. <span class='badge'><i class='fab fa-bitcoin'></i> {{altcoinName}}</span> est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur.
          </p>
        </div>

      </div>

      <div class="faq-container" fxFlexAlign.lt-md="center">
        <mat-card-header>
          <mat-card-title class="title">{{"ICO_FAQ" | translate}}</mat-card-title>
        </mat-card-header>
        <div class="divider"></div>

        <mat-card appearance="outlined" class="mat-elevation-z6">
          <div class="mdc-card">
            <h5><i class='fas fa-comments fa-2x'></i> Stet <strong><i class='fab fa-bitcoin'></i> {{altcoinName}}</strong> clita kasd gubergren?</h5>
            <small class="text-justify">
              Stet clita kasd gubergren, no <strong><i class='fab fa-bitcoin'></i> {{altcoinName}}</strong> sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua.
            </small>
          </div>
        </mat-card>

        <mat-card appearance="outlined" class="mat-elevation-z6">
          <div class="mdc-card">
            <h5><i class='far fa-comment-alt fa-2x'></i> Consetetur sadipscing elitr?</h5>
            <small class="text-justify">
              Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed <strong><i class='fab fa-bitcoin'></i> {{altcoinName}}</strong> diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum.
            </small>
          </div>
        </mat-card>

        <mat-card appearance="outlined" class="mat-elevation-z6">
          <div class="mdc-card">
            <h5><i class='far fa-comments fa-2x'></i> Hendrerit <strong><i class='fab fa-bitcoin'></i> {{altcoinName}}</strong> in vulputate velit?</h5>
            <small class="text-justify">
              Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis.
            </small>
          </div>
        </mat-card>

        <mat-card appearance="outlined" class="mat-elevation-z6">
          <div class="mdc-card">
            <h5><i class='fas fa-comment-alt fa-2x'></i> Justo duo dolores et ea rebum?</h5>
            <small class="text-justify">
              At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.
            </small>
          </div>
        </mat-card>

        <mat-card appearance="outlined" class="mat-elevation-z6">
          <div class="mdc-card">
            <h5><i class='fas fa-comments fa-2x'></i> <span style="margin-left: 10px;" [innerHtml]="'ICO_FAQ_QUESTION' | translate:{juicycoin: altcoinName}"></span></h5>
            <small class="text-justify">{{"ICO_FAQ_ANSWER" | translate}}</small>
          </div>
        </mat-card>

      </div>

      <img src="assets/public/images/padding/56px.png"/>
    </div>



  </mat-card>


/* ===== FILE: ./frontend/src/app/token-sale/token-sale.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { ConfigurationService } from '../Services/configuration.service'
import { Component, type OnInit } from '@angular/core'
import { library } from '@fortawesome/fontawesome-svg-core'
import { faBitcoin } from '@fortawesome/free-brands-svg-icons'
import { faCommentAlt, faComments, faGraduationCap, faUniversity } from '@fortawesome/free-solid-svg-icons'
import { faCommentAlt as farCommentAlt, faComments as farComments } from '@fortawesome/free-regular-svg-icons'
import { MatButtonModule } from '@angular/material/button'
import { TranslateModule } from '@ngx-translate/core'
import { FlexModule } from '@angular/flex-layout/flex'
import { MatCardModule, MatCardHeader, MatCardTitle, MatCardSubtitle } from '@angular/material/card'

library.add(faBitcoin, faUniversity, faGraduationCap, faCommentAlt, faComments, farCommentAlt, farComments)

@Component({
  selector: 'app-token-sale',
  templateUrl: './token-sale.component.html',
  styleUrls: ['./token-sale.component.scss'],
  imports: [MatCardModule, FlexModule, MatCardHeader, MatCardTitle, MatCardSubtitle, TranslateModule, MatButtonModule]
})
export class TokenSaleComponent implements OnInit {
  public altcoinName = 'Juicycoin'
  constructor (private readonly configurationService: ConfigurationService) { }

  ngOnInit (): void {
    this.configurationService.getApplicationConfiguration().subscribe((config: any) => {
      if (config?.application?.altcoinName) {
        this.altcoinName = config.application.altcoinName
      }
    }, (err) => { console.log(err) })
  }
}


/* ===== FILE: ./frontend/src/app/faucet/faucet.component.html ===== */

<div class="container">
  <mat-card appearance="outlined" class="mat-elevation-z6 faucet-container">
    <div class="mdc-card">
      <h1 >{{"TITLE_BEE_HAVEN" | translate}}</h1>
      <div class="faucet-image">
        <img src="assets/public/images/BeeOwner.png" />
      </div>
      <p>{{"BEE_HAVEN_INTRO" | translate}}</p>
      <div class="faucet-balance">
        <span color="accent">
          {{'FAUCET_BALANCE' | translate}}: {{ BEEBalance }} | {{'BEE_BALANCE' | translate}}:
          {{ myBEEBalance }}</span
        >
        <div class="metamask-button">
          <button
            mat-raised-button
            color="accent"
            type="button"
            (click)="handleAuth()"
          >
            <mat-icon>
              account_balance_wallet
            </mat-icon>
            <span *ngIf="!session" >{{"BTN_CONNECT_METAMASK" | translate}}</span>
            <span *ngIf="session"
              >{{ userData.address.substring(0, 6) }}...{{
                userData.address.slice(-6)
              }}</span
            >
          </button>
        </div>
      </div>

      <div class="withdraw-container">
        <div>
          <mat-form-field style="width: 100%" color="accent" appearance="outline">
            <mat-label>{{"LABEL_NUMBER_OF_BEES" | translate}}</mat-label>
            <input
              matInput
              [placeholder]="'LABEL_NUMBER_OF_BEES'|translate"
              type="number"
              id="withdrawAmount"
              [(ngModel)]="withdrawAmount"
              aria-label="Text field for the withdrawal amount"
            />
          </mat-form-field>
          <h5 class="error">{{ errorMessage }}</h5>
        </div>
        <button
          mat-raised-button
          type="button"
          color="primary"
          (click)="extractBEETokens()"
        >
          <mat-icon>
            emoji_nature
          </mat-icon>
          {{ "BTN_CLAIM_BEES" | translate }}
        </button>
      </div>
    </div>
  </mat-card>
  <mat-card appearance="outlined" class="mat-elevation-z6 honeypot-container">
    <div class="mdc-card">
      <div class="honeypot-image mat-elevation-z6">
        <img src="assets/public/images/HoneyPot.png" />
      </div>
      <h2 >{{"BEE_HONEYPOT_TITLE" | translate}}</h2>
      <p >{{"BEE_HONEYPOT_DESCRIPTION" | translate}}</p>

      <button
        class="mint_button"
        mat-raised-button
        color="warn"
        [disabled]="mintButtonDisabled"
        fxFlexAlign="center"
        (click)="mintNFT()"
      >
       <mat-icon>
        image
       </mat-icon>
        {{ nftMintText }}
      </button>
    </div>
  </mat-card>
</div>


/* ===== FILE: ./frontend/src/app/faucet/faucet.component.ts ===== */

import { Component, ChangeDetectorRef } from '@angular/core'
import { KeysService } from '../Services/keys.service'
import { SnackBarHelperService } from '../Services/snack-bar-helper.service'
import { TranslateService, TranslateModule } from '@ngx-translate/core'
import {
  BeeFaucetABI,
  BeeTokenABI,
  nftABI
} from '../../assets/public/ContractABIs'
import { getDefaultProvider, ethers, type BigNumber } from 'ethers'
import {
  createClient,
  connect,
  disconnect,
  getAccount,
  InjectedConnector
} from '@wagmi/core'
import { FormsModule } from '@angular/forms'
import { MatInputModule } from '@angular/material/input'
import { MatFormFieldModule, MatLabel } from '@angular/material/form-field'
import { NgIf } from '@angular/common'
import { MatButtonModule } from '@angular/material/button'
import { MatCardModule } from '@angular/material/card'
import { MatIconModule } from '@angular/material/icon'

// eslint-disable-next-line @typescript-eslint/no-unused-vars
const client = createClient({
  autoConnect: true,
  provider: getDefaultProvider()
})
const { ethereum } = window

const nftAddress = '0x41427790c94E7a592B17ad694eD9c06A02bb9C39'
const BeeTokenAddress = '0x36435796Ca9be2bf150CE0dECc2D8Fab5C4d6E13'
const BeeFaucetAddress = '0x860e3616aD0E0dEDc23352891f3E10C4131EA5BC'

@Component({
  selector: 'app-faucet',
  templateUrl: './faucet.component.html',
  styleUrls: ['./faucet.component.scss'],
  imports: [MatCardModule, TranslateModule, MatButtonModule, NgIf, MatFormFieldModule, MatLabel, MatInputModule, FormsModule, MatIconModule]
})
export class FaucetComponent {
  constructor (
    private readonly keysService: KeysService,
    private readonly snackBarHelperService: SnackBarHelperService,
    private readonly translateService: TranslateService,
    private readonly changeDetectorRef: ChangeDetectorRef
  ) {}

  userData: object
  session = false
  deployedContractAddress = ''
  BEEBalance = 0
  myBEEBalance = 0
  withdrawAmount: number = null
  successResponse = false
  mintButtonDisabled = true
  challengeSolved = false
  nftMintText = 'Mint the Pot - 1000 BEE'
  errorMessage = ''
  metamaskAddress = ''

  ngOnInit (): void {
    this.translateService.get('NFT_MINT_TEXT_INTRO').subscribe((translatedString: string) => {
      this.nftMintText = translatedString
    })
    this.handleAuth()
    this.checkNftMinted()
    this.nftMintListener()
    window.ethereum.on('chainChanged', this.handleChainChanged.bind(this))
  }

  nftMintListener () {
    this.keysService.nftMintListen().subscribe(
      (response) => {
        console.log(response)
      },
      (error) => {
        console.error(error)
      }
    )
  }

  checkNftMinted () {
    this.keysService.checkNftMinted().subscribe(
      (response) => {
        const challengeSolvedStatus = response.data[0].solved
        this.mintButtonDisabled = challengeSolvedStatus
        this.challengeSolved = challengeSolvedStatus
        if (challengeSolvedStatus) {
          this.translateService.get('NFT_MINT_TEXT_SUCCESS').subscribe((translatedString: string) => {
            this.nftMintText = translatedString
          })
        }
      },
      (error) => {
        console.error(error)
        this.successResponse = false
      }
    )
  }

  async fetchMyBeeBalance () {
    try {
      const provider = new ethers.providers.Web3Provider(window.ethereum)
      const signer = provider.getSigner()

      const contract = new ethers.Contract(
        BeeTokenAddress,
        BeeTokenABI,
        signer
      )
      const userAddress = await signer.getAddress()
      const balanceBigNumber: BigNumber = await contract.balanceOf(userAddress)
      console.log(balanceBigNumber)
      this.myBEEBalance = balanceBigNumber
        .div(ethers.constants.WeiPerEther)
        .toNumber()
      if (this.myBEEBalance >= 1000 && !this.challengeSolved) {
        this.mintButtonDisabled = false
      }
      if (this.myBEEBalance <= 1000 && !this.challengeSolved) {
        this.mintButtonDisabled = true
      }
    } catch (error) {
      console.error('Error fetching BEE balance:', error)
    }
  }

  async fetchBeeBalance () {
    try {
      const provider = new ethers.providers.Web3Provider(window.ethereum)
      const signer = provider.getSigner()

      const contract = new ethers.Contract(
        BeeFaucetAddress,
        BeeFaucetABI,
        signer
      )
      const balance = await contract.balance()
      console.log(balance)
      this.BEEBalance = balance
    } catch (error) {
      console.error('Error fetching BEE balance:', error)
    }
  }

  async handleChainChanged (chainId: string) {
    await this.handleAuth()
  }

  async handleAuth () {
    try {
      const { isConnected } = getAccount()

      if (isConnected) {
        await disconnect()
      }
      if (!window.ethereum) {
        this.snackBarHelperService.open('PLEASE_INSTALL_WEB3_WALLET', 'errorBar')
        return
      }

      const provider = await connect({ connector: new InjectedConnector() })
      this.metamaskAddress = provider.account
      this.userData = {
        address: provider.account,
        chain: provider.chain.id,
        network: 'evm'
      }
      await ethereum.request({
        method: 'wallet_addEthereumChain',
        params: [
          {
            chainId: '0xaa36a7',
            chainName: 'Sepolia Test Network',
            nativeCurrency: {
              name: 'SepoliaETH',
              symbol: 'ETH',
              decimals: 18
            },
            rpcUrls: ['https://ethereum-sepolia.blockpi.network/v1/rpc/public'],
            blockExplorerUrls: ['https://sepolia.etherscan.io/']
          }
        ]
      })
      const targetChainId = '11155111'
      const currentChainId = String(provider.chain?.id)

      if (provider && currentChainId !== targetChainId) {
        this.session = false
        this.snackBarHelperService.open('PLEASE_CONNECT_TO_SEPOLIA_NETWORK', 'errorBar')
      } else {
        console.log('Should show ethereum chain now')
        this.session = true
        await this.fetchBeeBalance()
        await this.fetchMyBeeBalance()
      }
      console.log('session', this.session)
      this.changeDetectorRef.detectChanges()
    } catch (err) {
      console.log(err)
    }
  }

  async extractBEETokens (amount = this.withdrawAmount) {
    if (!this.session) {
      this.snackBarHelperService.open('PLEASE_CONNECT_WEB3_WALLET', 'errorBar')
      return
    }
    try {
      const provider = new ethers.providers.Web3Provider(window.ethereum)
      const signer = provider.getSigner()
      const userAddress = await signer.getAddress()

      const balanceBigNumber = await provider.getBalance(userAddress)

      const balanceEth = ethers.utils.formatEther(balanceBigNumber)

      console.log('ETH balance:', balanceEth, typeof balanceEth)
      if (balanceEth < '0.001') {
        this.errorMessage = 'Deposit some test ETH from sepoliafaucet.com or any other ETH faucet to initiate transaction.'
        return
      }
      const contract = new ethers.Contract(
        BeeFaucetAddress,
        BeeFaucetABI,
        signer
      )
      const tx = await contract.withdraw(amount)
      await tx.wait()

      console.log('BEE tokens extracted successfully')
      this.fetchBeeBalance()
      this.fetchMyBeeBalance()
    } catch (error) {
      console.error('Error extracting BEEs:', error.message)
      this.errorMessage = error.message
    }
  }

  async mintNFT () {
    if (!this.session) {
      this.snackBarHelperService.open('PLEASE_CONNECT_WEB3_WALLET', 'errorBar')
      return
    }
    this.translateService.get('NFT_MINT_TEXT_AWAITING_APPROVAL').subscribe((translatedString: string) => {
      this.nftMintText = translatedString
    })
    try {
      const provider = new ethers.providers.Web3Provider(window.ethereum)
      const signer = provider.getSigner()
      const amountToApprove = ethers.utils.parseUnits('1000', '18')
      const BeeTokenContract = new ethers.Contract(
        BeeTokenAddress,
        BeeTokenABI,
        signer
      )
      const approvalTx = await BeeTokenContract.approve(
        nftAddress,
        amountToApprove
      )

      await approvalTx.wait()
      this.translateService.get('NFT_MINT_TEXT_CONFIRM').subscribe((translatedString: string) => {
        this.nftMintText = translatedString
      })

      const contract = new ethers.Contract(nftAddress, nftABI, signer)

      const transaction = await contract.mintNFT()
      console.log(transaction)
      this.translateService.get('NFT_MINT_TEXT_IN_PROGRESS').subscribe((translatedString: string) => {
        this.nftMintText = translatedString
      })

      const mintConfirmation = await transaction.wait()
      console.log(mintConfirmation)
      if (mintConfirmation) {
        this.translateService.get('NFT_MINT_TEXT_SUCCESS').subscribe((translatedString: string) => {
          this.nftMintText = translatedString
        })
        setTimeout(() => {
          this.keysService.verifyNFTWallet(this.metamaskAddress).subscribe(
            (response) => {
              if (response.success) {
                this.successResponse = response.status
                this.mintButtonDisabled = true
              }
            },
            (error) => {
              console.error(error)
              this.successResponse = false
            }
          )
        }, 3500)
      }

      console.log('NFT minted successfully!')
    } catch (error) {
      console.error('Error minting NFT:', error)
    }
  }

  async signOut () {
    await disconnect()
    this.session = false
  }
}


/* ===== FILE: ./frontend/src/app/faucet/faucet.module.ts ===== */

import { NgModule, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core'
import { CommonModule } from '@angular/common'
import { ReactiveFormsModule, FormsModule } from '@angular/forms'
import { RouterModule, type Routes } from '@angular/router'
import { ConfigurationService } from '../Services/configuration.service'
import { OverlayContainer } from '@angular/cdk/overlay'
import { MatCardModule } from '@angular/material/card'
import { MatInputModule } from '@angular/material/input'
import { MatButtonModule } from '@angular/material/button'
import { MatSnackBarModule } from '@angular/material/snack-bar'

import { FaucetComponent } from './faucet.component'
import { TranslateModule } from '@ngx-translate/core'

const routes: Routes = [
  {
    path: '',
    component: FaucetComponent
  }
]

@NgModule({
  imports: [
    CommonModule,
    RouterModule.forChild(routes),
    TranslateModule,
    FormsModule,
    ReactiveFormsModule,
    MatButtonModule,
    MatCardModule,
    MatInputModule,
    MatSnackBarModule,
    FaucetComponent
  ],
  schemas: [CUSTOM_ELEMENTS_SCHEMA]
})
export class FaucetModule {
  constructor (public configurationService: ConfigurationService, public overlayContainer: OverlayContainer) {
    configurationService.getApplicationConfiguration().subscribe((conf) => {
      overlayContainer.getContainerElement().classList.add(conf.application.theme + '-theme')
    })
  }
}


/* ===== FILE: ./frontend/src/app/administration/administration.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<mat-card appearance="outlined" class="mat-elevation-z6 mat-own-card">
  <div class="mdc-card">
    <h1 translate>TITLE_ADMINISTRATION</h1>
    <div class="container">
      <div class="user-table">
        <div class="heading">
          <span translate>SECTION_USER</span>
        </div>
        <mat-table [dataSource]="userDataSource">
          <ng-container matColumnDef="user">
            <mat-header-cell *matHeaderCellDef></mat-header-cell>
            <mat-cell *matCellDef="let user" style="vertical-align: middle">
              <i *ngIf="doesUserHaveAnActiveSession(user)" class="fas fa-user fa-lg confirmation"></i>
            </mat-cell>
          </ng-container>

          <ng-container matColumnDef="email">
            <mat-header-cell *matHeaderCellDef translate></mat-header-cell>
            <mat-cell *matCellDef="let user" [innerHTML]="user.email" style="vertical-align: middle"></mat-cell>
          </ng-container>

          <ng-container matColumnDef="user_detail">
            <mat-header-cell *matHeaderCellDef></mat-header-cell>
            <mat-cell *matCellDef="let user">
              <button mat-button (click)="showUserDetail(user.id)"><i class="fas fa-eye"></i></button>
            </mat-cell>
          </ng-container>

          <mat-header-row *matHeaderRowDef="userColumns"></mat-header-row>
          <mat-row *matRowDef="let row; columns: userColumns; "></mat-row>

        </mat-table>
        <mat-paginator #paginatorUsers
                      [pageSize]="10"
                      [length]="resultsLengthUser"
                      class="mat-elevation-z0"
                      color="accent">
        </mat-paginator>
      </div>
      <div class="customer-table">
        <div class="heading">
          <span translate>SECTION_CUSTOMER_FEEDBACK</span>
        </div>
        <mat-table [dataSource]="feedbackDataSource">
          <ng-container matColumnDef="user">
            <mat-header-cell *matHeaderCellDef translate></mat-header-cell>
            <mat-cell *matCellDef="let feedback"> {{feedback.UserId}}</mat-cell>
          </ng-container>

          <ng-container matColumnDef="comment">
            <mat-header-cell *matHeaderCellDef translate></mat-header-cell>
            <mat-cell *matCellDef="let feedback" (click)="showFeedbackDetails(feedback.comment, feedback.UserId)">
              <p [innerHTML]="feedback.comment" matTooltip="Click for more information" matTooltipPosition="above"></p>
            </mat-cell>
          </ng-container>

          <ng-container matColumnDef="rating">
            <mat-header-cell *matHeaderCellDef translate></mat-header-cell>
            <mat-cell *matCellDef="let feedback">
              <mat-icon *ngFor="let i of times(feedback.rating)">
                star_rate
              </mat-icon>
            </mat-cell>
          </ng-container>

          <ng-container matColumnDef="remove">
            <mat-header-cell *matHeaderCellDef></mat-header-cell>
            <mat-cell *matCellDef="let feedback">
              <button mat-button (click)="deleteFeedback(feedback.id)"><i class="fas fa-trash-alt"></i></button>
            </mat-cell>
          </ng-container>

          <mat-header-row *matHeaderRowDef="feedbackColumns"></mat-header-row>
          <mat-row *matRowDef="let row; columns: feedbackColumns;"></mat-row>
        </mat-table>
        <mat-paginator #paginatorFeedb
                      [pageSize]="10"
                      [length]="resultsLengthFeedback"
                      class="mat-elevation-z0"
                      color="accent">
        </mat-paginator>
      </div>
    </div>
  </div>
</mat-card>

<mat-table [dataSource]="userDataSourceHidden" style="visibility: hidden; height: 0px;">
  <ng-container matColumnDef="user">
    <mat-header-cell *matHeaderCellDef></mat-header-cell>
    <mat-cell *matCellDef="let user" style="vertical-align: middle">
    </mat-cell>
  </ng-container>

  <ng-container matColumnDef="email">
    <mat-header-cell *matHeaderCellDef translate></mat-header-cell>
    <mat-cell *matCellDef="let user" [innerHTML]="user.email" style="vertical-align: middle"></mat-cell>
  </ng-container>

  <ng-container matColumnDef="user_detail">
    <mat-header-cell *matHeaderCellDef></mat-header-cell>
    <mat-cell *matCellDef="let user">
      <button mat-button (click)="showUserDetail(user.id)"><i class="fas fa-eye"></i></button>
    </mat-cell>
  </ng-container>

  <mat-header-row *matHeaderRowDef="userColumns"></mat-header-row>
  <mat-row *matRowDef="let row; columns: userColumns; "></mat-row>
</mat-table>

<img src="assets/public/images/padding/19px.png"/>

/* ===== FILE: ./frontend/src/app/administration/administration.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { UserDetailsComponent } from '../user-details/user-details.component'
import { FeedbackDetailsComponent } from '../feedback-details/feedback-details.component'

import { FeedbackService } from '../Services/feedback.service'
import { UserService } from '../Services/user.service'
import { type ComponentFixture, fakeAsync, TestBed, tick, waitForAsync } from '@angular/core/testing'

import { AdministrationComponent } from './administration.component'
import { MatTableModule } from '@angular/material/table'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { MatDialog, MatDialogModule } from '@angular/material/dialog'
import { TranslateModule } from '@ngx-translate/core'
import { of } from 'rxjs'
import { throwError } from 'rxjs/internal/observable/throwError'
import { MatPaginatorModule } from '@angular/material/paginator'
import { MatCardModule } from '@angular/material/card'
import { MatDividerModule } from '@angular/material/divider'
import { MatIconModule } from '@angular/material/icon'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('AdministrationComponent', () => {
  let component: AdministrationComponent
  let fixture: ComponentFixture<AdministrationComponent>
  let dialog: any
  let userService: any
  let feedbackService: any

  beforeEach(waitForAsync(() => {
    dialog = jasmine.createSpyObj('MatDialog', ['open'])
    dialog.open.and.returnValue(null)
    userService = jasmine.createSpyObj('UserService', ['find'])
    userService.find.and.returnValue(of([{ email: 'User1' }, { email: 'User2' }]))
    feedbackService = jasmine.createSpyObj('FeedbackService', ['find', 'del'])
    feedbackService.find.and.returnValue(of([{ comment: 'Feedback1' }, { comment: 'Feedback2' }]))
    feedbackService.del.and.returnValue(of(null))

    TestBed.configureTestingModule({
      imports: [MatTableModule,
        TranslateModule.forRoot(),
        MatDialogModule,
        MatPaginatorModule,
        MatDividerModule,
        MatCardModule,
        MatIconModule,
        AdministrationComponent],
      providers: [
        { provide: MatDialog, useValue: dialog },
        { provide: UserService, useValue: userService },
        { provide: FeedbackService, useValue: feedbackService },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(AdministrationComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should find all users via the UserService', () => {
    component.findAllUsers()
    expect(component.userDataSource.data.length).toBe(2)
    expect(component.userDataSource.data[0].email).toMatch(/User1/)
    expect(component.userDataSource.data[1].email).toMatch(/User2/)
  })

  it('should give an error if UserService fails to find all users', fakeAsync(() => {
    userService.find.and.returnValue(throwError('Error'))
    component.findAllUsers()

    tick()

    expect(component.error).toBe('Error')
  }))

  it('should find all feedbacks via FeedbackService', () => {
    component.findAllFeedbacks()
    expect(component.feedbackDataSource.data.length).toBe(2)
    expect(component.feedbackDataSource.data[0].comment).toMatch(/Feedback1/)
    expect(component.feedbackDataSource.data[1].comment).toMatch(/Feedback2/)
  })

  it('should give an error if FeedbackService fails to find all feedbacks', fakeAsync(() => {
    feedbackService.find.and.returnValue(throwError('Error'))
    component.findAllFeedbacks()

    tick()

    expect(component.error).toBe('Error')
  }))

  it('should refresh all feedbacks after deletion', () => {
    spyOn(component, 'findAllFeedbacks')
    component.deleteFeedback(1)
    expect(component.findAllFeedbacks).toHaveBeenCalled()
    expect(feedbackService.del).toHaveBeenCalledWith(1)
  })

  it('should give an error if FeedbackService fails to delete feedback', fakeAsync(() => {
    feedbackService.del.and.returnValue(throwError('Error'))
    component.deleteFeedback(1)

    tick()

    expect(component.error).toBe('Error')
  }))

  it('should open the UserDetailsComponent to show details', () => {
    component.showUserDetail(1)
    expect(dialog.open).toHaveBeenCalledWith(UserDetailsComponent, { data: { id: 1 } })
  })

  it('should open the FeedbackDetailsComponent to show details', () => {
    component.showFeedbackDetails('Feedback', 1)
    expect(dialog.open).toHaveBeenCalledWith(FeedbackDetailsComponent, { data: { feedback: 'Feedback', id: 1 } })
  })

  it('should have three columns in the user table', () => {
    expect(component.userColumns.length).toBe(3)
    expect(component.userColumns[0]).toBe('user')
    expect(component.userColumns[1]).toBe('email')
    expect(component.userColumns[2]).toBe('user_detail')
  })

  it('should have four columns in the feedback table', () => {
    expect(component.feedbackColumns.length).toBe(4)
    expect(component.feedbackColumns[0]).toBe('user')
    expect(component.feedbackColumns[1]).toBe('comment')
    expect(component.feedbackColumns[2]).toBe('rating')
    expect(component.feedbackColumns[3]).toBe('remove')
  })
})


/* ===== FILE: ./frontend/src/app/administration/administration.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { UserDetailsComponent } from '../user-details/user-details.component'
import { FeedbackDetailsComponent } from '../feedback-details/feedback-details.component'
import { MatDialog } from '@angular/material/dialog'
import { FeedbackService } from '../Services/feedback.service'
import { MatTableDataSource, MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow } from '@angular/material/table'
import { UserService } from '../Services/user.service'
import { Component, type OnInit, ViewChild } from '@angular/core'
import { DomSanitizer } from '@angular/platform-browser'
import { library } from '@fortawesome/fontawesome-svg-core'
import { faArchive, faEye, faHome, faTrashAlt, faUser } from '@fortawesome/free-solid-svg-icons'
import { MatPaginator } from '@angular/material/paginator'
import { MatIconModule } from '@angular/material/icon'
import { MatTooltip } from '@angular/material/tooltip'
import { MatButtonModule } from '@angular/material/button'
import { NgIf, NgFor } from '@angular/common'
import { FlexModule } from '@angular/flex-layout/flex'
import { TranslateModule } from '@ngx-translate/core'
import { MatCardModule } from '@angular/material/card'

library.add(faUser, faEye, faHome, faArchive, faTrashAlt)

@Component({
  selector: 'app-administration',
  templateUrl: './administration.component.html',
  styleUrls: ['./administration.component.scss'],
  imports: [MatCardModule, TranslateModule, FlexModule, MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, NgIf, MatButtonModule, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow, MatPaginator, MatTooltip, NgFor, MatIconModule]
})
export class AdministrationComponent implements OnInit {
  public userDataSource: any
  public userDataSourceHidden: any
  public userColumns = ['user', 'email', 'user_detail']
  public feedbackDataSource: any
  public feedbackColumns = ['user', 'comment', 'rating', 'remove']
  public error: any
  public resultsLengthUser = 0
  public resultsLengthFeedback = 0
  @ViewChild('paginatorUsers') paginatorUsers: MatPaginator
  @ViewChild('paginatorFeedb') paginatorFeedb: MatPaginator
  constructor (private readonly dialog: MatDialog, private readonly userService: UserService, private readonly feedbackService: FeedbackService,
    private readonly sanitizer: DomSanitizer) {}

  ngOnInit (): void {
    this.findAllUsers()
    this.findAllFeedbacks()
  }

  findAllUsers () {
    this.userService.find().subscribe((users) => {
      this.userDataSource = users
      this.userDataSourceHidden = users
      for (const user of this.userDataSource) {
        user.email = this.sanitizer.bypassSecurityTrustHtml(`<span class="${this.doesUserHaveAnActiveSession(user) ? 'confirmation' : 'error'}">${user.email}</span>`)
      }
      this.userDataSource = new MatTableDataSource(this.userDataSource)
      this.userDataSource.paginator = this.paginatorUsers
      this.resultsLengthUser = users.length
    }, (err) => {
      this.error = err
      console.log(this.error)
    })
  }

  findAllFeedbacks () {
    this.feedbackService.find().subscribe((feedbacks) => {
      this.feedbackDataSource = feedbacks
      for (const feedback of this.feedbackDataSource) {
        feedback.comment = this.sanitizer.bypassSecurityTrustHtml(feedback.comment)
      }
      this.feedbackDataSource = new MatTableDataSource(this.feedbackDataSource)
      this.feedbackDataSource.paginator = this.paginatorFeedb
      this.resultsLengthFeedback = feedbacks.length
    }, (err) => {
      this.error = err
      console.log(this.error)
    })
  }

  deleteFeedback (id: number) {
    this.feedbackService.del(id).subscribe(() => {
      this.findAllFeedbacks()
    }, (err) => {
      this.error = err
      console.log(this.error)
    })
  }

  showUserDetail (id: number) {
    this.dialog.open(UserDetailsComponent, {
      data: {
        id
      }
    })
  }

  showFeedbackDetails (feedback: any, id: number) {
    this.dialog.open(FeedbackDetailsComponent, {
      data: {
        feedback,
        id
      }
    })
  }

  times (numberOfTimes: number) {
    return Array(numberOfTimes).fill('★')
  }

  doesUserHaveAnActiveSession (user: { email: string, lastLoginTime: number }) {
    const SIX_HOURS_IN_SECONDS = 60 * 60 * 6
    return user.lastLoginTime && user.lastLoginTime > ((Date.now() / 1000) - SIX_HOURS_IN_SECONDS)
  }
}


/* ===== FILE: ./frontend/src/app/roles.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

export const roles = {
  customer: 'customer',
  deluxe: 'deluxe',
  accounting: 'accounting',
  admin: 'admin'
}


/* ===== FILE: ./frontend/src/app/payment-method/payment-method.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { UntypedFormControl, Validators, FormsModule, ReactiveFormsModule } from '@angular/forms'
import { Component, EventEmitter, Input, type OnInit, Output } from '@angular/core'
import { PaymentService } from '../Services/payment.service'
import { MatTableDataSource, MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow } from '@angular/material/table'
import { library } from '@fortawesome/fontawesome-svg-core'
import { faPaperPlane } from '@fortawesome/free-solid-svg-icons'
import { faTrashAlt } from '@fortawesome/free-regular-svg-icons/'
import { TranslateService, TranslateModule } from '@ngx-translate/core'
import { SnackBarHelperService } from '../Services/snack-bar-helper.service'
import { MatInputModule } from '@angular/material/input'
import { MatFormFieldModule, MatLabel, MatError, MatHint } from '@angular/material/form-field'
import { MatExpansionPanel, MatExpansionPanelHeader, MatExpansionPanelTitle, MatExpansionPanelDescription } from '@angular/material/expansion'
import { MatIconButton, MatButtonModule } from '@angular/material/button'
import { MatRadioButton } from '@angular/material/radio'
import { NgIf, NgFor } from '@angular/common'
import { FlexModule } from '@angular/flex-layout/flex'
import { MatIconModule } from '@angular/material/icon'

library.add(faPaperPlane, faTrashAlt)

@Component({
  selector: 'app-payment-method',
  templateUrl: './payment-method.component.html',
  styleUrls: ['./payment-method.component.scss'],
  imports: [FlexModule, NgIf, MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, MatRadioButton, MatIconButton, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow, MatExpansionPanel, MatExpansionPanelHeader, MatExpansionPanelTitle, MatExpansionPanelDescription, MatFormFieldModule, MatLabel, TranslateModule, MatInputModule, FormsModule, ReactiveFormsModule, MatError, MatHint, NgFor, MatButtonModule, MatIconModule]
})

export class PaymentMethodComponent implements OnInit {
  @Output() emitSelection = new EventEmitter()
  @Input('allowDelete') public allowDelete: boolean = false
  public displayedColumns = ['Number', 'Name', 'Expiry']
  public nameControl: UntypedFormControl = new UntypedFormControl('', [Validators.required])
  // eslint-disable-next-line @typescript-eslint/no-loss-of-precision
  public numberControl: UntypedFormControl = new UntypedFormControl('', [Validators.required, Validators.min(1000000000000000), Validators.max(9999999999999999)])
  public monthControl: UntypedFormControl = new UntypedFormControl('', [Validators.required])
  public yearControl: UntypedFormControl = new UntypedFormControl('', [Validators.required])
  public confirmation: any
  public error: any
  public storedCards: any
  public card: any = {}
  public dataSource
  public monthRange: any[]
  public yearRange: any[]
  public cardsExist: boolean = false
  public paymentId: any = undefined

  constructor (public paymentService: PaymentService, private readonly translate: TranslateService, private readonly snackBarHelperService: SnackBarHelperService) { }

  ngOnInit (): void {
    this.monthRange = Array.from(Array(12).keys()).map(i => i + 1)
    this.yearRange = Array.from(Array(20).keys()).map(i => i + 2080)
    if (this.allowDelete) {
      this.displayedColumns.push('Remove')
    } else {
      this.displayedColumns.unshift('Selection')
    }
    this.load()
  }

  load () {
    this.paymentService.get().subscribe((cards) => {
      this.cardsExist = cards.length
      this.storedCards = cards
      this.dataSource = new MatTableDataSource<Element>(this.storedCards)
    }, (err) => { console.log(err) })
  }

  save () {
    this.card.fullName = this.nameControl.value
    this.card.cardNum = this.numberControl.value
    this.card.expMonth = this.monthControl.value
    this.card.expYear = this.yearControl.value
    this.paymentService.save(this.card).subscribe((savedCards) => {
      this.error = null
      this.translate.get('CREDIT_CARD_SAVED', { cardnumber: String(savedCards.cardNum).substring(String(savedCards.cardNum).length - 4) }).subscribe((creditCardSaved) => {
        this.snackBarHelperService.open(creditCardSaved, 'confirmBar')
      }, (translationId) => {
        this.snackBarHelperService.open(translationId, 'confirmBar')
      })
      this.load()
      this.resetForm()
    }, (err) => {
      this.snackBarHelperService.open(err.error?.error, 'errorBar')
      this.resetForm()
    })
  }

  delete (id) {
    this.paymentService.del(id).subscribe(() => {
      this.load()
    }, (err) => { console.log(err) })
  }

  emitSelectionToParent (id: number) {
    this.emitSelection.emit(id)
  }

  resetForm () {
    this.nameControl.markAsUntouched()
    this.nameControl.markAsPristine()
    this.nameControl.setValue('')
    this.numberControl.markAsUntouched()
    this.numberControl.markAsPristine()
    this.numberControl.setValue('')
    this.monthControl.markAsUntouched()
    this.monthControl.markAsPristine()
    this.monthControl.setValue('')
    this.yearControl.markAsUntouched()
    this.yearControl.markAsPristine()
    this.yearControl.setValue('')
  }
}


/* ===== FILE: ./frontend/src/app/payment-method/payment-method.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateModule, TranslateService } from '@ngx-translate/core'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { MatCardModule } from '@angular/material/card'
import { MatFormFieldModule } from '@angular/material/form-field'
import { type ComponentFixture, fakeAsync, TestBed, waitForAsync } from '@angular/core/testing'
import { MatInputModule } from '@angular/material/input'
import { ReactiveFormsModule } from '@angular/forms'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'

import { of, throwError } from 'rxjs'
import { MatTableModule } from '@angular/material/table'
import { MatExpansionModule } from '@angular/material/expansion'
import { MatDividerModule } from '@angular/material/divider'
import { MatRadioModule } from '@angular/material/radio'
import { PaymentService } from '../Services/payment.service'
import { MatDialogModule } from '@angular/material/dialog'
import { PaymentMethodComponent } from './payment-method.component'
import { EventEmitter } from '@angular/core'
import { MatSnackBar } from '@angular/material/snack-bar'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('PaymentMethodComponent', () => {
  let component: PaymentMethodComponent
  let fixture: ComponentFixture<PaymentMethodComponent>
  let paymentService
  let translateService
  let snackBar: any

  beforeEach(waitForAsync(() => {
    paymentService = jasmine.createSpyObj('BasketService', ['save', 'get', 'del'])
    paymentService.save.and.returnValue(of([]))
    paymentService.get.and.returnValue(of([]))
    paymentService.del.and.returnValue(of([]))
    translateService = jasmine.createSpyObj('TranslateService', ['get'])
    translateService.get.and.returnValue(of({}))
    translateService.onLangChange = new EventEmitter()
    translateService.onTranslationChange = new EventEmitter()
    translateService.onDefaultLangChange = new EventEmitter()
    snackBar = jasmine.createSpyObj('MatSnackBar', ['open'])

    TestBed.configureTestingModule({
      imports: [TranslateModule.forRoot(),
        ReactiveFormsModule,
        BrowserAnimationsModule,
        MatCardModule,
        MatTableModule,
        MatFormFieldModule,
        MatInputModule,
        MatExpansionModule,
        MatDividerModule,
        MatRadioModule,
        MatDialogModule,
        PaymentMethodComponent],
      providers: [
        { provide: PaymentService, useValue: paymentService },
        { provide: TranslateService, useValue: translateService },
        { provide: MatSnackBar, useValue: snackBar },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(PaymentMethodComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should hold cards returned by backend API', () => {
    paymentService.get.and.returnValue(of([{ cardNum: '************1231' }, { cardNum: '************6454' }]))
    component.load()
    expect(component.storedCards.length).toBe(2)
    expect(component.storedCards[0].cardNum).toBe('************1231')
    expect(component.storedCards[1].cardNum).toBe('************6454')
  })

  it('should hold no cards on error in backend API', fakeAsync(() => {
    paymentService.get.and.returnValue(throwError('Error'))
    component.load()
    expect(component.storedCards.length).toBe(0)
  }))

  it('should hold no cards when none are returned by backend API', () => {
    paymentService.get.and.returnValue(of([]))
    component.load()
    expect(component.storedCards).toEqual([])
  })

  it('should log error while getting Cards from backend API directly to browser console', fakeAsync(() => {
    paymentService.get.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.load()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should reinitizalise new payment method form by calling resetForm', () => {
    component.nameControl.setValue('jim')
    component.numberControl.setValue(1234567887654321)
    component.monthControl.setValue(12)
    component.yearControl.setValue(2085)
    component.resetForm()
    expect(component.nameControl.value).toBe('')
    expect(component.nameControl.pristine).toBe(true)
    expect(component.nameControl.untouched).toBe(true)
    expect(component.numberControl.value).toBe('')
    expect(component.numberControl.pristine).toBe(true)
    expect(component.numberControl.untouched).toBe(true)
    expect(component.monthControl.value).toBe('')
    expect(component.monthControl.pristine).toBe(true)
    expect(component.monthControl.untouched).toBe(true)
    expect(component.yearControl.value).toBe('')
    expect(component.yearControl.pristine).toBe(true)
    expect(component.yearControl.untouched).toBe(true)
  })

  it('should be compulsory to provide name', () => {
    component.nameControl.setValue('')
    expect(component.nameControl.valid).toBeFalsy()
  })

  it('should be compulsory to provide card number', () => {
    component.numberControl.setValue('')
    expect(component.numberControl.valid).toBeFalsy()
  })

  it('should be compulsory to provide month', () => {
    component.monthControl.setValue('')
    expect(component.monthControl.valid).toBeFalsy()
  })

  it('should be compulsory to provide year', () => {
    component.yearControl.setValue('')
    expect(component.yearControl.valid).toBeFalsy()
  })

  it('card number should be in the range [1000000000000000, 9999999999999999]', () => {
    component.numberControl.setValue(1111110)
    expect(component.numberControl.valid).toBeFalsy()
    // eslint-disable-next-line @typescript-eslint/no-loss-of-precision
    component.numberControl.setValue(99999999999999999)
    expect(component.numberControl.valid).toBeFalsy()
    // eslint-disable-next-line @typescript-eslint/no-loss-of-precision
    component.numberControl.setValue(9999999999999999)
    expect(component.numberControl.valid).toBe(true)
    component.numberControl.setValue(1234567887654321)
    expect(component.numberControl.valid).toBe(true)
  })

  it('should reset the form on saving card and show confirmation', () => {
    paymentService.get.and.returnValue(of([]))
    paymentService.save.and.returnValue(of({ cardNum: '1234' }))
    translateService.get.and.returnValue(of('CREDIT_CARD_SAVED'))
    spyOn(component, 'resetForm')
    spyOn(component, 'load')
    component.save()
    expect(translateService.get).toHaveBeenCalledWith('CREDIT_CARD_SAVED', { cardnumber: '1234' })
    expect(component.load).toHaveBeenCalled()
    expect(component.resetForm).toHaveBeenCalled()
  })

  it('should clear the form and display error if saving card fails', fakeAsync(() => {
    paymentService.save.and.returnValue(throwError({ error: 'Error' }))
    spyOn(component, 'resetForm')
    component.save()
    expect(snackBar.open).toHaveBeenCalled()
    expect(component.resetForm).toHaveBeenCalled()
  }))
})


/* ===== FILE: ./frontend/src/app/payment-method/payment-method.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<div fxLayout="column" fxLayoutGap="20px">
  <h1>{{"MY_PAYMENT_OPTIONS" | translate}}</h1>
  <div *ngIf="cardsExist">
    <mat-table [dataSource]="dataSource">
      <ng-container matColumnDef="Selection">
        <mat-header-cell *matHeaderCellDef fxFlex="15%"></mat-header-cell>
        <mat-cell *matCellDef="let element" fxFlex="15%">
          <mat-radio-button (click)="emitSelectionToParent(element.id)"></mat-radio-button>
        </mat-cell>
      </ng-container>
      <ng-container matColumnDef="Number">
        <mat-header-cell *matHeaderCellDef fxFlex="35%"></mat-header-cell>
        <mat-cell *matCellDef="let element" fxFlex="35%">{{ element.cardNum }}
        </mat-cell>
      </ng-container>
      <ng-container matColumnDef="Name">
        <mat-header-cell *matHeaderCellDef fxFlex="30%"></mat-header-cell>
        <mat-cell *matCellDef="let element" fxFlex="30%">{{ element.fullName }}</mat-cell>
      </ng-container>
      <ng-container matColumnDef="Expiry">
        <mat-header-cell *matHeaderCellDef fxFlex="20%"></mat-header-cell>
        <mat-cell *matCellDef="let element" fxFlex="20%">{{ element.expMonth }}/{{ element.expYear }}</mat-cell>
      </ng-container>
      <ng-container matColumnDef="Remove">
        <mat-header-cell *matHeaderCellDef fxFlex="15%"></mat-header-cell>
        <mat-cell *matCellDef="let element" fxFlex="15%">
          <button mat-icon-button (click)="delete(element.id)"><i class="far fa-trash-alt"></i></button>
        </mat-cell>
      </ng-container>
      <mat-header-row *matHeaderRowDef="displayedColumns"></mat-header-row>
      <mat-row *matRowDef="let row; columns: displayedColumns;"></mat-row>
    </mat-table>
  </div>
  <div>
    <mat-expansion-panel class="mat-elevation-z0">
      <mat-expansion-panel-header style="margin-bottom: 12px;">
        <mat-panel-title>
          {{"ADD_NEW_CARD" | translate}}
        </mat-panel-title>
        <mat-panel-description>
          {{"ADD_NEW_CARD_DESCRIPTION" | translate}}
        </mat-panel-description>
      </mat-expansion-panel-header>
      <div>
        <mat-form-field appearance="outline" color="accent">
          <mat-label translate>LABEL_NAME</mat-label>
          <input [formControl]="nameControl" type="text" matInput>
          <mat-error *ngIf="nameControl.invalid && nameControl.errors.required" translate>
            MANDATORY_NAME
          </mat-error>
        </mat-form-field>
        <mat-form-field appearance="outline" color="accent">
          <mat-label translate>LABEL_CARD_NUMBER</mat-label>
          <input #cardIn [formControl]="numberControl" type="number" matInput>
          <mat-hint align="end">{{cardIn .value?.length || 0}}/16</mat-hint>
          <mat-error *ngIf="numberControl.invalid && numberControl.errors.required" translate>
            MANDATORY_CARD_NUMBER
          </mat-error>
          <mat-error *ngIf="numberControl.invalid && (numberControl.errors.min || numberControl.errors.max)" translate>
            VALID_CARD_NUMBER
          </mat-error>
        </mat-form-field>
        <mat-form-field style="width: 45%;margin-right: 10%;" appearance="outline" color="accent">
          <mat-label translate>LABEL_EXPIRY_MONTH</mat-label>
          <select matNativeControl [formControl]="monthControl" required>
            <option *ngFor="let i of monthRange" value="{{ i }}">{{ i }}</option>
          </select>
          <mat-error *ngIf="monthControl.invalid && monthControl.errors.required" translate>
            MANDATORY_EXPIRY_MONTH
          </mat-error>
        </mat-form-field>
        <mat-form-field style="width: 45%" appearance="outline" color="accent">
          <mat-label translate>LABEL_EXPIRY_YEAR</mat-label>
          <select matNativeControl [formControl]="yearControl" required>
            <option *ngFor="let i of yearRange" value="{{ i }}">{{ i }}</option>
          </select>
          <mat-error *ngIf="yearControl.invalid && yearControl.errors.required" translate>
            MANDATORY_EXPIRY_YEAR
          </mat-error>
        </mat-form-field>
      </div>
      <button type="submit" id="submitButton" style="margin-top:5px; float:right;" mat-raised-button color="primary"
              [disabled]="nameControl.invalid || numberControl.invalid || monthControl.invalid || yearControl.invalid"
              (click)="save()">
              <mat-icon>send</mat-icon>
              {{'BTN_SUBMIT' | translate}}
      </button>
    </mat-expansion-panel>
  </div>
</div>


/* ===== FILE: ./frontend/src/app/nft-unlock/nft-unlock.component.html ===== */

<mat-card appearance="outlined">
  <div class="mdc-card container" fxLayout="column" fxLayoutGap="20px">
    <button
      class="detail-container offer-container warning-container"
      mat-raised-button
      color="warn"
      fxFlexAlign="center"
    >
    {{ 'BTN_SBT_NOTE' | translate }}
    </button>
    <div
      class="detail-container offer-container"
      fxFlexAlign="center"
      fxLayout="row"
      fxLayout.lt-lg="column"
    >
      <div>
        <img src="assets/public/images/products/juicy_chatbot.jpg" />
      </div>
      <div *ngIf="!successResponse">
        <div>
          <mat-card-title class="sbt-title">{{ 'TITLE_SBT' | translate }}</mat-card-title>
        </div>
        <form (ngSubmit)="submitForm()">
          <div class="form-group">
            <mat-form-field color="accent" appearance="outline" class="responsive-field">
              <mat-label>{{ 'LABEL_PRIVATE_KEY' | translate }}</mat-label>
              <input
                matInput
                [(ngModel)]="privateKey"
                id="privateKey"
                name="privateKey"
                required
                type="text"
                [attr.aria-label]="'LABEL_PRIVATE_KEY' | translate"
                class="text-ellipsis"
              />
            </mat-form-field>
            <h5 class="error">{{ errorMessage }}</h5>
          </div>

          <button
            type="submit"
            class="btn btn-primary"
            mat-raised-button
            color="accent"
          >
          {{ 'BTN_AUTHENTICATE' | translate }}
          </button>
        </form>
      </div>
      <div *ngIf="successResponse">
        <div>
          <mat-card-title >{{'TITLE_SBT'| translate}}</mat-card-title>
        </div>
        <div class="owner-text">
          {{'OWNED_BY' | translate}}
          <a
            target="_blank"
            href="https://testnets.opensea.io/0x8343d2eb2B13A2495De435a1b15e85b98115Ce05"
            >8343D2</a
          >
        </div>
        <mat-divider class="detail-divider"></mat-divider>
        <div class="detail-box mat-elevation-z6">
          <div class="box-title">{{ LABEL_ACCOUNT_ADDRESS | translate }}</div>
          <mat-divider class="detail-divider"></mat-divider>
          <p class="box-text">0x8343d2eb2B13A2495De435a1b15e85b98115Ce05</p>
        </div>
        <div class="detail-box mat-elevation-z6">
          <div class="box-title">{{ LABEL_DESCRIPTION |  translate }}</div>
          <mat-divider class="detail-divider"></mat-divider>
          <p class="box-text">
            {{'NFT_SBT_BOX_TEXT' | translate: {
              link: '<a
                target="_blank"
                href="https://testnets.opensea.io/assets/mumbai/0xf4817631372dca68a25a18eb7a0b36d54f3dbcf7/0"
              >Opensea</a>'
            &#125; &#125;&#125;
          </p>
        </div>
      </div>
    </div>
  </div>
</mat-card>


/* ===== FILE: ./frontend/src/app/nft-unlock/nft-unlock.component.ts ===== */

import { Component } from '@angular/core'
import { KeysService } from '../Services/keys.service'
import { MatDivider } from '@angular/material/divider'
import { MatInputModule } from '@angular/material/input'
import { MatFormFieldModule, MatLabel } from '@angular/material/form-field'
import { FormsModule } from '@angular/forms'
import { NgIf } from '@angular/common'
import { TranslateModule } from '@ngx-translate/core'
import { MatButtonModule } from '@angular/material/button'
import { FlexModule } from '@angular/flex-layout/flex'
import { MatCardModule, MatCardTitle } from '@angular/material/card'

@Component({
  selector: 'app-nft-unlock',
  templateUrl: './nft-unlock.component.html',
  styleUrls: ['./nft-unlock.component.scss'],
  imports: [MatCardModule, FlexModule, MatButtonModule, TranslateModule, NgIf, MatCardTitle, FormsModule, MatFormFieldModule, MatLabel, MatInputModule, MatDivider]
})
export class NFTUnlockComponent {
  privateKey: string
  formSubmitted: boolean = false
  successResponse: boolean = false
  errorMessage = ''

  constructor (private readonly keysService: KeysService) {}

  ngOnInit (): void {
    this.checkChallengeStatus()
  }

  checkChallengeStatus () {
    this.keysService.nftUnlocked().subscribe(
      (response) => {
        this.successResponse = response.status
      },
      (error) => {
        console.error(error)
        this.successResponse = false
      }
    )
  }

  submitForm () {
    this.formSubmitted = true
    this.keysService.submitKey(this.privateKey).subscribe(
      (response) => {
        if (response.success) {
          this.successResponse = true
          this.errorMessage = response.message
        } else {
          this.successResponse = false
        }
      },
      (error) => {
        this.successResponse = false
        this.errorMessage = error.error.message
      }
    )
  }
}


/* ===== FILE: ./frontend/src/app/code-fixes/code-fixes.component.spec.ts ===== */

import { type ComponentFixture, TestBed } from '@angular/core/testing'
import { CookieModule, CookieService } from 'ngy-cookie'

import { CodeFixesComponent } from './code-fixes.component'

describe('CodeFixesComponent', () => {
  let component: CodeFixesComponent
  let fixture: ComponentFixture<CodeFixesComponent>
  let cookieService: any

  beforeEach(async () => {
    cookieService = jasmine.createSpyObj('CookieService', ['put', 'get', 'hasKey'])
    await TestBed.configureTestingModule({
      imports: [CookieModule.forRoot(), CodeFixesComponent],
      providers: [{ provide: CookieService, useValue: cookieService }]
    })
      .compileComponents()
  })

  beforeEach(() => {
    fixture = TestBed.createComponent(CodeFixesComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should set the format from cookie if the cookie key exists', () => {
    cookieService.hasKey.and.returnValue(true)
    cookieService.get.and.returnValue('LineByLine')
    component.ngOnInit()
    expect(component.format).toBe('LineByLine')
  })

  it('should set the format to "LineByLine" and save it in the cookie if the cookie key does not exist', () => {
    cookieService.hasKey.and.returnValue(false)
    component.ngOnInit()
    expect(component.format).toBe('LineByLine')
    expect(cookieService.put).toHaveBeenCalledWith('code-fixes-component-format', 'LineByLine')
  })
})


/* ===== FILE: ./frontend/src/app/code-fixes/code-fixes.component.ts ===== */

import { Component, Input, type OnInit, ViewChild, type DoCheck, KeyValueDiffers, type KeyValueDiffer } from '@angular/core'
import { NgxTextDiffComponent, NgxTextDiffModule } from '@winarg/ngx-text-diff'

import { CookieService } from 'ngy-cookie'
import { type RandomFixes } from '../code-snippet/code-snippet.component'
import { type DiffTableFormat } from '@winarg/ngx-text-diff/lib/ngx-text-diff.model'
import { NgIf } from '@angular/common'

@Component({
  selector: 'app-code-fixes',
  templateUrl: './code-fixes.component.html',
  styleUrls: ['./code-fixes.component.scss'],
  imports: [NgIf, NgxTextDiffModule]
})
export class CodeFixesComponent implements OnInit, DoCheck {
  differ: KeyValueDiffer<string, DiffTableFormat>

  constructor (private readonly cookieService: CookieService, private readonly differs: KeyValueDiffers) {
    this.cookieService = cookieService
    this.differ = this.differs.find({}).create()
  }

  @Input('snippet')
  public snippet: string = ''

  @Input('fixes')
  public fixes: string[] = []

  @Input('selectedFix')
  public selectedFix: number = 0

  @Input('randomFixes')
  public randomFixes: RandomFixes[] = []

  @Input('format')
  public format: string = 'SideBySide'

  @ViewChild('codeComponent', { static: false }) codeComponent: NgxTextDiffComponent

  ngOnInit (): void {
    if (this.cookieService.hasKey('code-fixes-component-format')) {
      this.format = this.cookieService.get('code-fixes-component-format')
    } else {
      this.format = 'LineByLine'
      this.cookieService.put('code-fixes-component-format', 'LineByLine')
    }
  }

  ngDoCheck () {
    try {
      const change = this.differ.diff({ 'diff-format': this.codeComponent.format })
      if (change) {
        change.forEachChangedItem(item => {
          this.format = item.currentValue
          this.cookieService.put('code-fixes-component-format', this.format)
        }
        )
      }
    } catch {
    }
  }
}


/* ===== FILE: ./frontend/src/app/code-fixes/code-fixes.component.html ===== */

@for (fix of randomFixes;  track fix.index) {
    <td-ngx-text-diff *ngIf="selectedFix === $index" [left]="snippet" [right]="fix?.fix" [format]="format" #codeComponent>
    </td-ngx-text-diff>
}


/* ===== FILE: ./frontend/src/app/privacy-security/privacy-security.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Component } from '@angular/core'
import { RouterOutlet } from '@angular/router'

@Component({
  selector: 'app-privacy-security',
  templateUrl: './privacy-security.component.html',
  styleUrls: ['./privacy-security.component.scss'],
  imports: [RouterOutlet]
})
export class PrivacySecurityComponent {}


/* ===== FILE: ./frontend/src/app/privacy-security/privacy-security.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type ComponentFixture, TestBed, waitForAsync } from '@angular/core/testing'
import { NoopAnimationsModule } from '@angular/platform-browser/animations'
import { PrivacySecurityComponent } from './privacy-security.component'
import { RouterOutlet } from '@angular/router'

describe('PrivacySecurityComponent', () => {
  let component: PrivacySecurityComponent
  let fixture: ComponentFixture<PrivacySecurityComponent>

  beforeEach(waitForAsync(() => {
    TestBed.configureTestingModule({
      imports: [
        NoopAnimationsModule,
        RouterOutlet,
        PrivacySecurityComponent
      ]
    }).compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(PrivacySecurityComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should compile', () => {
    expect(component).toBeTruthy()
  })
})


/* ===== FILE: ./frontend/src/app/privacy-security/privacy-security.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<router-outlet></router-outlet>


/* ===== FILE: ./frontend/src/app/app.routing.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TokenSaleComponent } from './token-sale/token-sale.component'
import { OAuthComponent } from './oauth/oauth.component'
import { BasketComponent } from './basket/basket.component'
import { TrackResultComponent } from './track-result/track-result.component'
import { ContactComponent } from './contact/contact.component'
import { AboutComponent } from './about/about.component'
import { RegisterComponent } from './register/register.component'
import { ForgotPasswordComponent } from './forgot-password/forgot-password.component'
import { SearchResultComponent } from './search-result/search-result.component'
import { LoginComponent } from './login/login.component'
import { AdministrationComponent } from './administration/administration.component'
import { ChangePasswordComponent } from './change-password/change-password.component'
import { ComplaintComponent } from './complaint/complaint.component'
import { ChatbotComponent } from './chatbot/chatbot.component'
import { RecycleComponent } from './recycle/recycle.component'
import { RouterModule, type Routes, type UrlMatchResult, type UrlSegment } from '@angular/router'
import { TwoFactorAuthEnterComponent } from './two-factor-auth-enter/two-factor-auth-enter.component'
import { ErrorPageComponent } from './error-page/error-page.component'
import { PrivacySecurityComponent } from './privacy-security/privacy-security.component'
import { TwoFactorAuthComponent } from './two-factor-auth/two-factor-auth.component'
import { DataExportComponent } from './data-export/data-export.component'
import { LastLoginIpComponent } from './last-login-ip/last-login-ip.component'
import { PrivacyPolicyComponent } from './privacy-policy/privacy-policy.component'
import { AddressCreateComponent } from './address-create/address-create.component'
import { AddressSelectComponent } from './address-select/address-select.component'
import { SavedAddressComponent } from './saved-address/saved-address.component'
import { PaymentComponent } from './payment/payment.component'
import { SavedPaymentMethodsComponent } from './saved-payment-methods/saved-payment-methods.component'
import { AccountingComponent } from './accounting/accounting.component'
import { OrderCompletionComponent } from './order-completion/order-completion.component'
import { OrderSummaryComponent } from './order-summary/order-summary.component'
import { WalletComponent } from './wallet/wallet.component'
import { OrderHistoryComponent } from './order-history/order-history.component'
import { DeliveryMethodComponent } from './delivery-method/delivery-method.component'
import { PhotoWallComponent } from './photo-wall/photo-wall.component'
import { DeluxeUserComponent } from './deluxe-user/deluxe-user.component'
import { AccountingGuard, AdminGuard, LoginGuard } from './app.guard'
import { NFTUnlockComponent } from './nft-unlock/nft-unlock.component'
import { ScoreBoardComponent } from './score-board/score-board.component'

const loadFaucetModule = async () => {
  const module = await import('./faucet/faucet.module')
  return module.FaucetModule
}
const loadWeb3WalletModule = async () => {
  const module = await import('./wallet-web3/wallet-web3.module')
  return module.WalletWeb3Module
}

const loadWeb3SandboxModule = async () => {
  const module = await import('./web3-sandbox/web3-sandbox.module')
  return module.Web3SandboxModule
}
// vuln-code-snippet start adminSectionChallenge scoreBoardChallenge web3SandboxChallenge
const routes: Routes = [
  { // vuln-code-snippet neutral-line adminSectionChallenge
    path: 'administration', // vuln-code-snippet vuln-line adminSectionChallenge
    component: AdministrationComponent, // vuln-code-snippet neutral-line adminSectionChallenge
    canActivate: [AdminGuard] // vuln-code-snippet neutral-line adminSectionChallenge
  }, // vuln-code-snippet neutral-line adminSectionChallenge
  {
    path: 'accounting',
    component: AccountingComponent,
    canActivate: [AccountingGuard]
  },
  {
    path: 'about',
    component: AboutComponent
  },
  {
    path: 'address/select',
    component: AddressSelectComponent,
    canActivate: [LoginGuard]
  },
  {
    path: 'address/saved',
    component: SavedAddressComponent,
    canActivate: [LoginGuard]
  },
  {
    path: 'address/create',
    component: AddressCreateComponent,
    canActivate: [LoginGuard]
  },
  {
    path: 'address/edit/:addressId',
    component: AddressCreateComponent,
    canActivate: [LoginGuard]
  },
  {
    path: 'delivery-method',
    component: DeliveryMethodComponent
  },
  {
    path: 'deluxe-membership',
    component: DeluxeUserComponent,
    canActivate: [LoginGuard]
  },
  {
    path: 'saved-payment-methods',
    component: SavedPaymentMethodsComponent
  },
  {
    path: 'basket',
    component: BasketComponent
  },
  {
    path: 'order-completion/:id',
    component: OrderCompletionComponent
  },
  {
    path: 'contact',
    component: ContactComponent
  },
  {
    path: 'photo-wall',
    component: PhotoWallComponent
  },
  {
    path: 'complain',
    component: ComplaintComponent
  },
  {
    path: 'chatbot',
    component: ChatbotComponent
  },
  {
    path: 'order-summary',
    component: OrderSummaryComponent
  },
  {
    path: 'order-history',
    component: OrderHistoryComponent
  },
  {
    path: 'payment/:entity',
    component: PaymentComponent
  },
  {
    path: 'wallet',
    component: WalletComponent
  },
  {
    path: 'login',
    component: LoginComponent
  },
  {
    path: 'forgot-password',
    component: ForgotPasswordComponent
  },
  {
    path: 'recycle',
    component: RecycleComponent
  },
  {
    path: 'register',
    component: RegisterComponent
  },
  {
    path: 'search',
    component: SearchResultComponent
  },
  {
    path: 'hacking-instructor',
    component: SearchResultComponent
  },
  { // vuln-code-snippet neutral-line scoreBoardChallenge
    path: 'score-board', // vuln-code-snippet vuln-line scoreBoardChallenge
    component: ScoreBoardComponent // vuln-code-snippet neutral-line scoreBoardChallenge
  }, // vuln-code-snippet neutral-line scoreBoardChallenge
  {
    path: 'track-result',
    component: TrackResultComponent
  },
  {
    path: 'track-result/new',
    component: TrackResultComponent,
    data: {
      type: 'new'
    }
  },
  {
    path: '2fa/enter',
    component: TwoFactorAuthEnterComponent
  },
  {
    path: 'privacy-security',
    component: PrivacySecurityComponent,
    children: [
      {
        path: 'privacy-policy',
        component: PrivacyPolicyComponent
      },
      {
        path: 'change-password',
        component: ChangePasswordComponent
      },
      {
        path: 'two-factor-authentication',
        component: TwoFactorAuthComponent
      },
      {
        path: 'data-export',
        component: DataExportComponent
      },
      {
        path: 'last-login-ip',
        component: LastLoginIpComponent
      }
    ]
  },
  {
    path: 'juicy-nft',
    component: NFTUnlockComponent
  },
  {
    path: 'wallet-web3',
    loadChildren: async () => await loadWeb3WalletModule()
  },
  { // vuln-code-snippet neutral-line web3SandboxChallenge
    path: 'web3-sandbox', // vuln-code-snippet vuln-line web3SandboxChallenge
    loadChildren: async () => await loadWeb3SandboxModule() // vuln-code-snippet neutral-line web3SandboxChallenge
  }, // vuln-code-snippet neutral-line web3SandboxChallenge
  {
    path: 'bee-haven',
    loadChildren: async () => await loadFaucetModule()
  },
  // vuln-code-snippet start tokenSaleChallenge
  {
    matcher: oauthMatcher,
    data: { params: (window.location.href).substr(window.location.href.indexOf('#')) },
    component: OAuthComponent
  },
  { // vuln-code-snippet neutral-line tokenSaleChallenge
    matcher: tokenMatcher, // vuln-code-snippet vuln-line tokenSaleChallenge
    component: TokenSaleComponent // vuln-code-snippet neutral-line tokenSaleChallenge
  }, // vuln-code-snippet neutral-line tokenSaleChallenge
  {
    path: '403',
    component: ErrorPageComponent
  },
  {
    path: '**',
    component: SearchResultComponent
  }
]
// vuln-code-snippet end adminSectionChallenge scoreBoardChallenge web3SandboxChallenge

export const Routing = RouterModule.forRoot(routes, { useHash: true })

export function oauthMatcher (url: UrlSegment[]): UrlMatchResult {
  if (url.length === 0) {
    return null as unknown as UrlMatchResult
  }
  const path = window.location.href
  if (path.includes('#access_token=')) {
    return ({ consumed: url })
  }

  return null as unknown as UrlMatchResult
}

export function tokenMatcher (url: UrlSegment[]): UrlMatchResult { // vuln-code-snippet neutral-line tokenSaleChallenge
  if (url.length === 0) { // vuln-code-snippet neutral-line tokenSaleChallenge
    return null as unknown as UrlMatchResult // vuln-code-snippet neutral-line tokenSaleChallenge
  } // vuln-code-snippet neutral-line tokenSaleChallenge
  // vuln-code-snippet neutral-line tokenSaleChallenge
  const path = url[0].toString() // vuln-code-snippet neutral-line tokenSaleChallenge
  // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
  if (path.match((token1(25, 184, 174, 179, 182, 186) + (36669).toString(36).toLowerCase() + token2(13, 144, 87, 152, 139, 144, 83, 138) + (10).toString(36).toLowerCase()))) { // vuln-code-snippet vuln-line tokenSaleChallenge
    return ({ consumed: url }) // vuln-code-snippet neutral-line tokenSaleChallenge
  } // vuln-code-snippet neutral-line tokenSaleChallenge
  // vuln-code-snippet neutral-line tokenSaleChallenge
  return null as unknown as UrlMatchResult // vuln-code-snippet neutral-line tokenSaleChallenge
} // vuln-code-snippet neutral-line tokenSaleChallenge

export function token1 (...args: number[]) { // vuln-code-snippet neutral-line tokenSaleChallenge
  const L = Array.prototype.slice.call(args) // vuln-code-snippet neutral-line tokenSaleChallenge
  const D = L.shift() // vuln-code-snippet neutral-line tokenSaleChallenge
  return L.reverse().map(function (C, A) { // vuln-code-snippet neutral-line tokenSaleChallenge
    return String.fromCharCode(C - D - 45 - A) // vuln-code-snippet neutral-line tokenSaleChallenge
  }).join('') // vuln-code-snippet neutral-line tokenSaleChallenge
} // vuln-code-snippet neutral-line tokenSaleChallenge

export function token2 (...args: number[]) { // vuln-code-snippet neutral-line tokenSaleChallenge
  const T = Array.prototype.slice.call(arguments) // vuln-code-snippet neutral-line tokenSaleChallenge
  const M = T.shift() // vuln-code-snippet neutral-line tokenSaleChallenge
  return T.reverse().map(function (m, H) { // vuln-code-snippet neutral-line tokenSaleChallenge
    return String.fromCharCode(m - M - 24 - H) // vuln-code-snippet neutral-line tokenSaleChallenge
  }).join('') // vuln-code-snippet neutral-line tokenSaleChallenge
} // vuln-code-snippet neutral-line tokenSaleChallenge
// vuln-code-snippet end tokenSaleChallenge


/* ===== FILE: ./frontend/src/app/change-password/change-password.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<div fxLayoutAlign="center">
  <mat-card appearance="outlined" class="mat-elevation-z6" style="margin-bottom: 20px;">
    <div class="mdc-card">

      <h1 >{{"TITLE_CHANGE_PASSWORD" | translate }}</h1>

      <div class="confirmation"
          [hidden]="!(confirmation && !passwordControl.dirty && !newPasswordControl.dirty && !repeatNewPasswordControl.dirty)">
        {{ confirmation }}
      </div>

      <div class="error"
          [hidden]="!(error && !passwordControl.dirty && !newPasswordControl.dirty && !repeatNewPasswordControl.dirty)">
        {{ error }}
      </div>

      <div class="form-container" id="password-form">

        <mat-form-field appearance="outline" color="accent">
          <mat-label >{{"LABEL_CURRENT_PASSWORD" | translate }}</mat-label>
          <input id="currentPassword" [formControl]="passwordControl" type="password" matInput
                aria-label="Field to enter the current password"
                placeholder="{{'MANDATORY_CURRENT_PASSWORD' | translate }}">
          <mat-error *ngIf="passwordControl.invalid" >{{"MANDATORY_CURRENT_PASSWORD" | translate }}</mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" color="accent">
          <mat-label >{{"LABEL_NEW_PASSWORD" | translate }}</mat-label>
          <input #password id="newPassword" [formControl]="newPasswordControl" type="password" matInput
                aria-label="Field for the new password">
          <mat-hint translate>
            <i class="fas fa-exclamation-circle"></i>
            <em style="margin-left:5px;" translate>{{ 'INVALID_PASSWORD_LENGTH' | translate: {length: '5-40'} }}</em>
          </mat-hint>
          <mat-hint align="end">{{password.value?.length || 0}}/40</mat-hint>
          <mat-error *ngIf="newPasswordControl?.invalid && newPasswordControl?.errors.required">
            {{"MANDATORY_NEW_PASSWORD" | translate }}
          </mat-error>
          <mat-error
            *ngIf="newPasswordControl?.invalid && (newPasswordControl?.errors.minlength || newPasswordControl?.errors.maxlength)"
            translate [translateParams]="{length: '5-40'}">{{"INVALID_PASSWORD_LENGTH"| translate }}
          </mat-error>
        </mat-form-field>

        <mat-form-field appearance="outline" color="accent">
          <mat-label>{{"LABEL_REPEAT_NEW_PASSWORD"| translate }}</mat-label>
          <input #passwordRepeat id="newPasswordRepeat" [formControl]="repeatNewPasswordControl" type="password" matInput
                aria-label="Field to repeat the new password">
          <mat-hint align="end">{{passwordRepeat.value?.length || 0}}/20</mat-hint>
          <mat-error *ngIf="repeatNewPasswordControl.invalid && repeatNewPasswordControl.errors.required" translate>MANDATORY_PASSWORD_REPEAT</mat-error>
          <mat-error *ngIf="repeatNewPasswordControl.invalid && repeatNewPasswordControl.errors.notSame" translate>
            {{"PASSWORDS_NOT_MATCHING" | translate }}
          </mat-error>
        </mat-form-field>

      </div>

      <button type="submit" id="changeButton"
              [disabled]="passwordControl.invalid || newPasswordControl.invalid || repeatNewPasswordControl.invalid"
              mat-raised-button color="primary" (click)="changePassword()" aria-label="Button to confirm the change">
        <i class="far fa-edit fa-lg" aria-hidden="true"></i>
        {{'BTN_CHANGE' | translate}}
      </button>

    </div>
  </mat-card>
</div>


/* ===== FILE: ./frontend/src/app/change-password/change-password.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateModule } from '@ngx-translate/core'
import { UserService } from '../Services/user.service'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { type ComponentFixture, fakeAsync, TestBed, waitForAsync } from '@angular/core/testing'
import { ChangePasswordComponent } from './change-password.component'
import { ReactiveFormsModule } from '@angular/forms'

import { BrowserAnimationsModule } from '@angular/platform-browser/animations'
import { MatButtonModule } from '@angular/material/button'
import { MatInputModule } from '@angular/material/input'
import { MatFormFieldModule } from '@angular/material/form-field'
import { MatCardModule } from '@angular/material/card'
import { of, throwError } from 'rxjs'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('ChangePasswordComponent', () => {
  let component: ChangePasswordComponent
  let fixture: ComponentFixture<ChangePasswordComponent>
  let userService: any

  beforeEach(waitForAsync(() => {
    userService = jasmine.createSpyObj('UserService', ['changePassword'])
    userService.changePassword.and.returnValue(of({}))

    TestBed.configureTestingModule({
      imports: [TranslateModule.forRoot(),
        ReactiveFormsModule,
        BrowserAnimationsModule,
        MatCardModule,
        MatFormFieldModule,
        MatInputModule,
        MatButtonModule,
        ChangePasswordComponent],
      providers: [{ provide: UserService, useValue: userService }, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(ChangePasswordComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should be compulsory to give password', () => {
    component.passwordControl.setValue('')
    expect(component.passwordControl.valid).toBeFalsy()
    component.passwordControl.setValue('pass')
    expect(component.passwordControl.valid).toBe(true)
  })

  it('length of new password must be 5-40 characters', () => {
    component.newPasswordControl.setValue('old')
    expect(component.newPasswordControl.valid).toBeFalsy()
    component.newPasswordControl.setValue('new password')
    expect(component.newPasswordControl.valid).toBe(true)
    component.newPasswordControl.setValue('new password new password')
    expect(component.newPasswordControl.valid).toBe(true)
    component.newPasswordControl.setValue('new password new password new password new password')
    expect(component.newPasswordControl.valid).toBeFalsy()
  })

  it('should be compulsory to repeat new password', () => {
    component.repeatNewPasswordControl.setValue('')
    expect(component.passwordControl.valid).toBeFalsy()
    component.newPasswordControl.setValue('passed')
    component.repeatNewPasswordControl.setValue('passed')
    expect(component.repeatNewPasswordControl.valid).toBe(true)
  })

  it('should reinitizalise forms by calling resetForm', () => {
    component.passwordControl.setValue('password')
    component.newPasswordControl.setValue('newPassword')
    component.repeatNewPasswordControl.setValue('newPassword')
    component.resetForm()
    expect(component.passwordControl.value).toBe('')
    expect(component.passwordControl.pristine).toBe(true)
    expect(component.passwordControl.untouched).toBe(true)
    expect(component.newPasswordControl.value).toBe('')
    expect(component.newPasswordControl.pristine).toBe(true)
    expect(component.newPasswordControl.untouched).toBe(true)
    expect(component.repeatNewPasswordControl.value).toBe('')
    expect(component.repeatNewPasswordControl.pristine).toBe(true)
    expect(component.repeatNewPasswordControl.untouched).toBe(true)
  })

  it('should clear form and show confirmation after changing password', () => {
    userService.changePassword.and.returnValue(of({}))
    spyOn(component, 'resetForm')
    component.passwordControl.setValue('old')
    component.newPasswordControl.setValue('foobar')
    component.repeatNewPasswordControl.setValue('foobar')
    component.changePassword()
    expect(component.error).toBeUndefined()
    expect(component.confirmation).toBeDefined()
    expect(component.resetForm).toHaveBeenCalled()
  })

  it('should clear form and gracefully handle error on password change', fakeAsync(() => {
    userService.changePassword.and.returnValue(throwError('Error'))
    spyOn(component, 'resetPasswords')
    console.log = jasmine.createSpy('log')
    component.passwordControl.setValue('old')
    component.newPasswordControl.setValue('foobar')
    component.repeatNewPasswordControl.setValue('fooabar')
    component.changePassword()
    expect(component.confirmation).toBeUndefined()
    expect(component.error).toBe('Error')
    expect(console.log).toHaveBeenCalledWith('Error')
    expect(component.resetPasswords).toHaveBeenCalled()
  }))
})


/* ===== FILE: ./frontend/src/app/change-password/change-password.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type AbstractControl, UntypedFormControl, Validators, FormsModule, ReactiveFormsModule } from '@angular/forms'
import { UserService } from '../Services/user.service'
import { Component } from '@angular/core'
import { library } from '@fortawesome/fontawesome-svg-core'
import { faSave } from '@fortawesome/free-solid-svg-icons'
import { faEdit } from '@fortawesome/free-regular-svg-icons'
import { FormSubmitService } from '../Services/form-submit.service'
import { TranslateService, TranslateModule } from '@ngx-translate/core'
import { MatButtonModule } from '@angular/material/button'
import { NgIf } from '@angular/common'
import { MatInputModule } from '@angular/material/input'
import { MatFormFieldModule, MatLabel, MatError, MatHint } from '@angular/material/form-field'
import { MatCardModule } from '@angular/material/card'
import { FlexModule } from '@angular/flex-layout/flex'

library.add(faSave, faEdit)

@Component({
  selector: 'app-change-password',
  templateUrl: './change-password.component.html',
  styleUrls: ['./change-password.component.scss'],
  imports: [FlexModule, MatCardModule, TranslateModule, MatFormFieldModule, MatLabel, MatInputModule, FormsModule, ReactiveFormsModule, NgIf, MatError, MatHint, MatButtonModule]
})
export class ChangePasswordComponent {
  public passwordControl: UntypedFormControl = new UntypedFormControl('', [Validators.required])
  public newPasswordControl: UntypedFormControl = new UntypedFormControl('', [Validators.required, Validators.minLength(5), Validators.maxLength(40)])
  public repeatNewPasswordControl: UntypedFormControl = new UntypedFormControl('', [Validators.required, Validators.minLength(5), Validators.maxLength(40), matchValidator(this.newPasswordControl)])
  public error: any
  public confirmation: any

  constructor (private readonly userService: UserService, private readonly formSubmitService: FormSubmitService, private readonly translate: TranslateService) { }

  ngOnInit (): void {
    this.formSubmitService.attachEnterKeyHandler('password-form', 'changeButton', () => { this.changePassword() })
  }

  changePassword () {
    if (localStorage.getItem('email')?.match(/support@.*/) && !this.newPasswordControl.value.match(/(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{12,30}/)) {
      console.error('Parola echipei de asistență nu respectă politica corporativă pentru conturile privilegiate! Vă rugăm să schimbați parola în consecință!')
    }
    this.userService.changePassword({
      current: this.passwordControl.value,
      new: this.newPasswordControl.value,
      repeat: this.repeatNewPasswordControl.value
    }).subscribe((response: any) => {
      this.error = undefined
      this.translate.get('PASSWORD_SUCCESSFULLY_CHANGED').subscribe((passwordSuccessfullyChanged) => {
        this.confirmation = passwordSuccessfullyChanged
      }, (translationId) => {
        this.confirmation = { error: translationId }
      })
      this.resetForm()
    }, (error) => {
      console.log(error)
      this.error = error
      this.confirmation = undefined
      this.resetPasswords()
    })
  }

  resetForm () {
    this.passwordControl.setValue('')
    this.resetPasswords()
  }

  resetPasswords () {
    this.passwordControl.markAsPristine()
    this.passwordControl.markAsUntouched()
    this.newPasswordControl.setValue('')
    this.newPasswordControl.markAsPristine()
    this.newPasswordControl.markAsUntouched()
    this.repeatNewPasswordControl.setValue('')
    this.repeatNewPasswordControl.markAsPristine()
    this.repeatNewPasswordControl.markAsUntouched()
  }
}

function matchValidator (newPasswordControl: AbstractControl) {
  return function matchOtherValidate (repeatNewPasswordControl: UntypedFormControl) {
    const password = newPasswordControl.value
    const passwordRepeat = repeatNewPasswordControl.value
    if (password !== passwordRepeat) {
      return { notSame: true }
    }
    return null
  }
}


/* ===== FILE: ./frontend/src/app/login/login.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { SearchResultComponent } from '../search-result/search-result.component'
import { WindowRefService } from '../Services/window-ref.service'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { UserService } from '../Services/user.service'
import { type ComponentFixture, fakeAsync, TestBed, tick, waitForAsync } from '@angular/core/testing'
import { LoginComponent } from './login.component'
import { RouterTestingModule } from '@angular/router/testing'
import { ReactiveFormsModule } from '@angular/forms'

import { BrowserAnimationsModule } from '@angular/platform-browser/animations'
import { MatIconModule } from '@angular/material/icon'
import { MatCheckboxModule } from '@angular/material/checkbox'
import { MatFormFieldModule } from '@angular/material/form-field'
import { MatCardModule } from '@angular/material/card'
import { MatInputModule } from '@angular/material/input'
import { CookieModule, CookieService } from 'ngy-cookie'
import { Location } from '@angular/common'
import { of, throwError } from 'rxjs'
import { MatTableModule } from '@angular/material/table'
import { MatPaginatorModule } from '@angular/material/paginator'
import { MatDialogModule } from '@angular/material/dialog'
import { MatDividerModule } from '@angular/material/divider'
import { TranslateModule } from '@ngx-translate/core'
import { MatGridListModule } from '@angular/material/grid-list'
import { MatTooltipModule } from '@angular/material/tooltip'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('LoginComponent', () => {
  let component: LoginComponent
  let fixture: ComponentFixture<LoginComponent>
  let userService: any
  let location: Location

  beforeEach(waitForAsync(() => {
    userService = jasmine.createSpyObj('UserService', ['login'])
    userService.login.and.returnValue(of({}))
    userService.isLoggedIn = jasmine.createSpyObj('userService.isLoggedIn', ['next'])
    userService.isLoggedIn.next.and.returnValue({})

    TestBed.configureTestingModule({
      imports: [RouterTestingModule.withRoutes([
        { path: 'search', component: SearchResultComponent }
      ]),
      ReactiveFormsModule,
      CookieModule.forRoot(),
      TranslateModule.forRoot(),
      BrowserAnimationsModule,
      MatCheckboxModule,
      MatFormFieldModule,
      MatCardModule,
      MatIconModule,
      MatInputModule,
      MatTableModule,
      MatPaginatorModule,
      MatDialogModule,
      MatDividerModule,
      MatGridListModule,
      MatTooltipModule,
      LoginComponent, SearchResultComponent],
      providers: [
        { provide: UserService, useValue: userService },
        WindowRefService,
        CookieService,
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()

    location = TestBed.inject(Location)
  }))

  beforeEach(() => {
    localStorage.removeItem('token')
    localStorage.removeItem('email')
    sessionStorage.removeItem('bid')
    fixture = TestBed.createComponent(LoginComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should have email as compulsory', () => {
    component.emailControl.setValue('')
    expect(component.emailControl.valid).toBeFalsy()
    component.emailControl.setValue('Value')
    expect(component.emailControl.valid).toBe(true)
  })

  it('should have password as compulsory', () => {
    component.passwordControl.setValue('')
    expect(component.passwordControl.valid).toBeFalsy()
    component.passwordControl.setValue('Value')
    expect(component.passwordControl.valid).toBe(true)
  })

  it('should have remember-me checked if email token is present as in localStorage', () => {
    localStorage.setItem('email', 'a@a')
    component.ngOnInit()
    expect(component.rememberMe.value).toBe(true)
  })

  it('should have remember-me unchecked if email token is not present in localStorage', () => {
    component.ngOnInit()
    expect(component.rememberMe.value).toBeFalsy()
  })

  it('should flag OAuth as disabled if server is running on unauthorized redirect URI', () => {
    expect(component.oauthUnavailable).toBe(true)
  })

  it('forwards to main page after successful login', fakeAsync(() => {
    userService.login.and.returnValue(of({}))
    component.login()
    tick()
    expect(location.path()).toBe('/search')
  }))

  it('stores the returned authentication token in localStorage', () => {
    userService.login.and.returnValue(of({ token: 'token' }))
    component.login()
    expect(localStorage.getItem('token')).toBe('token')
  })

  it('puts the returned basket id into browser session storage', () => {
    userService.login.and.returnValue(of({ bid: 4711 }))
    component.login()
    expect(sessionStorage.getItem('bid')).toBe('4711')
  })

  it('removes authentication token and basket id on failed login attempt', fakeAsync(() => {
    userService.login.and.returnValue(throwError({ error: 'Error' }))
    component.login()
    expect(localStorage.getItem('token')).toBeNull()
    expect(sessionStorage.getItem('bid')).toBeNull()
  }))

  it('returns error message from server to client on failed login attempt', fakeAsync(() => {
    userService.login.and.returnValue(throwError({ error: 'Error' }))
    component.login()
    expect(component.error).toBeTruthy()
  }))

  it('sets form to pristine on failed login attempt', fakeAsync(() => {
    userService.login.and.returnValue(throwError({ error: 'Error' }))
    component.login()
    expect(component.emailControl.pristine).toBe(true)
    expect(component.passwordControl.pristine).toBe(true)
  }))

  it('puts current email into "email" cookie on successful login with remember-me checkbox ticked', () => {
    userService.login.and.returnValue(of({}))
    component.emailControl.setValue('horst@juice-sh.op')
    component.rememberMe.setValue(true)
    component.login()
    expect(localStorage.getItem('email')).toBe('horst@juice-sh.op')
  })

  it('puts current email into "email" cookie on failed login with remember-me checkbox ticked', fakeAsync(() => {
    userService.login.and.returnValue(throwError({ error: 'Error' }))
    component.emailControl.setValue('horst@juice-sh.op')
    component.rememberMe.setValue(true)
    component.login()
    expect(localStorage.getItem('email')).toBe('horst@juice-sh.op')
  }))
})


/* ===== FILE: ./frontend/src/app/login/login.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { CookieService } from 'ngy-cookie'
import { WindowRefService } from '../Services/window-ref.service'
import { Router, RouterLink } from '@angular/router'
import { Component, NgZone, type OnInit } from '@angular/core'
import { UntypedFormControl, Validators, FormsModule, ReactiveFormsModule } from '@angular/forms'
import { library } from '@fortawesome/fontawesome-svg-core'
import { UserService } from '../Services/user.service'
import { faEye, faEyeSlash, faKey } from '@fortawesome/free-solid-svg-icons'
import { faGoogle } from '@fortawesome/free-brands-svg-icons'
import { FormSubmitService } from '../Services/form-submit.service'
import { ConfigurationService } from '../Services/configuration.service'
import { BasketService } from '../Services/basket.service'
import { MatCheckbox } from '@angular/material/checkbox'
import { MatIconModule } from '@angular/material/icon'
import { MatTooltip } from '@angular/material/tooltip'
import { MatIconButton, MatButtonModule } from '@angular/material/button'
import { MatInputModule } from '@angular/material/input'
import { TranslateModule } from '@ngx-translate/core'
import { MatFormFieldModule, MatLabel, MatError, MatSuffix } from '@angular/material/form-field'
import { NgIf } from '@angular/common'
import { MatCardModule } from '@angular/material/card'
import { FlexModule } from '@angular/flex-layout/flex'

library.add(faKey, faEye, faEyeSlash, faGoogle)

const oauthProviderUrl = 'https://accounts.google.com/o/oauth2/v2/auth'

@Component({
  selector: 'app-login',
  templateUrl: './login.component.html',
  styleUrls: ['./login.component.scss'],
  imports: [FlexModule, MatCardModule, NgIf, MatFormFieldModule, MatLabel, TranslateModule, MatInputModule, FormsModule, ReactiveFormsModule, MatError, MatIconButton, MatSuffix, MatTooltip, RouterLink, MatButtonModule, MatIconModule, MatCheckbox]
})

export class LoginComponent implements OnInit {
  public emailControl = new UntypedFormControl('', [Validators.required])

  public passwordControl = new UntypedFormControl('', [Validators.required, Validators.minLength(1)])

  public hide = true
  public user: any
  public rememberMe: UntypedFormControl = new UntypedFormControl(false)
  public error: any
  public clientId = '1005568560502-6hm16lef8oh46hr2d98vf2ohlnj4nfhq.apps.googleusercontent.com'
  public oauthUnavailable: boolean = true
  public redirectUri: string = ''
  public testingUsername = 'testing@juice-sh.op'
  public testingPassword = 'IamUsedForTesting'
  constructor (private readonly configurationService: ConfigurationService, private readonly userService: UserService, private readonly windowRefService: WindowRefService, private readonly cookieService: CookieService, private readonly router: Router, private readonly formSubmitService: FormSubmitService, private readonly basketService: BasketService, private readonly ngZone: NgZone) { }

  ngOnInit (): void {
    const email = localStorage.getItem('email')
    if (email) {
      this.user = {}
      this.user.email = email
      this.rememberMe.setValue(true)
    } else {
      this.rememberMe.setValue(false)
    }

    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
    this.redirectUri = `${this.windowRefService.nativeWindow.location.protocol}//${this.windowRefService.nativeWindow.location.host}`
    this.configurationService.getApplicationConfiguration().subscribe((config) => {
      if (config?.application?.googleOauth) {
        this.clientId = config.application.googleOauth.clientId
        const authorizedRedirect = config.application.googleOauth.authorizedRedirects.find(r => r.uri === this.redirectUri)
        if (authorizedRedirect) {
          this.oauthUnavailable = false
          this.redirectUri = authorizedRedirect.proxy ? authorizedRedirect.proxy : authorizedRedirect.uri
        } else {
          this.oauthUnavailable = true
          console.log(this.redirectUri + ' is not an authorized redirect URI for this application.')
        }
      }
    }, (err) => { console.log(err) })

    this.formSubmitService.attachEnterKeyHandler('login-form', 'loginButton', () => { this.login() })
  }

  login () {
    this.user = {}
    this.user.email = this.emailControl.value
    this.user.password = this.passwordControl.value
    this.userService.login(this.user).subscribe((authentication: any) => {
      localStorage.setItem('token', authentication.token)
      const expires = new Date()
      expires.setHours(expires.getHours() + 8)
      this.cookieService.put('token', authentication.token, { expires })
      sessionStorage.setItem('bid', authentication.bid)
      this.basketService.updateNumberOfCartItems()
      this.userService.isLoggedIn.next(true)
      this.ngZone.run(async () => await this.router.navigate(['/search']))
    }, ({ error }) => {
      if (error.status && error.data && error.status === 'totp_token_required') {
        localStorage.setItem('totp_tmp_token', error.data.tmpToken)
        this.ngZone.run(async () => await this.router.navigate(['/2fa/enter']))
        return
      }
      localStorage.removeItem('token')
      this.cookieService.remove('token')
      sessionStorage.removeItem('bid')
      this.error = error
      this.userService.isLoggedIn.next(false)
      this.emailControl.markAsPristine()
      this.passwordControl.markAsPristine()
    })

    if (this.rememberMe.value) {
      localStorage.setItem('email', this.user.email)
    } else {
      localStorage.removeItem('email')
    }
  }

  googleLogin () {
    this.windowRefService.nativeWindow.location.replace(`${oauthProviderUrl}?client_id=${this.clientId}&response_type=token&scope=email&redirect_uri=${this.redirectUri}`)
  }
}


/* ===== FILE: ./frontend/src/app/login/login.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<div fxLayoutAlign="center">
  <mat-card appearance="outlined" class="mat-elevation-z6">
    <div class="mdc-card">

      <h1>Login</h1>

      <div class="error" *ngIf="error">{{error}}</div>

      <div class="form-container" id="login-form">

        <mat-form-field color="accent" appearance="outline">
          <mat-label translate>LABEL_EMAIL</mat-label>
          <input id="email" #email name="email"
                [formControl]="emailControl"
                (focus)="this.error=null"
                matInput placeholder=""
                aria-label="Text field for the login email">
          <mat-error *ngIf="emailControl.invalid" translate>MANDATORY_EMAIL</mat-error>
        </mat-form-field>

        <mat-form-field color="accent" appearance="outline">
          <mat-label translate>LABEL_PASSWORD</mat-label>
          <input id="password" #password name="password"
                [formControl]="passwordControl"
                (focus)="this.error=null"
                matInput placeholder="" [type]="hide ? 'password' : 'text'"
                aria-label="Text field for the login password">
          <button *ngIf="hide" mat-icon-button matSuffix (click)="hide = !hide"
                  aria-label="Button to display the password" matTooltip="{{ 'SHOW_PWD_TOOLTIP' | translate  }}"
                  matTooltipPosition=right>
            <i class="fas fa-eye" aria-label="Eye"></i>
          </button>
          <button *ngIf="!hide" mat-icon-button matSuffix (click)="hide = !hide" aria-label="Button to hide the password" matTooltip="{{ 'HIDE_PWD_TOOLTIP' | translate  }}"
                  matTooltipPosition=right>
            <i class="fas fa-eye-slash" aria-label="Eye Slash"></i>
          </button>
          <mat-error *ngIf="passwordControl.invalid" translate>MANDATORY_PASSWORD</mat-error>
        </mat-form-field>

        <a class="primary-link forgot-pw" routerLink="/forgot-password" translate>FORGOT_PASSWORD</a>

        <button type="submit" id="loginButton" [disabled]="!emailControl.value||!passwordControl.value" mat-raised-button
                color="primary" (click)="login()" aria-label="Login">
          <mat-icon>
            exit_to_app
          </mat-icon>
          {{'BTN_LOGIN' | translate}}
        </button>

        <mat-checkbox [formControl]="rememberMe" id="rememberMe" aria-label="Checkbox to stay logged in or not logged in">
          {{'REMEMBER_ME' | translate}}
        </mat-checkbox>

        <div class="breakLine" *ngIf="!oauthUnavailable">
          <div class="line">
            <div></div>
          </div>
          <div class="textOnLine" translate>LABEL_OR</div>
          <div class="line">
            <div></div>
          </div>
        </div>

        <button id="loginButtonGoogle" *ngIf="!oauthUnavailable" mat-raised-button color="accent" (click)="googleLogin()"
                aria-label="Login with Google" class="google-button"><i
          class="fab fa-google fa-lg"></i> {{'BTN_GOOGLE_LOGIN' | translate}}
        </button>

        <div id="newCustomerLink">
          <a class="primary-link" routerLink="/register" translate>NO_CUSTOMER</a>
        </div>
      </div>
    </div>
  </mat-card>
</div>


/* ===== FILE: ./frontend/src/app/product-review-edit/product-review-edit.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Component, Inject, type OnInit } from '@angular/core'
import { MAT_DIALOG_DATA, MatDialogRef, MatDialogContent, MatDialogActions, MatDialogClose } from '@angular/material/dialog'
import { UntypedFormControl, Validators, FormsModule, ReactiveFormsModule } from '@angular/forms'
import { ProductReviewService } from '../Services/product-review.service'

import { library } from '@fortawesome/fontawesome-svg-core'
import { faArrowCircleLeft, faPaperPlane } from '@fortawesome/free-solid-svg-icons'
import { type Review } from '../Models/review.model'
import { SnackBarHelperService } from '../Services/snack-bar-helper.service'
import { MatButtonModule } from '@angular/material/button'
import { NgIf } from '@angular/common'
import { MatInputModule } from '@angular/material/input'
import { MatFormFieldModule, MatLabel, MatHint, MatError } from '@angular/material/form-field'
import { TranslateModule } from '@ngx-translate/core'
import { FlexModule } from '@angular/flex-layout/flex'
import { MatIconModule } from '@angular/material/icon'

library.add(faPaperPlane, faArrowCircleLeft)

@Component({
  selector: 'app-product-review-edit',
  templateUrl: './product-review-edit.component.html',
  styleUrls: ['./product-review-edit.component.scss'],
  imports: [MatDialogContent, FlexModule, TranslateModule, MatFormFieldModule, MatLabel, MatInputModule, FormsModule, ReactiveFormsModule, MatHint, NgIf, MatError, MatDialogActions, MatButtonModule, MatDialogClose, MatIconModule]
})
export class ProductReviewEditComponent implements OnInit {
  public editReviewControl: UntypedFormControl = new UntypedFormControl('', [Validators.required, Validators.minLength(1), Validators.maxLength(160)])
  public error: string | null = null

  constructor (@Inject(MAT_DIALOG_DATA) public data: { reviewData: Review }, private readonly productReviewService: ProductReviewService, private readonly dialogRef: MatDialogRef<ProductReviewEditComponent>,
    private readonly snackBarHelperService: SnackBarHelperService) { }

  ngOnInit (): void {
    this.editReviewControl.setValue(this.data.reviewData.message)
  }

  editReview () {
    this.productReviewService.patch({ id: this.data.reviewData._id, message: this.editReviewControl.value }).subscribe(() => {
      this.dialogRef.close()
    }, (err) => {
      console.log(err)
      this.error = err
    })
    this.snackBarHelperService.open('CONFIRM_CHANGES_SAVED')
  }
}


/* ===== FILE: ./frontend/src/app/product-review-edit/product-review-edit.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<mat-dialog-content>
  <div class="container" fxLayout="column">
    <h1 translate>LABEL_EDIT_REVIEW</h1>
    <div>
      <mat-form-field appearance="outline" color="accent" hintLabel="Max 160 characters" floatLabel="always">
        <mat-label translate>LABEL_REVIEW</mat-label>
          <textarea [formControl]="editReviewControl" #textPut matInput
                    placeholder="{{'WRITE_REVIEW_PLACEHOLDER' | translate}}"
                    matTextareaAutosize matAutosizeMinRows="2" maxlength="160"
                    matAutosizeMaxRows="4" aria-label="Text field to edit a product review"  (focus)="this.error=null"></textarea>
        <mat-hint align="end">{{textPut.value?.length || 0}}/160</mat-hint>
        <mat-error *ngIf="editReviewControl.invalid" translate>MANDATORY_REVIEW</mat-error>
      </mat-form-field>
    </div>
  </div>
</mat-dialog-content>

<mat-dialog-actions align="end">
  <button mat-stroked-button mat-dialog-close class="close-dialog" aria-label="Close Dialog">
    <mat-icon>close</mat-icon>
    <span>{{'BTN_CLOSE' | translate}}</span>
  </button>
  <button type="submit" (click)="editReview()" mat-raised-button style="margin-left: 5px;" color="primary" aria-label="Send the review"
          [disabled]="editReviewControl.invalid">
    <mat-icon>send</mat-icon>
    <span>{{'BTN_SUBMIT' | translate}}</span>
  </button>
</mat-dialog-actions>


/* ===== FILE: ./frontend/src/app/product-review-edit/product-review-edit.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type ComponentFixture, fakeAsync, flush, TestBed, waitForAsync } from '@angular/core/testing'
import { TranslateModule } from '@ngx-translate/core'
import { ProductReviewEditComponent } from './product-review-edit.component'
import { ReactiveFormsModule } from '@angular/forms'
import { MAT_DIALOG_DATA, MatDialogModule, MatDialogRef } from '@angular/material/dialog'
import { MatFormFieldModule } from '@angular/material/form-field'
import { MatButtonModule } from '@angular/material/button'
import { of, throwError } from 'rxjs'
import { ProductReviewService } from 'src/app/Services/product-review.service'
import { MatInputModule } from '@angular/material/input'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'
import { MatSnackBarModule } from '@angular/material/snack-bar'

describe('ProductReviewEditComponent', () => {
  let component: ProductReviewEditComponent
  let fixture: ComponentFixture<ProductReviewEditComponent>
  let productReviewService: any
  let dialogRef: any

  beforeEach(waitForAsync(() => {
    productReviewService = jasmine.createSpyObj('ProductReviewService', ['patch'])
    productReviewService.patch.and.returnValue(of({}))
    dialogRef = jasmine.createSpyObj('MatDialogRef', ['close'])
    dialogRef.close.and.returnValue({})

    TestBed.configureTestingModule({
      imports: [
        TranslateModule.forRoot(),
        ReactiveFormsModule,
        BrowserAnimationsModule,
        MatDialogModule,
        MatFormFieldModule,
        MatInputModule,
        MatButtonModule,
        MatSnackBarModule,
        ProductReviewEditComponent
      ],
      providers: [
        { provide: ProductReviewService, useValue: productReviewService },
        { provide: MAT_DIALOG_DATA, useValue: { productData: {} } },
        { provide: MatDialogRef, useValue: dialogRef }
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(ProductReviewEditComponent)
    component = fixture.componentInstance
    component.data = { reviewData: { _id: '42', message: 'Review', author: 'Horst' } }
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should be initialized with data from the passed review', () => {
    component.data = { reviewData: { _id: '42', message: 'Review', author: 'Horst' } }
    component.ngOnInit()
    expect(component.editReviewControl.value).toBe('Review')
  })

  it('should update review through backend API', () => {
    component.data = { reviewData: { _id: '42', message: 'Review', author: 'Horst' } }
    component.ngOnInit()
    component.editReviewControl.setValue('Another Review')
    component.editReview()
    expect(productReviewService.patch.calls.count()).toBe(1)
    expect(productReviewService.patch.calls.argsFor(0)[0]).toEqual({ id: '42', message: 'Another Review' })
  })

  it('should close the dialog on submitting the edited review', () => {
    productReviewService.patch.and.returnValue(of({}))
    component.data = { reviewData: { _id: '42', message: 'Review', author: 'Horst' } }
    component.ngOnInit()
    component.editReview()
    expect(dialogRef.close).toHaveBeenCalled()
  })

  it('should log errors directly to browser console', fakeAsync(() => {
    component.data = { reviewData: { _id: '42', message: 'Review', author: 'Horst' } }
    console.log = jasmine.createSpy('log')
    productReviewService.patch.and.returnValue(throwError('Error'))
    component.ngOnInit()
    component.editReview()
    expect(console.log).toHaveBeenCalledWith('Error')
    fixture.destroy()
    flush()
  }))
})


/* ===== FILE: ./frontend/src/app/Services/delivery.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing'
import { fakeAsync, inject, TestBed, tick } from '@angular/core/testing'
import { DeliveryService } from './delivery.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('DeliveryService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [],
      providers: [DeliveryService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
  })

  it('should be created', inject([DeliveryService], (service: DeliveryService) => {
    expect(service).toBeTruthy()
  }))

  it('should get address directly from the api', inject([DeliveryService, HttpTestingController],
    fakeAsync((service: DeliveryService, httpMock: HttpTestingController) => {
      let res
      service.get().subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/api/Deliverys')
      req.flush({ data: 'apiResponse' })
      tick()
      expect(req.request.method).toBe('GET')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should get single address directly from the api', inject([DeliveryService, HttpTestingController],
    fakeAsync((service: DeliveryService, httpMock: HttpTestingController) => {
      let res
      service.getById(1).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/api/Deliverys/1')
      req.flush({ data: 'apiResponse' })
      tick()
      expect(req.request.method).toBe('GET')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))
})


/* ===== FILE: ./frontend/src/app/Services/code-fixes.service.ts ===== */

import { Injectable } from '@angular/core'
import { environment } from '../../environments/environment'
import { HttpClient } from '@angular/common/http'
import { catchError, map } from 'rxjs/operators'
import { type Observable } from 'rxjs'

export interface result {
  verdict: boolean
}

export interface Fixes {
  fixes: string[]
}

export interface Solved {
  challenges: string[]
}

@Injectable({
  providedIn: 'root'
})
export class CodeFixesService {
  private readonly hostServer = environment.hostServer
  private readonly host = this.hostServer + '/snippets/fixes'

  constructor (private readonly http: HttpClient) { }

  get (key: string): Observable<Fixes> {
    return this.http.get(this.host + `/${key}`).pipe(map((response: Fixes) => response), catchError((error: any) => { throw error }))
  }

  check (key: string, selectedFix: number): any {
    return this.http.post(this.host, {
      key,
      selectedFix
    }).pipe(map((response: result) => response), catchError((error: any) => { throw error }))
  }
}


/* ===== FILE: ./frontend/src/app/Services/administration.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { environment } from '../../environments/environment'
import { HttpClient } from '@angular/common/http'
import { Injectable } from '@angular/core'
import { catchError, map } from 'rxjs/operators'

@Injectable({
  providedIn: 'root'
})
export class AdministrationService {
  private readonly hostServer = environment.hostServer
  private readonly host = this.hostServer + '/rest/admin'

  constructor (private readonly http: HttpClient) { }

  getApplicationVersion () {
    return this.http.get(this.host + '/application-version').pipe(
      map((response: any) => response.version),
      catchError((error: Error) => { throw error })
    )
  }
}


/* ===== FILE: ./frontend/src/app/Services/two-factor-auth-service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Injectable } from '@angular/core'
import { HttpClient } from '@angular/common/http'
import { catchError, map } from 'rxjs/operators'
import { environment } from '../../environments/environment'
import { type Observable } from 'rxjs'

interface TwoFactorVerifyResponse {
  authentication: AuthenticationPayload
}

interface AuthenticationPayload {
  token: string
  bid: number
  umail: string
}

interface TwoFactorAuthStatusPayload {
  setup: boolean
  secret?: string
  setupToken?: string
  email?: string
}

@Injectable({
  providedIn: 'root'
})
export class TwoFactorAuthService {
  constructor (private readonly http: HttpClient) {}

  verify (totpToken: string): Observable<AuthenticationPayload> {
    return this.http.post<TwoFactorVerifyResponse>(`${environment.hostServer}/rest/2fa/verify`, {
      tmpToken: localStorage.getItem('totp_tmp_token'),
      totpToken
    }).pipe(map((response: TwoFactorVerifyResponse) => response.authentication), catchError((error) => { throw error }))
  }

  status (): Observable<TwoFactorAuthStatusPayload> {
    return this.http.get<TwoFactorAuthStatusPayload>(`${environment.hostServer}/rest/2fa/status`)
      .pipe(map((response: TwoFactorAuthStatusPayload) => response), catchError((error) => { throw error }))
  }

  setup (password: string, initialToken: string, setupToken?: string): Observable<void> {
    return this.http.post(`${environment.hostServer}/rest/2fa/setup`, {
      password,
      setupToken,
      initialToken
    }).pipe(map(() => undefined), catchError((error) => { throw error }))
  }

  disable (password: string): Observable<void> {
    return this.http.post(`${environment.hostServer}/rest/2fa/disable`, { password })
      .pipe(map(() => undefined), catchError((error) => { throw error }))
  }
}


/* ===== FILE: ./frontend/src/app/Services/country-mapping.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing'
import { fakeAsync, inject, TestBed, tick } from '@angular/core/testing'

import { CountryMappingService } from './country-mapping.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('CountryMappingService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [],
      providers: [CountryMappingService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
  })

  it('should be created', inject([CountryMappingService], (service: CountryMappingService) => {
    expect(service).toBeTruthy()
  }))

  it('should get the country mapping directly through the rest API', inject([CountryMappingService, HttpTestingController],
    fakeAsync((service: CountryMappingService, httpMock: HttpTestingController) => {
      let res: any
      service.getCountryMapping().subscribe((data) => (res = data))

      const req = httpMock.expectOne('http://localhost:3000/rest/country-mapping')
      req.flush('apiResponse')

      tick()

      expect(req.request.method).toBe('GET')
      expect(res).toBe('apiResponse')

      httpMock.verify()
    })
  ))
})


/* ===== FILE: ./frontend/src/app/Services/request.interceptor.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type HttpEvent, type HttpHandler, type HttpInterceptor, type HttpRequest } from '@angular/common/http'
import { Injectable } from '@angular/core'
import { type Observable } from 'rxjs'

@Injectable()
export class RequestInterceptor implements HttpInterceptor {
  intercept (req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    if (localStorage.getItem('token')) {
      req = req.clone({
        setHeaders: {
          Authorization: `Bearer ${localStorage.getItem('token')}`
        }
      })
    }
    if (localStorage.getItem('email')) {
      req = req.clone({
        setHeaders: {
          'X-User-Email': String(localStorage.getItem('email'))
        }
      })
    }
    return next.handle(req)
  }
}


/* ===== FILE: ./frontend/src/app/Services/languages.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing'
import { fakeAsync, inject, TestBed, tick } from '@angular/core/testing'

import { LanguagesService } from './languages.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('LanguagesService', () => {
  beforeEach(() => TestBed.configureTestingModule({
    imports: [],
    providers: [LanguagesService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
  }))

  it('should be created', () => {
    const service: LanguagesService = TestBed.inject(LanguagesService)
    expect(service).toBeTruthy()
  })

  it('should get the language list through the rest API', inject([LanguagesService, HttpTestingController],
    fakeAsync((service: LanguagesService, httpMock: HttpTestingController) => {
      let res: any
      service.getLanguages().subscribe((data) => (res = data))

      const req = httpMock.expectOne('http://localhost:3000/rest/languages')
      req.flush('apiResponse')

      tick()

      expect(req.request.method).toBe('GET')
      expect(res).toBe('apiResponse')

      httpMock.verify()
    })
  ))
})


/* ===== FILE: ./frontend/src/app/Services/challenge.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { environment } from '../../environments/environment'
import { HttpClient } from '@angular/common/http'
import { Injectable } from '@angular/core'
import { type Observable } from 'rxjs'
import { catchError, map } from 'rxjs/operators'
import { type Challenge } from '../Models/challenge.model'

@Injectable({
  providedIn: 'root'
})
export class ChallengeService {
  private readonly hostServer = environment.hostServer
  private readonly host = this.hostServer + '/api/Challenges'
  constructor (private readonly http: HttpClient) { }

  find (params?: any): Observable<Challenge[]> {
    return this.http.get(this.host + '/', { params }).pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }

  repeatNotification (challengeName: string) {
    return this.http.get(this.hostServer + '/rest/repeat-notification', { params: { challenge: challengeName }, responseType: 'text' as const }).pipe(catchError((err) => { throw err }))
  }

  continueCode () {
    return this.http.get(this.hostServer + '/rest/continue-code').pipe(map((response: any) => response.continueCode), catchError((err) => { throw err }))
  }

  continueCodeFindIt () {
    return this.http.get(this.hostServer + '/rest/continue-code-findIt').pipe(map((response: any) => response.continueCode), catchError((err) => { throw err }))
  }

  continueCodeFixIt () {
    return this.http.get(this.hostServer + '/rest/continue-code-fixIt').pipe(map((response: any) => response.continueCode), catchError((err) => { throw err }))
  }

  restoreProgress (continueCode: string) {
    return this.http.put(this.hostServer + '/rest/continue-code/apply/' + continueCode, {}).pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }

  restoreProgressFindIt (continueCode: string) {
    return this.http.put(this.hostServer + '/rest/continue-code-findIt/apply/' + continueCode, {}).pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }

  restoreProgressFixIt (continueCode: string) {
    return this.http.put(this.hostServer + '/rest/continue-code-fixIt/apply/' + continueCode, {}).pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }
}


/* ===== FILE: ./frontend/src/app/Services/order-history.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { environment } from '../../environments/environment'
import { Injectable } from '@angular/core'
import { HttpClient } from '@angular/common/http'
import { catchError, map } from 'rxjs/operators'

@Injectable({
  providedIn: 'root'
})
export class OrderHistoryService {
  private readonly hostServer = environment.hostServer
  private readonly host = this.hostServer + '/rest/order-history'

  constructor (private readonly http: HttpClient) { }

  get () {
    return this.http.get(this.host).pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }

  getAll () {
    return this.http.get(this.host + '/orders').pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }

  toggleDeliveryStatus (id: number, params) {
    return this.http.put(`${this.host}/${id}/delivery-status`, params).pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }
}


/* ===== FILE: ./frontend/src/app/Services/window-ref.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Injectable } from '@angular/core'

@Injectable({
  providedIn: 'root'
})
export class WindowRefService {
  get nativeWindow (): any {
    return getWindow()
  }
}

function getWindow (): any {
  return window
}


/* ===== FILE: ./frontend/src/app/Services/chatbot.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing'
import { fakeAsync, inject, TestBed, tick } from '@angular/core/testing'

import { ChatbotService } from './chatbot.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('ChatbotService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [],
      providers: [ChatbotService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
  })

  it('should be created', inject([ChatbotService], (service: ChatbotService) => {
    expect(service).toBeTruthy()
  }))

  it('should get status from the REST API', inject([ChatbotService, HttpTestingController],
    fakeAsync((service: ChatbotService, httpMock: HttpTestingController) => {
      let res: any
      service.getChatbotStatus().subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/rest/chatbot/status')
      req.flush({ status: true, body: 'apiResponse' })

      tick()
      expect(req.request.method).toBe('GET')
      expect(req.request.body).toBeNull()
      expect(res.status).toBeTrue()
      expect(res.body).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should get query response from the REST API', inject([ChatbotService, HttpTestingController],
    fakeAsync((service: ChatbotService, httpMock: HttpTestingController) => {
      let res: any
      service.getResponse('query', 'apiQuery').subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/rest/chatbot/respond')
      req.flush({ action: 'response', body: 'apiResponse' })

      tick()
      expect(req.request.method).toBe('POST')
      expect(req.request.body.query).toBe('apiQuery')
      expect(res.action).toBe('response')
      expect(res.body).toBe('apiResponse')
      httpMock.verify()
    })
  ))
})


/* ===== FILE: ./frontend/src/app/Services/form-submit.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Inject, Injectable } from '@angular/core'
import { DOCUMENT } from '@angular/common'

@Injectable({
  providedIn: 'root'
})
export class FormSubmitService {
  constructor (@Inject(DOCUMENT) private readonly _document: HTMLDocument) { }

  attachEnterKeyHandler (formId: string, submitButtonId: string, onSubmit: any) {
    const form = this._document.getElementById(formId) as HTMLFormElement
    const submitButton = this._document.getElementById(submitButtonId) as HTMLInputElement

    form.addEventListener('keyup', function (event) {
      event.preventDefault()
      // eslint-disable-next-line import/no-deprecated
      if (event.keyCode === 13 && !submitButton.disabled) {
        onSubmit()
      }
    })
  }
}


/* ===== FILE: ./frontend/src/app/Services/quantity.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { environment } from '../../environments/environment'
import { Injectable } from '@angular/core'
import { HttpClient } from '@angular/common/http'
import { catchError, map } from 'rxjs/operators'

@Injectable({
  providedIn: 'root'
})
export class QuantityService {
  private readonly hostServer = environment.hostServer
  private readonly host = this.hostServer + '/api/Quantitys'

  constructor (private readonly http: HttpClient) { }

  getAll () {
    return this.http.get(this.host + '/').pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }

  put (id: number, params) {
    return this.http.put(`${this.host}/${id}`, params).pipe(map((response: any) => response.data), catchError((error) => { throw error }))
  }
}


/* ===== FILE: ./frontend/src/app/Services/socket-io.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { inject, TestBed } from '@angular/core/testing'

import { SocketIoService } from './socket-io.service'

describe('SocketIoService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      providers: [SocketIoService]
    })
  })

  it('should be created', inject([SocketIoService], (service: SocketIoService) => {
    expect(service).toBeTruthy()
  }))
})


/* ===== FILE: ./frontend/src/app/Services/address.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing'
import { fakeAsync, inject, TestBed, tick } from '@angular/core/testing'
import { AddressService } from './address.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('AddressService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [],
      providers: [AddressService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
  })

  it('should be created', inject([AddressService], (service: AddressService) => {
    expect(service).toBeTruthy()
  }))

  it('should get address directly from the api', inject([AddressService, HttpTestingController],
    fakeAsync((service: AddressService, httpMock: HttpTestingController) => {
      let res
      service.get().subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/api/Addresss')
      req.flush({ data: 'apiResponse' })
      tick()
      expect(req.request.method).toBe('GET')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should get single address directly from the api', inject([AddressService, HttpTestingController],
    fakeAsync((service: AddressService, httpMock: HttpTestingController) => {
      let res
      service.getById(1).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/api/Addresss/1')
      req.flush({ data: 'apiResponse' })
      tick()
      expect(req.request.method).toBe('GET')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should create address directly from the api', inject([AddressService, HttpTestingController],
    fakeAsync((service: AddressService, httpMock: HttpTestingController) => {
      let res
      service.save({}).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/api/Addresss/')
      req.flush({ data: 'apiResponse' })
      tick()
      expect(req.request.method).toBe('POST')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should update address directly from the api', inject([AddressService, HttpTestingController],
    fakeAsync((service: AddressService, httpMock: HttpTestingController) => {
      let res
      service.put(1, {}).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/api/Addresss/1')
      req.flush({ data: 'apiResponse' })
      tick()
      expect(req.request.method).toBe('PUT')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should delete address directly from the api', inject([AddressService, HttpTestingController],
    fakeAsync((service: AddressService, httpMock: HttpTestingController) => {
      let res
      service.del(1).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/api/Addresss/1')
      req.flush({ data: 'apiResponse' })
      tick()
      expect(req.request.method).toBe('DELETE')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))
})


/* ===== FILE: ./frontend/src/app/Services/track-order.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing'
import { fakeAsync, inject, TestBed, tick } from '@angular/core/testing'

import { TrackOrderService } from './track-order.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('TrackOrderService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [],
      providers: [TrackOrderService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
  })

  it('should be created', inject([TrackOrderService], (service: TrackOrderService) => {
    expect(service).toBeTruthy()
  }))

  it('should get tracking order results directly via the rest api', inject([TrackOrderService, HttpTestingController],
    fakeAsync((service: TrackOrderService, httpMock: HttpTestingController) => {
      let res: any
      service.find('5267-f9cd5882f54c75a3').subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/rest/track-order/5267-f9cd5882f54c75a3')
      req.flush('apiResponse')

      tick()
      expect(req.request.method).toBe('GET')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))
})


/* ===== FILE: ./frontend/src/app/Services/captcha.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing'
import { fakeAsync, inject, TestBed, tick } from '@angular/core/testing'

import { CaptchaService } from './captcha.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('CaptchaService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [],
      providers: [CaptchaService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
  })

  it('should be created', inject([CaptchaService], (service: CaptchaService) => {
    expect(service).toBeTruthy()
  }))

  it('should get captcha directly from the rest api', inject([CaptchaService, HttpTestingController],
    fakeAsync((service: CaptchaService, httpMock: HttpTestingController) => {
      let res: any
      service.getCaptcha().subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/rest/captcha/')
      req.flush('apiResponse')

      tick()
      expect(req.request.method).toBe('GET')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))
})


/* ===== FILE: ./frontend/src/app/Services/vuln-lines.service.ts ===== */

import { Injectable } from '@angular/core'
import { environment } from '../../environments/environment'
import { HttpClient } from '@angular/common/http'
import { catchError, map } from 'rxjs/operators'

export interface result {
  verdict: boolean
  hint: string
}

@Injectable({
  providedIn: 'root'
})
export class VulnLinesService {
  private readonly hostServer = environment.hostServer
  private readonly host = this.hostServer + '/snippets/verdict'

  constructor (private readonly http: HttpClient) { }

  check (key: string, selectedLines: number[]): any {
    return this.http.post(this.host, {
      key,
      selectedLines
    }).pipe(map((response: result) => response), catchError((error: any) => { throw error }))
  }
}


/* ===== FILE: ./frontend/src/app/Services/wallet.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { environment } from '../../environments/environment'
import { Injectable } from '@angular/core'
import { HttpClient } from '@angular/common/http'
import { catchError, map } from 'rxjs/operators'

@Injectable({
  providedIn: 'root'
})
export class WalletService {
  private readonly hostServer = environment.hostServer
  private readonly host = this.hostServer + '/rest/wallet/balance'

  constructor (private readonly http: HttpClient) { }

  get () {
    return this.http.get(this.host).pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }

  put (params) {
    return this.http.put(this.host, params).pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }
}


/* ===== FILE: ./frontend/src/app/Services/product-review.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { environment } from '../../environments/environment'
import { Injectable } from '@angular/core'
import { HttpClient } from '@angular/common/http'
import { catchError, map } from 'rxjs/operators'

@Injectable({
  providedIn: 'root'
})
export class ProductReviewService {
  private readonly hostServer = environment.hostServer
  private readonly host = this.hostServer + '/rest/products'

  constructor (private readonly http: HttpClient) { }

  get (id: number) {
    return this.http.get(`${this.host}/${id}/reviews`).pipe(
      map((response: any) => response.data), catchError((err: Error) => {
        throw err
      })
    )
  }

  create (id: number, review: { message: string, author: string }) {
    return this.http.put(`${this.host}/${id}/reviews`, review).pipe(map((response: any) => response.data),
      catchError((err) => { throw err })
    )
  }

  patch (review: { id: string, message: string }) {
    return this.http.patch(this.host + '/reviews', review).pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }

  like (_id?: string) {
    return this.http.post(this.host + '/reviews', { id: _id }).pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }
}


/* ===== FILE: ./frontend/src/app/Services/product-review.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing'
import { fakeAsync, inject, TestBed, tick } from '@angular/core/testing'

import { ProductReviewService } from './product-review.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('ProductReviewService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [],
      providers: [ProductReviewService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
  })

  it('should be created', inject([ProductReviewService], (service: ProductReviewService) => {
    expect(service).toBeTruthy()
  }))

  it('should get product reviews directly via the rest api', inject([ProductReviewService, HttpTestingController],
    fakeAsync((service: ProductReviewService, httpMock: HttpTestingController) => {
      let res: any
      service.get(42).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/rest/products/42/reviews')
      req.flush({ data: 'apiResponse' })

      tick()
      expect(req.request.method).toBe('GET')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should create product reviews directly via the rest api', inject([ProductReviewService, HttpTestingController],
    fakeAsync((service: ProductReviewService, httpMock: HttpTestingController) => {
      let res: any
      service.create(42, { message: 'A', author: 'B' }).subscribe((data: any) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/rest/products/42/reviews')
      req.flush({ data: 'apiResponse' })

      tick()
      expect(req.request.method).toBe('PUT')
      expect(req.request.body).toEqual({ message: 'A', author: 'B' })
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should edit product reviews directly via the rest api', inject([ProductReviewService, HttpTestingController],
    fakeAsync((service: ProductReviewService, httpMock: HttpTestingController) => {
      let res: any
      service.patch(null as unknown as { id: string, message: string }).subscribe((data: any) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/rest/products/reviews')
      req.flush({ data: 'apiResponse' })

      tick()
      expect(req.request.method).toBe('PATCH')
      expect(req.request.body).toBe(null)
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))
})


/* ===== FILE: ./frontend/src/app/Services/quantity.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing'
import { fakeAsync, inject, TestBed, tick } from '@angular/core/testing'

import { QuantityService } from './quantity.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('QuantityService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [],
      providers: [QuantityService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
  })

  it('should be created', inject([QuantityService], (service: QuantityService) => {
    expect(service).toBeTruthy()
  }))

  it('should get all quantities directly from the rest api', inject([QuantityService, HttpTestingController],
    fakeAsync((service: QuantityService, httpMock: HttpTestingController) => {
      let res
      service.getAll().subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/api/Quantitys/')
      req.flush({ data: 'apiResponse' })

      tick()
      expect(req.request.method).toBe('GET')
      expect(req.request.params.toString()).toBeFalsy()
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should change quantity directly via the rest api', inject([QuantityService, HttpTestingController],
    fakeAsync((service: QuantityService, httpMock: HttpTestingController) => {
      let res
      service.put(42, {}).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/api/Quantitys/42')
      req.flush({ data: 'apiResponse' })

      tick()
      expect(req.request.method).toBe('PUT')
      expect(req.request.body).toEqual({})
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))
})


/* ===== FILE: ./frontend/src/app/Services/basket.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { environment } from '../../environments/environment'
import { Injectable } from '@angular/core'
import { HttpClient } from '@angular/common/http'
import { catchError, map } from 'rxjs/operators'
import { type Observable, Subject } from 'rxjs'

interface OrderDetail {
  paymentId: string
  addressId: string
  deliveryMethodId: string
}

@Injectable({
  providedIn: 'root'
})
export class BasketService {
  public hostServer = environment.hostServer
  public itemTotal = new Subject<any>()
  private readonly host = this.hostServer + '/api/BasketItems'

  constructor (private readonly http: HttpClient) { }

  find (id?: number) {
    return this.http.get(`${this.hostServer}/rest/basket/${id}`).pipe(map((response: any) => response.data), catchError((error) => { throw error }))
  }

  get (id: number) {
    return this.http.get(`${this.host}/${id}`).pipe(map((response: any) => response.data), catchError((error) => { throw error }))
  }

  put (id: number, params: any) {
    return this.http.put(`${this.host}/${id}`, params).pipe(map((response: any) => response.data), catchError((error) => { throw error }))
  }

  del (id: number) {
    return this.http.delete(`${this.host}/${id}`).pipe(map((response: any) => response.data), catchError((error) => { throw error }))
  }

  save (params?: any) {
    return this.http.post(this.host + '/', params).pipe(map((response: any) => response.data), catchError((error) => { throw error }))
  }

  checkout (id?: number, couponData?: string, orderDetails?: OrderDetail) {
    return this.http.post(`${this.hostServer}/rest/basket/${id}/checkout`, { couponData, orderDetails }).pipe(map((response: any) => response.orderConfirmation), catchError((error) => { throw error }))
  }

  applyCoupon (id?: number, coupon?: string) {
    return this.http.put(`${this.hostServer}/rest/basket/${id}/coupon/${coupon}`, {}).pipe(map((response: any) => response.discount), catchError((error) => { throw error }))
  }

  updateNumberOfCartItems () {
    this.find(parseInt(sessionStorage.getItem('bid'), 10)).subscribe((basket) => {
      // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
      this.itemTotal.next(basket.Products.reduce((itemTotal, product) => itemTotal + product.BasketItem.quantity, 0))
    }, (err) => { console.log(err) })
  }

  getItemTotal (): Observable<any> {
    return this.itemTotal.asObservable()
  }
}


/* ===== FILE: ./frontend/src/app/Services/languages.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Injectable } from '@angular/core'
import { environment } from '../../environments/environment'
import { HttpClient } from '@angular/common/http'
import { catchError } from 'rxjs/operators'

@Injectable({
  providedIn: 'root'
})
export class LanguagesService {
  private readonly hostServer = environment.hostServer
  constructor (private readonly http: HttpClient) { }

  getLanguages () {
    return this.http.get(`${this.hostServer}/rest/languages`).pipe(catchError((err) => { throw err }))
  }
}


/* ===== FILE: ./frontend/src/app/Services/data-subject.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { environment } from '../../environments/environment'
import { HttpClient } from '@angular/common/http'
import { Injectable } from '@angular/core'
import { catchError } from 'rxjs/operators'

@Injectable({
  providedIn: 'root'
})

export class DataSubjectService {
  private readonly hostServer = environment.hostServer
  private readonly host = this.hostServer + '/rest/user'

  constructor (private readonly http: HttpClient) { }

  erase (params: any) {
    return this.http.post(this.host + '/erasure-request', params).pipe(catchError((error: Error) => { throw error })
    )
  }

  dataExport (params: any) {
    return this.http.post(this.host + '/data-export', params).pipe(catchError((err) => { throw err }))
  }
}


/* ===== FILE: ./frontend/src/app/Services/chatbot.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { environment } from '../../environments/environment'
import { HttpClient } from '@angular/common/http'
import { Injectable } from '@angular/core'
import { catchError, map } from 'rxjs/operators'

@Injectable({
  providedIn: 'root'
})
export class ChatbotService {
  private readonly hostServer = environment.hostServer
  private readonly host = this.hostServer + '/rest/chatbot'

  constructor (private readonly http: HttpClient) { }

  getChatbotStatus () {
    return this.http.get(this.host + '/status').pipe(map((response: any) => response), catchError((error: Error) => { throw error }))
  }

  getResponse (action, query) {
    return this.http.post(this.host + '/respond', { action, query }).pipe(map((response: any) => response), catchError((error: Error) => { throw error }))
  }
}


/* ===== FILE: ./frontend/src/app/Services/payment.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { environment } from '../../environments/environment'
import { Injectable } from '@angular/core'
import { HttpClient } from '@angular/common/http'
import { catchError, map } from 'rxjs/operators'

@Injectable({
  providedIn: 'root'
})
export class PaymentService {
  private readonly hostServer = environment.hostServer
  private readonly host = this.hostServer + '/api/Cards'

  constructor (private readonly http: HttpClient) { }

  get () {
    return this.http.get(this.host).pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }

  getById (id) {
    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
    return this.http.get(`${this.host}/${id}`).pipe(map((response: any) => response.data), catchError((err: Error) => { throw err }))
  }

  save (params) {
    return this.http.post(this.host + '/', params).pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }

  del (id: number) {
    return this.http.delete(`${this.host}/${id}`).pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }
}


/* ===== FILE: ./frontend/src/app/Services/track-order.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Injectable } from '@angular/core'
import { HttpClient } from '@angular/common/http'
import { environment } from '../../environments/environment'
import { catchError, map } from 'rxjs/operators'

@Injectable({
  providedIn: 'root'
})
export class TrackOrderService {
  private readonly hostServer = environment.hostServer
  private readonly host = this.hostServer + '/rest/track-order'

  constructor (private readonly http: HttpClient) { }

  find (params: string) {
    params = encodeURIComponent(params)
    return this.http.get(`${this.host}/${params}`).pipe(map((response: any) => response), catchError((error) => { throw error }))
  }
}


/* ===== FILE: ./frontend/src/app/Services/local-backup.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Injectable } from '@angular/core'
import { type Backup } from '../Models/backup.model'
import { CookieService } from 'ngy-cookie'
import { saveAs } from 'file-saver'
import { SnackBarHelperService } from './snack-bar-helper.service'
import { MatSnackBar } from '@angular/material/snack-bar'
import { forkJoin, from, of } from 'rxjs'
import { ChallengeService } from './challenge.service'

@Injectable({
  providedIn: 'root'
})
export class LocalBackupService {
  private readonly VERSION = 1

  constructor (private readonly cookieService: CookieService, private readonly challengeService: ChallengeService, private readonly snackBarHelperService: SnackBarHelperService, private readonly snackBar: MatSnackBar) { }

  save (fileName: string = 'owasp_juice_shop') {
    const backup: Backup = { version: this.VERSION }

    backup.banners = {
      welcomeBannerStatus: this.cookieService.get('welcomebanner_status') ? this.cookieService.get('welcomebanner_status') : undefined,
      cookieConsentStatus: this.cookieService.get('cookieconsent_status') ? this.cookieService.get('cookieconsent_status') : undefined
    }
    backup.language = this.cookieService.get('language') ? this.cookieService.get('language') : undefined

    const continueCode = this.challengeService.continueCode()
    const continueCodeFindIt = this.challengeService.continueCodeFindIt()
    const continueCodeFixIt = this.challengeService.continueCodeFixIt()
    forkJoin([continueCode, continueCodeFindIt, continueCodeFixIt]).subscribe(([continueCode, continueCodeFindIt, continueCodeFixIt]) => {
      backup.continueCode = continueCode
      backup.continueCodeFindIt = continueCodeFindIt
      backup.continueCodeFixIt = continueCodeFixIt
      const blob = new Blob([JSON.stringify(backup)], { type: 'text/plain;charset=utf-8' })
      saveAs(blob, `${fileName}-${new Date().toISOString().split('T')[0]}.json`)
    }, () => {
      console.log('Failed to retrieve continue code(s) for backup from server. Using cookie values as fallback.')
      backup.continueCode = this.cookieService.get('continueCode') ? this.cookieService.get('continueCode') : undefined
      backup.continueCodeFindIt = this.cookieService.get('continueCodeFindIt') ? this.cookieService.get('continueCodeFindIt') : undefined
      backup.continueCodeFixIt = this.cookieService.get('continueCodeFixIt') ? this.cookieService.get('continueCodeFixIt') : undefined
      const blob = new Blob([JSON.stringify(backup)], { type: 'text/plain;charset=utf-8' })
      saveAs(blob, `${fileName}-${new Date().toISOString().split('T')[0]}.json`)
    })
  }

  restore (backupFile: File) {
    return from(backupFile.text().then((backupData) => {
      const backup: Backup = JSON.parse(backupData)

      if (backup.version === this.VERSION) {
        this.restoreCookie('welcomebanner_status', backup.banners?.welcomeBannerStatus)
        this.restoreCookie('cookieconsent_status', backup.banners?.cookieConsentStatus)
        this.restoreCookie('language', backup.language)
        this.restoreCookie('continueCodeFindIt', backup.continueCodeFindIt)
        this.restoreCookie('continueCodeFixIt', backup.continueCodeFixIt)
        this.restoreCookie('continueCode', backup.continueCode)

        const snackBarRef = this.snackBar.open('Backup has been restored from ' + backupFile.name, 'Apply changes now', {
          duration: 10000,
          panelClass: ['mat-body']
        })
        snackBarRef.onAction().subscribe(() => {
          const hackingProgress = backup.continueCode ? this.challengeService.restoreProgress(encodeURIComponent(backup.continueCode)) : of(true)
          const findItProgress = backup.continueCodeFindIt ? this.challengeService.restoreProgressFindIt(encodeURIComponent(backup.continueCodeFindIt)) : of(true)
          const fixItProgress = backup.continueCodeFixIt ? this.challengeService.restoreProgressFixIt(encodeURIComponent(backup.continueCodeFixIt)) : of(true)
          forkJoin([hackingProgress, findItProgress, fixItProgress]).subscribe(() => {
            location.reload()
          }, (err) => { console.log(err) })
        })
      } else {
        this.snackBarHelperService.open(`Version ${backup.version} is incompatible with expected version ${this.VERSION}`, 'errorBar')
      }
    }).catch((err: Error) => {
      this.snackBarHelperService.open(`Backup restore operation failed: ${err.message}`, 'errorBar')
    }))
  }

  private restoreCookie (cookieName: string, cookieValue: string) {
    if (cookieValue) {
      const expires = new Date()
      expires.setFullYear(expires.getFullYear() + 1)
      this.cookieService.put(cookieName, cookieValue, { expires })
    } else {
      this.cookieService.remove(cookieName)
    }
  }
}


/* ===== FILE: ./frontend/src/app/Services/keys.service.ts ===== */

import { Injectable } from '@angular/core'
import { HttpClient } from '@angular/common/http'
import { catchError, map } from 'rxjs/operators'
import { environment } from '../../environments/environment'

@Injectable({
  providedIn: 'root'
})
export class KeysService {
  private readonly hostServer = environment.hostServer
  private readonly host = this.hostServer + '/rest/web3'

  constructor (private readonly http: HttpClient) {}

  nftUnlocked () {
    return this.http.get(this.host + '/nftUnlocked').pipe(
      map((response: any) => response),
      catchError((err) => {
        throw err
      })
    )
  }

  nftMintListen () {
    return this.http.get(this.host + '/nftMintListen').pipe(
      map((response: any) => response),
      catchError((err) => {
        throw err
      })
    )
  }

  checkNftMinted () {
    return this.http.get(this.hostServer + '/api/Challenges/?key=nftMintChallenge').pipe(
      map((response: any) => response),
      catchError((err) => {
        throw err
      })
    )
  }

  submitKey (privateKey: string) {
    const endpoint = this.host + '/submitKey'
    const params = { privateKey }
    return this.http.post(endpoint, params).pipe(
      map((response: any) => response),
      catchError((err) => {
        throw err
      })
    )
  }

  verifyNFTWallet (walletAddress: string) {
    const endpoint = this.host + '/walletNFTVerify'
    const params = { walletAddress }
    return this.http.post(endpoint, params).pipe(
      map((response: any) => response),
      catchError((err) => {
        throw err
      })
    )
  }

  walletAddressSend (walletAddress: string) {
    const endpoint = this.host + '/walletExploitAddress'
    const params = { walletAddress }
    return this.http.post(endpoint, params).pipe(
      map((response: any) => response),
      catchError((err) => {
        throw err
      })
    )
  }
}


/* ===== FILE: ./frontend/src/app/Services/configuration.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { environment } from '../../environments/environment'
import { Injectable } from '@angular/core'
import { HttpClient } from '@angular/common/http'
import { catchError, map } from 'rxjs/operators'
import { type Observable } from 'rxjs'

interface ConfigResponse {
  config: Config
}
export interface Config {
  server: {
    port: number
  }
  application: {
    domain: string
    name: string
    logo: string
    favicon: string
    theme: string
    showVersionNumber: boolean
    showGitHubLinks: boolean
    localBackupEnabled: boolean
    numberOfRandomFakeUsers: number
    altcoinName: string
    privacyContactEmail: string
    social: {
      blueSkyUrl: string
      mastodonUrl: string
      twitterUrl: string
      facebookUrl: string
      slackUrl: string
      redditUrl: string
      pressKitUrl: string
      nftUrl: string
      questionnaireUrl: string
    }
    recyclePage: {
      topProductImage: string
      bottomProductImage: string
    }
    welcomeBanner: {
      showOnFirstStart: boolean
      title: string
      message: string
    }
    cookieConsent: {
      message: string
      dismissText: string
      linkText: string
      linkUrl: string
    }
    securityTxt: {
      contact: string
      encryption: string
      acknowledgements: string
    }
    promotion: {
      video: string
      subtitles: string
    }
    easterEggPlanet: {
      name: string
      overlayMap: string
    }
    googleOauth: {
      clientId: string
      authorizedRedirects: any[]
    }
  }
  challenges: {
    showSolvedNotifications: boolean
    showHints: boolean
    showMitigations: boolean
    codingChallengesEnabled: string
    restrictToTutorialsFirst: boolean
    safetyMode: string
    overwriteUrlForProductTamperingChallenge: string
    showFeedbackButtons: boolean
  }
  hackingInstructor: {
    isEnabled: boolean
    avatarImage: string
  }
  products: any[]
  memories: any[]
  ctf: {
    showFlagsInNotifications: boolean
    showCountryDetailsInNotifications: string
    countryMapping: any[]
  }
}

@Injectable({
  providedIn: 'root'
})
export class ConfigurationService {
  private readonly hostServer = environment.hostServer
  private readonly host = this.hostServer + '/rest/admin'
  private configObservable: any
  constructor (private readonly http: HttpClient) { }

  getApplicationConfiguration (): Observable<Config> {
    if (this.configObservable) {
      return this.configObservable
    } else {
      this.configObservable = this.http.get<ConfigResponse>(this.host + '/application-configuration').pipe(map((response: ConfigResponse) => response.config, catchError((err) => { throw err })))
      return this.configObservable
    }
  }
}


/* ===== FILE: ./frontend/src/app/Services/code-snippet.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing'
import { fakeAsync, inject, TestBed, tick } from '@angular/core/testing'

import { CodeSnippetService } from './code-snippet.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('CodeSnippetService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [],
      providers: [CodeSnippetService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
  })

  it('should be created', inject([CodeSnippetService], (service: CodeSnippetService) => {
    expect(service).toBeTruthy()
  }))

  it('should get single snippet directly from the rest api', inject([CodeSnippetService, HttpTestingController],
    fakeAsync((service: CodeSnippetService, httpMock: HttpTestingController) => {
      let res: any
      service.get('testChallenge').subscribe((data) => (res = data))

      const req = httpMock.expectOne('http://localhost:3000/snippets/testChallenge')
      req.flush({ snippet: 'apiResponse' })
      tick()

      expect(req.request.method).toBe('GET')
      expect(res).toEqual({ snippet: 'apiResponse' })
      httpMock.verify()
    })
  ))
})


/* ===== FILE: ./frontend/src/app/Services/window-ref.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { inject, TestBed } from '@angular/core/testing'

import { WindowRefService } from './window-ref.service'

describe('WindowRefService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      providers: [WindowRefService]
    })
  })

  it('should be created', inject([WindowRefService], (service: WindowRefService) => {
    expect(service).toBeTruthy()
  }))
})


/* ===== FILE: ./frontend/src/app/Services/user.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { environment } from '../../environments/environment'
import { Injectable } from '@angular/core'
import { HttpClient } from '@angular/common/http'
import { catchError, map } from 'rxjs/operators'
import { Subject } from 'rxjs'

interface Passwords {
  current?: string
  new?: string
  repeat?: string
}

@Injectable({
  providedIn: 'root'
})
export class UserService {
  public isLoggedIn = new Subject<any>()
  private readonly hostServer = environment.hostServer
  private readonly host = this.hostServer + '/api/Users'

  constructor (private readonly http: HttpClient) { }

  find (params?: any) {
    return this.http.get(this.hostServer + '/rest/user/authentication-details/', { params }).pipe(map((response: any) =>
      response.data), catchError((err) => { throw err }))
  }

  get (id: number) {
    return this.http.get(`${this.host}/${id}`).pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }

  save (params: any) {
    return this.http.post(this.host + '/', params).pipe(
      map((response: any) => response.data),
      catchError((err) => { throw err })
    )
  }

  login (params: any) {
    this.isLoggedIn.next(true)
    return this.http.post(this.hostServer + '/rest/user/login', params).pipe(map((response: any) => response.authentication), catchError((err) => { throw err }))
  }

  getLoggedInState () {
    return this.isLoggedIn.asObservable()
  }

  changePassword (passwords: Passwords) {
    return this.http.get(this.hostServer + '/rest/user/change-password?current=' + passwords.current + '&new=' +
    passwords.new + '&repeat=' + passwords.repeat).pipe(map((response: any) => response.user), catchError((err) => { throw err.error }))
  }

  resetPassword (params: any) {
    return this.http.post(this.hostServer + '/rest/user/reset-password', params).pipe(map((response: any) => response.user), catchError((err) => { throw err }))
  }

  whoAmI () {
    return this.http.get(this.hostServer + '/rest/user/whoami').pipe(map((response: any) => response.user), catchError((err) => { throw err }))
  }

  oauthLogin (accessToken: string) {
    return this.http.get('https://www.googleapis.com/oauth2/v1/userinfo?alt=json&access_token=' + accessToken)
  }

  saveLastLoginIp () {
    return this.http.get(this.hostServer + '/rest/saveLoginIp').pipe(map((response: any) => response), catchError((err) => { throw err }))
  }

  deluxeStatus () {
    return this.http.get(this.hostServer + '/rest/deluxe-membership').pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }

  upgradeToDeluxe (paymentMode: string, paymentId: any) {
    return this.http.post(this.hostServer + '/rest/deluxe-membership', { paymentMode, paymentId }).pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }
}


/* ===== FILE: ./frontend/src/app/Services/complaint.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing'
import { fakeAsync, inject, TestBed, tick } from '@angular/core/testing'

import { ComplaintService } from './complaint.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('ComplaintService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [],
      providers: [ComplaintService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
  })

  it('should be created', inject([ComplaintService], (service: ComplaintService) => {
    expect(service).toBeTruthy()
  }))

  it('should create complaint directly via the rest api', inject([ComplaintService, HttpTestingController],
    fakeAsync((service: ComplaintService, httpMock: HttpTestingController) => {
      let res: any
      service.save(null).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/api/Complaints/')
      req.flush({ data: 'apiResponse' })

      tick()
      expect(req.request.method).toBe('POST')
      expect(req.request.body).toBeNull()
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))
})


/* ===== FILE: ./frontend/src/app/Services/snack-bar-helper.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Injectable } from '@angular/core'
import { MatSnackBar } from '@angular/material/snack-bar'
import { TranslateService } from '@ngx-translate/core'

@Injectable({
  providedIn: 'root'
})
export class SnackBarHelperService {
  constructor (private readonly translateService: TranslateService,
    private readonly snackBar: MatSnackBar) { }

  open (message: string, cssClass?: string) {
    this.translateService.get(message).subscribe((translatedMessage) => {
      this.snackBar.open(translatedMessage, 'X', {
        duration: 5000,
        panelClass: [cssClass, 'mat-body']
      })
    }, () => {
      this.snackBar.open(message, 'X', {
        duration: 5000,
        panelClass: [cssClass, 'mat-body']
      })
    })
  }
}


/* ===== FILE: ./frontend/src/app/Services/feedback.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing'
import { fakeAsync, inject, TestBed, tick } from '@angular/core/testing'

import { FeedbackService } from './feedback.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('FeedbackService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [],
      providers: [FeedbackService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
  })

  it('should be created', inject([FeedbackService], (service: FeedbackService) => {
    expect(service).toBeTruthy()
  }))

  it('should get all feedback directly from the rest api', inject([FeedbackService, HttpTestingController],
    fakeAsync((service: FeedbackService, httpMock: HttpTestingController) => {
      let res: any
      service.find(null).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/api/Feedbacks/')
      req.flush({ data: 'apiResponse' })

      tick()
      expect(req.request.method).toBe('GET')
      expect(req.request.params.toString()).toBeFalsy()
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should delete feedback directly via the rest api', inject([FeedbackService, HttpTestingController],
    fakeAsync((service: FeedbackService, httpMock: HttpTestingController) => {
      let res: any
      service.del(1).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/api/Feedbacks/1')
      req.flush({ data: 'apiResponse' })

      tick()
      expect(req.request.method).toBe('DELETE')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should create feedback directly via the rest api', inject([FeedbackService, HttpTestingController],
    fakeAsync((service: FeedbackService, httpMock: HttpTestingController) => {
      let res: any
      service.save(null).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/api/Feedbacks/')
      req.flush({ data: 'apiResponse' })

      tick()
      expect(req.request.method).toBe('POST')
      expect(req.request.body).toBeNull()
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))
})


/* ===== FILE: ./frontend/src/app/Services/security-answer.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { environment } from '../../environments/environment'
import { HttpClient } from '@angular/common/http'
import { Injectable } from '@angular/core'
import { catchError, map } from 'rxjs/operators'

@Injectable({
  providedIn: 'root'
})
export class SecurityAnswerService {
  private readonly hostServer = environment.hostServer
  private readonly host = this.hostServer + '/api/SecurityAnswers'

  constructor (private readonly http: HttpClient) { }

  save (params: any) {
    return this.http.post(this.host + '/', params).pipe(
      map((response: any) => response.data),
      catchError((err) => { throw err })
    )
  }
}


/* ===== FILE: ./frontend/src/app/Services/delivery.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { environment } from '../../environments/environment'
import { Injectable } from '@angular/core'
import { HttpClient } from '@angular/common/http'
import { catchError, map } from 'rxjs/operators'
import { type DeliveryMethod } from '../Models/deliveryMethod.model'

interface DeliveryMultipleMethodResponse {
  status: string
  data: DeliveryMethod[]
}

interface DeliverySingleMethodResponse {
  status: string
  data: DeliveryMethod
}

@Injectable({
  providedIn: 'root'
})
export class DeliveryService {
  private readonly hostServer = environment.hostServer
  private readonly host = this.hostServer + '/api/Deliverys'

  constructor (private readonly http: HttpClient) { }

  get () {
    return this.http.get(this.host).pipe(map((response: DeliveryMultipleMethodResponse) => response.data), catchError((err) => { throw err }))
  }

  getById (id) {
    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
    return this.http.get(`${this.host}/${id}`).pipe(map((response: DeliverySingleMethodResponse) => response.data), catchError((err) => { throw err }))
  }
}


/* ===== FILE: ./frontend/src/app/Services/configuration.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { fakeAsync, inject, TestBed, tick } from '@angular/core/testing'
import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing'
import { ConfigurationService } from './configuration.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('ConfigurationService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [],
      providers: [ConfigurationService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
  })

  it('should be created', inject([ConfigurationService], (service: ConfigurationService) => {
    expect(service).toBeTruthy()
  }))

  it('should get application configuration directly from the rest api',
    inject([ConfigurationService, HttpTestingController],
      fakeAsync((service: ConfigurationService, httpMock: HttpTestingController) => {
        let res: any
        service.getApplicationConfiguration().subscribe(data => { res = data })

        const req = httpMock.expectOne('http://localhost:3000/rest/admin/application-configuration')
        req.flush({
          config:
            {
              version: '8.0.0',
              showGitHubLinks: false
            }
        })

        tick()

        const data = res
        expect(data.version).toBe('8.0.0')
        expect(data.showGitHubLink).toBeFalsy()

        httpMock.verify()
      })
    ))

  it('should throw an error on recieving an error from the server',
    inject([ConfigurationService, HttpTestingController],
      fakeAsync((service: ConfigurationService, httpMock: HttpTestingController) => {
        let res: any
        service.getApplicationConfiguration().subscribe(data => {
          console.log(data)
        }, (err) => (res = err))
        const req = httpMock.expectOne('http://localhost:3000/rest/admin/application-configuration')
        req.error(new ErrorEvent('Request failed'), { status: 404, statusText: 'Request failed' })
        tick()

        const error = res
        expect(service.getApplicationConfiguration).toThrow()
        expect(error.status).toBe(404)
        expect(error.statusText).toBe('Request failed')
        httpMock.verify()
      })
    ))
})


/* ===== FILE: ./frontend/src/app/Services/feedback.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { environment } from '../../environments/environment'
import { Injectable } from '@angular/core'
import { HttpClient } from '@angular/common/http'
import { catchError, map } from 'rxjs/operators'

@Injectable({
  providedIn: 'root'
})
export class FeedbackService {
  private readonly hostServer = environment.hostServer
  private readonly host = this.hostServer + '/api/Feedbacks'

  constructor (private readonly http: HttpClient) { }

  find (params?: any) {
    return this.http.get(this.host + '/', {
      params
    }).pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }

  save (params: any) {
    return this.http.post(this.host + '/', params).pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }

  del (id: number) {
    return this.http.delete(`${this.host}/${id}`).pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }
}


/* ===== FILE: ./frontend/src/app/Services/product.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing'
import { fakeAsync, inject, TestBed, tick } from '@angular/core/testing'

import { ProductService } from './product.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('ProductService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [],
      providers: [ProductService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
  })

  it('should be created', inject([ProductService], (service: ProductService) => {
    expect(service).toBeTruthy()
  }))

  it('should search for products directly from the rest api', inject([ProductService, HttpTestingController],
    fakeAsync((service: ProductService, httpMock: HttpTestingController) => {
      let res: any
      service.search('1').subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/rest/products/search?q=1')
      req.flush({ data: 'apiResponse' })

      tick()
      expect(req.request.method).toBe('GET')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should get all products directly from the rest api', inject([ProductService, HttpTestingController],
    fakeAsync((service: ProductService, httpMock: HttpTestingController) => {
      let res: any
      service.find(null).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/api/Products/')
      req.flush({ data: 'apiResponse' })

      tick()
      expect(req.request.method).toBe('GET')
      expect(req.request.params.toString()).toBeFalsy()
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should get single product directly from the rest api', inject([ProductService, HttpTestingController],
    fakeAsync((service: ProductService, httpMock: HttpTestingController) => {
      let res: any
      service.get(1).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/api/Products/1?d=' + encodeURIComponent(new Date().toDateString()))
      req.flush({ data: 'apiResponse' })

      tick()
      expect(req.request.method).toBe('GET')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))
})


/* ===== FILE: ./frontend/src/app/Services/challenge.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing'
import { fakeAsync, inject, TestBed, tick } from '@angular/core/testing'

import { ChallengeService } from './challenge.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('ChallengeService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [],
      providers: [ChallengeService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
  })

  it('should be created', inject([ChallengeService], (service: ChallengeService) => {
    expect(service).toBeTruthy()
  }))

  it('should get all challenges directly from the rest api', inject([ChallengeService, HttpTestingController],
    fakeAsync((service: ChallengeService, httpMock: HttpTestingController) => {
      let res: any
      service.find().subscribe((data) => (res = data))

      const req = httpMock.expectOne('http://localhost:3000/api/Challenges/')
      req.flush({ data: 'apiResponse' })
      tick()

      expect(req.request.method).toBe('GET')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should get current continue code directly from the rest api', inject([ChallengeService, HttpTestingController],
    fakeAsync((service: ChallengeService, httpMock: HttpTestingController) => {
      let res: any
      service.continueCode().subscribe((data) => (res = data))

      const req = httpMock.expectOne('http://localhost:3000/rest/continue-code')
      req.flush({ continueCode: 'apiResponse' })
      tick()

      expect(req.request.method).toBe('GET')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should pass continue code for restoring challenge progress on to the rest api', inject([ChallengeService, HttpTestingController],
    fakeAsync((service: ChallengeService, httpMock: HttpTestingController) => {
      let res: any
      service.restoreProgress('CODE').subscribe((data) => (res = data))

      const req = httpMock.expectOne('http://localhost:3000/rest/continue-code/apply/CODE')
      req.flush({ data: 'apiResponse' })
      tick()

      expect(req.request.method).toBe('PUT')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should get current "Find It" coding challenge continue code directly from the rest api', inject([ChallengeService, HttpTestingController],
    fakeAsync((service: ChallengeService, httpMock: HttpTestingController) => {
      let res: any
      service.continueCodeFindIt().subscribe((data) => (res = data))

      const req = httpMock.expectOne('http://localhost:3000/rest/continue-code-findIt')
      req.flush({ continueCode: 'apiResponse' })
      tick()

      expect(req.request.method).toBe('GET')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should pass "Find It" coding challenge continue code for restoring progress on to the rest api', inject([ChallengeService, HttpTestingController],
    fakeAsync((service: ChallengeService, httpMock: HttpTestingController) => {
      let res: any
      service.restoreProgressFindIt('CODE').subscribe((data) => (res = data))

      const req = httpMock.expectOne('http://localhost:3000/rest/continue-code-findIt/apply/CODE')
      req.flush({ data: 'apiResponse' })
      tick()

      expect(req.request.method).toBe('PUT')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should get current "Fix It" coding challenge continue code directly from the rest api', inject([ChallengeService, HttpTestingController],
    fakeAsync((service: ChallengeService, httpMock: HttpTestingController) => {
      let res: any
      service.continueCodeFixIt().subscribe((data) => (res = data))

      const req = httpMock.expectOne('http://localhost:3000/rest/continue-code-fixIt')
      req.flush({ continueCode: 'apiResponse' })
      tick()

      expect(req.request.method).toBe('GET')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should pass "Fix It" coding challenge continue code for restoring progress on to the rest api', inject([ChallengeService, HttpTestingController],
    fakeAsync((service: ChallengeService, httpMock: HttpTestingController) => {
      let res: any
      service.restoreProgressFixIt('CODE').subscribe((data) => (res = data))

      const req = httpMock.expectOne('http://localhost:3000/rest/continue-code-fixIt/apply/CODE')
      req.flush({ data: 'apiResponse' })
      tick()

      expect(req.request.method).toBe('PUT')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should repeat notification directly from the rest api', inject([ChallengeService, HttpTestingController],
    fakeAsync((service: ChallengeService, httpMock: HttpTestingController) => {
      let res: any
      service.repeatNotification('CHALLENGE').subscribe((data) => (res = data))

      const req = httpMock.expectOne(req => req.url === 'http://localhost:3000/rest/repeat-notification')
      req.flush('apiResponse')
      tick()

      expect(req.request.method).toBe('GET')
      expect(req.request.params.get('challenge')).toBe('CHALLENGE')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))
})


/* ===== FILE: ./frontend/src/app/Services/captcha.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { HttpClient } from '@angular/common/http'
import { environment } from '../../environments/environment'
import { Injectable } from '@angular/core'
import { catchError } from 'rxjs/operators'

@Injectable({
  providedIn: 'root'
})
export class CaptchaService {
  private readonly hostServer = environment.hostServer
  private readonly host = this.hostServer + '/rest/captcha'

  constructor (private readonly http: HttpClient) { }

  getCaptcha () {
    return this.http.get(this.host + '/').pipe(catchError((err) => { throw err }))
  }
}


/* ===== FILE: ./frontend/src/app/Services/payment.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing'
import { fakeAsync, inject, TestBed, tick } from '@angular/core/testing'
import { PaymentService } from './payment.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('PaymentService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [],
      providers: [PaymentService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
  })

  it('should be created', inject([PaymentService], (service: PaymentService) => {
    expect(service).toBeTruthy()
  }))

  it('should get payment cards directly from the api', inject([PaymentService, HttpTestingController],
    fakeAsync((service: PaymentService, httpMock: HttpTestingController) => {
      let res
      service.get().subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/api/Cards')
      req.flush({ data: 'apiResponse' })
      tick()
      expect(req.request.method).toBe('GET')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should get single payment card directly from the api', inject([PaymentService, HttpTestingController],
    fakeAsync((service: PaymentService, httpMock: HttpTestingController) => {
      let res
      service.getById(1).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/api/Cards/1')
      req.flush({ data: 'apiResponse' })
      tick()
      expect(req.request.method).toBe('GET')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should create payment card directly from the api', inject([PaymentService, HttpTestingController],
    fakeAsync((service: PaymentService, httpMock: HttpTestingController) => {
      let res
      service.save({}).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/api/Cards/')
      req.flush({ data: 'apiResponse' })
      tick()
      expect(req.request.method).toBe('POST')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should delete payment card directly from the api', inject([PaymentService, HttpTestingController],
    fakeAsync((service: PaymentService, httpMock: HttpTestingController) => {
      let res
      service.del(1).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/api/Cards/1')
      req.flush({ data: 'apiResponse' })
      tick()
      expect(req.request.method).toBe('DELETE')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))
})


/* ===== FILE: ./frontend/src/app/Services/user.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing'
import { fakeAsync, inject, TestBed, tick } from '@angular/core/testing'

import { UserService } from './user.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('UserService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [],
      providers: [UserService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
  })

  it('should be created', inject([UserService], (service: UserService) => {
    expect(service).toBeTruthy()
  }))

  it('should get all users directly from the rest api', inject([UserService, HttpTestingController],
    fakeAsync((service: UserService, httpMock: HttpTestingController) => {
      let res: any
      service.find().subscribe((data) => (res = data))

      const req = httpMock.expectOne('http://localhost:3000/rest/user/authentication-details/')
      req.flush({ data: 'apiResponse' })
      tick()

      expect(req.request.method).toBe('GET')
      expect(req.request.params.toString()).toBeFalsy()
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should get single users directly from the rest api', inject([UserService, HttpTestingController],
    fakeAsync((service: UserService, httpMock: HttpTestingController) => {
      let res: any
      service.get(1).subscribe((data) => (res = data))

      const req = httpMock.expectOne('http://localhost:3000/api/Users/1')
      req.flush({ data: 'apiResponse' })
      tick()

      expect(req.request.method).toBe('GET')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should create user directly via the rest api', inject([UserService, HttpTestingController],
    fakeAsync((service: UserService, httpMock: HttpTestingController) => {
      let res: any
      service.save(null).subscribe((data) => (res = data))

      const req = httpMock.expectOne('http://localhost:3000/api/Users/')
      req.flush({ data: 'apiResponse' })
      tick()

      expect(req.request.method).toBe('POST')
      expect(req.request.body).toBeNull()
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should login user directly via the rest api', inject([UserService, HttpTestingController],
    fakeAsync((service: UserService, httpMock: HttpTestingController) => {
      let res: any
      service.login(null).subscribe((data) => (res = data))

      const req = httpMock.expectOne('http://localhost:3000/rest/user/login')
      req.flush({ authentication: 'apiResponse' })
      tick()

      expect(req.request.method).toBe('POST')
      expect(req.request.body).toBeNull()
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should change user password directly via the rest api', inject([UserService, HttpTestingController],
    fakeAsync((service: UserService, httpMock: HttpTestingController) => {
      let res: any
      service.changePassword({ current: 'foo', new: 'bar', repeat: 'bar' }).subscribe((data) => (res = data))

      const req = httpMock.expectOne('http://localhost:3000/rest/user/change-password?current=foo&new=bar&repeat=bar')
      req.flush({ user: 'apiResponse' })
      tick()

      expect(req.request.method).toBe('GET')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should return the logged-in users identity directly from the rest api', inject([UserService, HttpTestingController],
    fakeAsync((service: UserService, httpMock: HttpTestingController) => {
      let res: any
      service.whoAmI().subscribe((data) => (res = data))

      const req = httpMock.expectOne('http://localhost:3000/rest/user/whoami')
      req.flush({ user: 'apiResponse' })
      tick()

      expect(req.request.method).toBe('GET')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should reset the password directly from the rest api', inject([UserService, HttpTestingController],
    fakeAsync((service: UserService, httpMock: HttpTestingController) => {
      let res: any
      const mockObject = { req: 'apiRequest' }
      service.resetPassword(mockObject).subscribe((data) => (res = data))

      const req = httpMock.expectOne('http://localhost:3000/rest/user/reset-password')
      req.flush({ user: 'apiResponse' })
      tick()

      expect(req.request.method).toBe('POST')
      expect(req.request.body).toEqual(mockObject)
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should get users deluxe status directly from the rest api', inject([UserService, HttpTestingController],
    fakeAsync((service: UserService, httpMock: HttpTestingController) => {
      let res
      service.deluxeStatus().subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/rest/deluxe-membership')
      req.flush({ data: 'apiResponse' })
      tick()
      expect(req.request.method).toBe('GET')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should upgrade users deluxe status directly from the rest api', inject([UserService, HttpTestingController],
    fakeAsync((service: UserService, httpMock: HttpTestingController) => {
      let res
      service.upgradeToDeluxe('wallet', null).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/rest/deluxe-membership')
      req.flush({ data: 'apiResponse' })
      tick()
      expect(req.request.method).toBe('POST')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))
})


/* ===== FILE: ./frontend/src/app/Services/complaint.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { environment } from '../../environments/environment'
import { HttpClient } from '@angular/common/http'
import { Injectable } from '@angular/core'
import { catchError, map } from 'rxjs/operators'

@Injectable({
  providedIn: 'root'
})
export class ComplaintService {
  private readonly hostServer = environment.hostServer
  private readonly host = this.hostServer + '/api/Complaints'
  constructor (private readonly http: HttpClient) { }

  save (params: any) {
    return this.http.post(this.host + '/', params).pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }
}


/* ===== FILE: ./frontend/src/app/Services/two-factor-auth-service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing'
import { fakeAsync, inject, TestBed, tick } from '@angular/core/testing'

import { TwoFactorAuthService } from './two-factor-auth-service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('TwoFactorAuthServiceService', () => {
  beforeEach(() => TestBed.configureTestingModule({
    imports: [],
    providers: [TwoFactorAuthService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
  }))

  it('should be created', inject([TwoFactorAuthService], (service: TwoFactorAuthService) => {
    expect(service).toBeTruthy()
  }))

  it('should verify TOTP token directly via the rest api', inject([TwoFactorAuthService, HttpTestingController],
    fakeAsync((service: TwoFactorAuthService, httpMock: HttpTestingController) => {
      localStorage.setItem('totp_tmp_token', '000000')
      let res: any
      service.verify('123456').subscribe((data) => (res = data))

      const req = httpMock.expectOne('http://localhost:3000/rest/2fa/verify')
      req.flush({ authentication: 'apiResponse' })
      tick()

      expect(req.request.method).toBe('POST')
      expect(req.request.body).toEqual({ tmpToken: '000000', totpToken: '123456' })
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should retrieve 2FA status directly via the rest api', inject([TwoFactorAuthService, HttpTestingController],
    fakeAsync((service: TwoFactorAuthService, httpMock: HttpTestingController) => {
      let res: any
      service.status().subscribe((data) => (res = data))

      const req = httpMock.expectOne('http://localhost:3000/rest/2fa/status')
      req.flush({ setup: false })
      tick()

      expect(req.request.method).toBe('GET')
      expect(req.request.params.toString()).toBeFalsy()
      expect(res).toEqual({ setup: false })
      httpMock.verify()
    })
  ))

  it('should set up 2FA directly via the rest api', inject([TwoFactorAuthService, HttpTestingController],
    fakeAsync((service: TwoFactorAuthService, httpMock: HttpTestingController) => {
      let res: any
      service.setup('s3cr3t!', 'initialToken', 'setupToken').subscribe((data) => (res = data))

      const req = httpMock.expectOne('http://localhost:3000/rest/2fa/setup')
      req.flush({})
      tick()

      expect(req.request.method).toBe('POST')
      expect(req.request.body).toEqual({ password: 's3cr3t!', initialToken: 'initialToken', setupToken: 'setupToken' })
      expect(res).toBe(undefined)
      httpMock.verify()
    })
  ))

  it('should disable 2FA directly via the rest api', inject([TwoFactorAuthService, HttpTestingController],
    fakeAsync((service: TwoFactorAuthService, httpMock: HttpTestingController) => {
      let res: any
      service.disable('s3cr3t!').subscribe((data) => (res = data))

      const req = httpMock.expectOne('http://localhost:3000/rest/2fa/disable')
      req.flush({})
      tick()

      expect(req.request.method).toBe('POST')
      expect(req.request.body).toEqual({ password: 's3cr3t!' })
      expect(res).toBe(undefined)
      httpMock.verify()
    })
  ))
})


/* ===== FILE: ./frontend/src/app/Services/photo-wall.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing'
import { fakeAsync, inject, TestBed, tick } from '@angular/core/testing'
import { PhotoWallService } from './photo-wall.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('PhotoWallService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [],
      providers: [PhotoWallService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
  })

  it('should be created', inject([PhotoWallService], (service: PhotoWallService) => {
    expect(service).toBeTruthy()
  }))

  it('should get memories directly from the api', inject([PhotoWallService, HttpTestingController],
    fakeAsync((service: PhotoWallService, httpMock: HttpTestingController) => {
      let res
      service.get().subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/rest/memories/')
      req.flush({ data: 'apiResponse' })
      tick()
      expect(req.request.method).toBe('GET')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should create memories directly from the api', inject([PhotoWallService, HttpTestingController],
    fakeAsync((service: PhotoWallService, httpMock: HttpTestingController) => {
      let res
      service.addMemory('str', new File([''], 'image')).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/rest/memories')
      req.flush({ data: 'apiResponse' })
      tick()
      expect(req.request.method).toBe('POST')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))
})


/* ===== FILE: ./frontend/src/app/Services/form-submit.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TestBed } from '@angular/core/testing'
import { DOCUMENT } from '@angular/common'
import { FormSubmitService } from './form-submit.service'

describe('FormSubmitService', () => {
  let service: FormSubmitService
  let documentMock: Document

  beforeEach(() => {
    documentMock = document.implementation.createHTMLDocument()
    TestBed.configureTestingModule({
      providers: [
        FormSubmitService,
        { provide: DOCUMENT, useValue: documentMock }
      ]
    })
    service = TestBed.inject(FormSubmitService)
  })

  it('should be created', () => {
    expect(service).toBeTruthy()
  })

  it('should attach keyup event listener to the form', () => {
    const form = documentMock.createElement('form')
    form.id = 'testForm'
    documentMock.body.appendChild(form)

    const submitButton = documentMock.createElement('input')
    submitButton.id = 'submitButton'
    documentMock.body.appendChild(submitButton)

    const onSubmit = jasmine.createSpy('onSubmit')
    service.attachEnterKeyHandler('testForm', 'submitButton', onSubmit)

    // eslint-disable-next-line import/no-deprecated
    const event = new KeyboardEvent('keyup', { keyCode: 13 })
    form.dispatchEvent(event)

    expect(onSubmit).toHaveBeenCalled()
  })

  it('should submit form when Enter key is pressed and submit button is not disabled', () => {
    const form = documentMock.createElement('form')
    form.id = 'testForm'
    documentMock.body.appendChild(form)

    const submitButton = documentMock.createElement('input')
    submitButton.id = 'submitButton'
    submitButton.disabled = false
    documentMock.body.appendChild(submitButton)

    const onSubmit = jasmine.createSpy('onSubmit')
    service.attachEnterKeyHandler('testForm', 'submitButton', onSubmit)

    // eslint-disable-next-line import/no-deprecated
    const event = new KeyboardEvent('keyup', { keyCode: 13 })
    form.dispatchEvent(event)

    expect(onSubmit).toHaveBeenCalled()
  })

  it('should not submit form when Enter key is pressed but submit button is disabled', () => {
    const form = documentMock.createElement('form')
    form.id = 'testForm'
    documentMock.body.appendChild(form)

    const submitButton = documentMock.createElement('input')
    submitButton.id = 'submitButton'
    submitButton.disabled = true
    documentMock.body.appendChild(submitButton)

    const onSubmit = jasmine.createSpy('onSubmit')
    service.attachEnterKeyHandler('testForm', 'submitButton', onSubmit)

    // eslint-disable-next-line import/no-deprecated
    const event = new KeyboardEvent('keyup', { keyCode: 13 })
    form.dispatchEvent(event)

    expect(onSubmit).not.toHaveBeenCalled()
  })
})


/* ===== FILE: ./frontend/src/app/Services/image-captcha.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing'
import { fakeAsync, inject, TestBed, tick } from '@angular/core/testing'
import { ImageCaptchaService } from './image-captcha.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('ImageCaptchaService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [],
      providers: [ImageCaptchaService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
  })

  it('should be created', inject([ImageCaptchaService], (service: ImageCaptchaService) => {
    expect(service).toBeTruthy()
  }))

  it('should get captcha directly from the rest api', inject([ImageCaptchaService, HttpTestingController],
    fakeAsync((service: ImageCaptchaService, httpMock: HttpTestingController) => {
      let res: any
      service.getCaptcha().subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/rest/image-captcha/')
      req.flush('apiResponse')

      tick()
      expect(req.request.method).toBe('GET')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))
})


/* ===== FILE: ./frontend/src/app/Services/snack-bar-helper.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TestBed } from '@angular/core/testing'
import { TranslateFakeLoader, TranslateLoader, TranslateModule, TranslateService } from '@ngx-translate/core'
import { MatSnackBarModule } from '@angular/material/snack-bar'

import { SnackBarHelperService } from './snack-bar-helper.service'

describe('SnackBarHelperService', () => {
  beforeEach(() =>
    TestBed.configureTestingModule({
      imports: [
        TranslateModule.forRoot({
          loader: {
            provide: TranslateLoader,
            useClass: TranslateFakeLoader
          }
        }),
        MatSnackBarModule
      ],
      providers: [TranslateService]
    })
  )

  it('should be created', () => {
    const service: SnackBarHelperService = TestBed.inject(SnackBarHelperService)
    expect(service).toBeTruthy()
  })
})


/* ===== FILE: ./frontend/src/app/Services/wallet.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing'
import { fakeAsync, inject, TestBed, tick } from '@angular/core/testing'
import { WalletService } from './wallet.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('WalletService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [],
      providers: [WalletService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
  })

  it('should be created', inject([WalletService], (service: WalletService) => {
    expect(service).toBeTruthy()
  }))

  it('should get wallet balance directly from the api', inject([WalletService, HttpTestingController],
    fakeAsync((service: WalletService, httpMock: HttpTestingController) => {
      let res
      service.get().subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/rest/wallet/balance')
      req.flush({ data: 'apiResponse' })
      tick()
      expect(req.request.method).toBe('GET')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should update wallet balance directly from the api', inject([WalletService, HttpTestingController],
    fakeAsync((service: WalletService, httpMock: HttpTestingController) => {
      let res
      service.put(1).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/rest/wallet/balance')
      req.flush({ data: 'apiResponse' })
      tick()
      expect(req.request.method).toBe('PUT')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))
})


/* ===== FILE: ./frontend/src/app/Services/country-mapping.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { environment } from '../../environments/environment'
import { HttpClient } from '@angular/common/http'
import { Injectable } from '@angular/core'
import { catchError } from 'rxjs/operators'

@Injectable({
  providedIn: 'root'
})
export class CountryMappingService {
  private readonly hostServer = environment.hostServer
  constructor (private readonly http: HttpClient) { }

  getCountryMapping () {
    return this.http.get(this.hostServer + '/rest/country-mapping').pipe(catchError((err) => { throw err }))
  }
}


/* ===== FILE: ./frontend/src/app/Services/local-backup.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { inject, TestBed, waitForAsync } from '@angular/core/testing'

import { LocalBackupService } from './local-backup.service'
import { CookieModule, CookieService } from 'ngy-cookie'
import { TranslateFakeLoader, TranslateLoader, TranslateModule } from '@ngx-translate/core'
import { MatSnackBar } from '@angular/material/snack-bar'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'
import * as FileSaver from 'file-saver'
import { ChallengeService } from './challenge.service'

describe('LocalBackupService', () => {
  let snackBar: any
  let cookieService: any
  let challengeService: any

  beforeEach(() => {
    snackBar = jasmine.createSpyObj('MatSnackBar', ['open'])
    snackBar.open.and.returnValue(null)
    challengeService = jasmine.createSpyObj('ChallengeService', ['restoreProgress', 'continueCode', 'continueCodeFindIt', 'continueCodeFixIt'])

    TestBed.configureTestingModule({
      imports: [
        CookieModule.forRoot(),
        TranslateModule.forRoot({
          loader: {
            provide: TranslateLoader,
            useClass: TranslateFakeLoader
          }
        }),
        BrowserAnimationsModule
      ],
      providers: [
        { provide: MatSnackBar, useValue: snackBar },
        { provide: ChallengeService, useValue: challengeService },
        CookieService,
        LocalBackupService
      ]
    })
    cookieService = TestBed.inject(CookieService)
  })

  it('should be created', inject([LocalBackupService], (service: LocalBackupService) => {
    expect(service).toBeTruthy()
  }))

  it('should save language to file', inject([LocalBackupService], (service: LocalBackupService) => {
    spyOn(FileSaver, 'saveAs').and.stub()

    cookieService.put('language', 'de')
    service.save()

    const blob = new Blob([JSON.stringify({ version: 1, language: 'de' })], { type: 'text/plain;charset=utf-8' })
    expect(FileSaver.saveAs).toHaveBeenCalledWith(blob, `owasp_juice_shop-${new Date().toISOString().split('T')[0]}.json`)
  }))

  it('should restore language from backup file', waitForAsync(inject([LocalBackupService], (service: LocalBackupService) => {
    cookieService.put('language', 'de')
    service.restore(new File(['{ "version": 1, "language": "cn" }'], 'test.json')).subscribe(() => {
      expect(cookieService.get('language')).toBe('cn')
      expect(snackBar.open).toHaveBeenCalled()
    })
  })))

  it('should not restore language from an outdated backup version', waitForAsync(inject([LocalBackupService], (service: LocalBackupService) => {
    cookieService.put('language', 'de')
    service.restore(new File(['{ "version": 0, "language": "cn" }'], 'test.json')).subscribe(() => {
      expect(cookieService.get('language')).toBe('de')
      expect(snackBar.open).toHaveBeenCalled()
    })
  })))
})


/* ===== FILE: ./frontend/src/app/Services/code-fixes.service.spec.ts ===== */

import { fakeAsync, inject, TestBed, tick } from '@angular/core/testing'
import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing'
import { CodeFixesService } from './code-fixes.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('CodeFixesService', () => {
  let service: CodeFixesService

  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [],
      providers: [CodeFixesService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
    service = TestBed.inject(CodeFixesService)
  })

  it('should be created', () => {
    expect(service).toBeTruthy()
  })

  it('should get code fixes for challenge directly from the rest api', inject([CodeFixesService, HttpTestingController],
    fakeAsync((service: CodeFixesService, httpMock: HttpTestingController) => {
      let res: any
      service.get('testChallenge').subscribe((data) => (res = data))

      const req = httpMock.expectOne('http://localhost:3000/snippets/fixes/testChallenge')
      req.flush({ snippet: 'apiResponse' })
      tick()

      expect(req.request.method).toBe('GET')
      expect(res).toEqual({ snippet: 'apiResponse' })
      httpMock.verify()
    })
  ))

  it('should submit solution for "Fit It" phase of coding challenge via the rest api', inject([CodeFixesService, HttpTestingController],
    fakeAsync((service: CodeFixesService, httpMock: HttpTestingController) => {
      let res: any
      service.check('testChallenge', 1).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/snippets/fixes')
      req.flush('apiResponse')

      tick()
      expect(req.request.method).toBe('POST')
      expect(req.request.body).toEqual({ key: 'testChallenge', selectedFix: 1 })
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))
})


/* ===== FILE: ./frontend/src/app/Services/vuln-lines.service.spec.ts ===== */

import { TestBed, inject, fakeAsync, tick } from '@angular/core/testing'
import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing'
import { VulnLinesService } from './vuln-lines.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('VulnLinesService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [],
      providers: [VulnLinesService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
  })

  it('should be created', inject([VulnLinesService], (service: VulnLinesService) => {
    expect(service).toBeTruthy()
  }))

  it('should submit solution for "Fit It" phase of coding challenge via the rest api', inject([VulnLinesService, HttpTestingController],
    fakeAsync((service: VulnLinesService, httpMock: HttpTestingController) => {
      let res: any
      service.check('testChallenge', [1, 2]).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/snippets/verdict')
      req.flush('apiResponse')

      tick()
      expect(req.request.method).toBe('POST')
      expect(req.request.body).toEqual({ key: 'testChallenge', selectedLines: [1, 2] })
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))
})


/* ===== FILE: ./frontend/src/app/Services/image-captcha.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { HttpClient } from '@angular/common/http'
import { environment } from '../../environments/environment'
import { Injectable } from '@angular/core'
import { catchError } from 'rxjs/operators'

@Injectable({
  providedIn: 'root'
})
export class ImageCaptchaService {
  private readonly hostServer = environment.hostServer

  constructor (private readonly http: HttpClient) { }

  getCaptcha () {
    return this.http.get(this.hostServer + '/rest/image-captcha/').pipe(catchError((err) => { throw err }))
  }
}


/* ===== FILE: ./frontend/src/app/Services/order-history.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing'
import { fakeAsync, inject, TestBed, tick } from '@angular/core/testing'
import { OrderHistoryService } from './order-history.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('OrderHistoryService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [],
      providers: [OrderHistoryService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
  })

  it('should be created', inject([OrderHistoryService], (service: OrderHistoryService) => {
    expect(service).toBeTruthy()
  }))

  it('should get payment cards directly from the api', inject([OrderHistoryService, HttpTestingController],
    fakeAsync((service: OrderHistoryService, httpMock: HttpTestingController) => {
      let res
      service.get().subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/rest/order-history')
      req.flush({ data: 'apiResponse' })
      tick()
      expect(req.request.method).toBe('GET')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should get payment cards directly from the api', inject([OrderHistoryService, HttpTestingController],
    fakeAsync((service: OrderHistoryService, httpMock: HttpTestingController) => {
      let res
      service.getAll().subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/rest/order-history/orders')
      req.flush({ data: 'apiResponse' })
      tick()
      expect(req.request.method).toBe('GET')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should update address directly from the api', inject([OrderHistoryService, HttpTestingController],
    fakeAsync((service: OrderHistoryService, httpMock: HttpTestingController) => {
      let res
      service.toggleDeliveryStatus(1, {}).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/rest/order-history/1/delivery-status')
      req.flush({ data: 'apiResponse' })
      tick()
      expect(req.request.method).toBe('PUT')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))
})


/* ===== FILE: ./frontend/src/app/Services/recycle.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing'
import { fakeAsync, inject, TestBed, tick } from '@angular/core/testing'

import { RecycleService } from './recycle.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('RecycleService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [],
      providers: [RecycleService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
  })

  it('should be created', inject([RecycleService], (service: RecycleService) => {
    expect(service).toBeTruthy()
  }))

  it('should find the recycle directly from the rest api', inject([RecycleService, HttpTestingController],
    fakeAsync((service: RecycleService, httpMock: HttpTestingController) => {
      let res: any
      service.find().subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/api/Recycles/')
      req.flush({ data: 'apiResponse' })

      tick()
      expect(req.request.method).toBe('GET')
      expect(req.request.params.toString()).toBeFalsy()
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should create recycle directly via the rest api', inject([RecycleService, HttpTestingController],
    fakeAsync((service: RecycleService, httpMock: HttpTestingController) => {
      let res: any
      service.save(1).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/api/Recycles/')
      req.flush({ data: 'apiResponse' })

      tick()
      expect(req.request.method).toBe('POST')
      expect(req.request.body).toBe(1)
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))
})


/* ===== FILE: ./frontend/src/app/Services/basket.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing'
import { fakeAsync, inject, TestBed, tick } from '@angular/core/testing'

import { BasketService } from './basket.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('BasketService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [],
      providers: [BasketService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
  })

  it('should be created', inject([BasketService], (service: BasketService) => {
    expect(service).toBeTruthy()
  }))

  it('should get basket directly from the rest api', inject([BasketService, HttpTestingController],
    fakeAsync((service: BasketService, httpMock: HttpTestingController) => {
      let res: any
      service.find(1).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/rest/basket/1')
      req.flush({ data: 'apiResponse' })
      tick()
      expect(req.request.method).toBe('GET')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should get single basket item directly from the rest api', inject([BasketService, HttpTestingController],
    fakeAsync((service: BasketService, httpMock: HttpTestingController) => {
      let res: any
      service.get(1).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/api/BasketItems/1')
      req.flush({ data: 'apiResponse' })
      tick()
      expect(req.request.method).toBe('GET')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should create basket item directly from the rest api', inject([BasketService, HttpTestingController],
    fakeAsync((service: BasketService, httpMock: HttpTestingController) => {
      let res: any
      service.save().subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/api/BasketItems/')
      req.flush({ data: 'apiResponse' })
      tick()
      expect(req.request.method).toBe('POST')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should update basket item directly from the rest api', inject([BasketService, HttpTestingController],
    fakeAsync((service: BasketService, httpMock: HttpTestingController) => {
      let res: any
      service.put(1, {}).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/api/BasketItems/1')
      req.flush({ data: 'apiResponse' })
      tick()
      expect(req.request.method).toBe('PUT')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should delete basket item directly from the rest api', inject([BasketService, HttpTestingController],
    fakeAsync((service: BasketService, httpMock: HttpTestingController) => {
      let res: any
      service.del(1).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/api/BasketItems/1')
      req.flush({ data: 'apiResponse' })
      tick()
      expect(req.request.method).toBe('DELETE')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should place order for basket via the rest api', inject([BasketService, HttpTestingController],
    fakeAsync((service: BasketService, httpMock: HttpTestingController) => {
      let res: any
      service.checkout(1).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/rest/basket/1/checkout')
      req.flush({ orderConfirmation: 'apiResponse' })
      tick()
      expect(req.request.method).toBe('POST')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should apply coupon to basket via the rest api', inject([BasketService, HttpTestingController],
    fakeAsync((service: BasketService, httpMock: HttpTestingController) => {
      let res: any
      service.applyCoupon(1, '1234567890').subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/rest/basket/1/coupon/1234567890')
      req.flush({ discount: 'apiResponse' })
      tick()
      expect(req.request.method).toBe('PUT')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))
})


/* ===== FILE: ./frontend/src/app/Services/security-question.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing'
import { fakeAsync, inject, TestBed, tick } from '@angular/core/testing'

import { SecurityQuestionService } from './security-question.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('SecurityQuestionService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [],
      providers: [SecurityQuestionService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
  })

  it('should be created', inject([SecurityQuestionService], (service: SecurityQuestionService) => {
    expect(service).toBeTruthy()
  }))

  it('should get all challenges directly from the rest api', inject([SecurityQuestionService, HttpTestingController],
    fakeAsync((service: SecurityQuestionService, httpMock: HttpTestingController) => {
      let res: any
      service.find(null).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/api/SecurityQuestions/')
      req.flush({ data: 'apiResponse' })
      tick()

      expect(req.request.method).toBe('GET')
      expect(req.request.params.toString()).toBeFalsy()
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should get security question by user email directly from the rest api', inject([SecurityQuestionService, HttpTestingController],
    fakeAsync((service: SecurityQuestionService, httpMock: HttpTestingController) => {
      let res: any
      service.findBy('x@y.z').subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/rest/user/security-question?email=x@y.z')
      req.flush({ question: 'apiResponse' })
      tick()

      expect(req.request.method).toBe('GET')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))
})


/* ===== FILE: ./frontend/src/app/Services/socket-io.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { environment } from 'src/environments/environment'
import { Injectable, NgZone } from '@angular/core'
import { io, type Socket } from 'socket.io-client'

@Injectable({
  providedIn: 'root'
})
export class SocketIoService {
  private _socket: Socket

  constructor (private readonly ngZone: NgZone) {
    this.ngZone.runOutsideAngular(() => {
      if (environment.hostServer === '.') {
        this._socket = io(window.location.origin, {
          path: (window.location.pathname.endsWith('/') ? window.location.pathname : window.location.pathname + '/') + 'socket.io'
        })
      } else {
        this._socket = io(environment.hostServer)
      }
    })
  }

  socket () {
    return this._socket
  }
}


/* ===== FILE: ./frontend/src/app/Services/data-subject.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing'
import { fakeAsync, inject, TestBed, tick } from '@angular/core/testing'
import { DataSubjectService } from './data-subject.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('DataSubjectService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [],
      providers: [DataSubjectService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
  })

  it('should be created', inject([DataSubjectService], (service: DataSubjectService) => {
    expect(service).toBeTruthy()
  }))

  it('should pass the erasure request directly to the rest API', inject([DataSubjectService, HttpTestingController],
    fakeAsync((service: DataSubjectService, httpMock: HttpTestingController) => {
      let res: any
      service.erase({}).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/rest/user/erasure-request')
      req.flush('apiResponse')

      tick()

      expect(req.request.method).toBe('POST')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))

  it('should request data export directly from the rest api', inject([DataSubjectService, HttpTestingController],
    fakeAsync((service: DataSubjectService, httpMock: HttpTestingController) => {
      let res: any
      service.dataExport(1).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/rest/user/data-export')
      req.flush('apiResponse')

      tick()
      expect(req.request.method).toBe('POST')
      expect(req.request.body).toBe(1)
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))
})


/* ===== FILE: ./frontend/src/app/Services/security-question.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { HttpClient } from '@angular/common/http'
import { Injectable } from '@angular/core'
import { environment } from 'src/environments/environment'
import { catchError, map } from 'rxjs/operators'

@Injectable({
  providedIn: 'root'
})
export class SecurityQuestionService {
  private readonly hostServer = environment.hostServer
  private readonly host = this.hostServer + '/api/SecurityQuestions'

  constructor (private readonly http: HttpClient) { }

  find (params: any) {
    return this.http.get(this.host + '/', { params }).pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }

  findBy (email: string) {
    return this.http.get(this.hostServer + '/' + 'rest/user/security-question?email=' + email).pipe(
      map((response: any) => response.question),
      catchError((error) => { throw error })
    )
  }
}


/* ===== FILE: ./frontend/src/app/Services/product.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { environment } from '../../environments/environment'
import { Injectable } from '@angular/core'
import { HttpClient } from '@angular/common/http'
import { catchError, map } from 'rxjs/operators'

@Injectable({
  providedIn: 'root'
})
export class ProductService {
  private readonly hostServer = environment.hostServer
  private readonly host = this.hostServer + '/api/Products'

  constructor (private readonly http: HttpClient) { }

  search (criteria: string) {
    return this.http.get(`${this.hostServer}/rest/products/search?q=${criteria}`).pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }

  find (params: any) {
    return this.http.get(this.host + '/', { params }).pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }

  get (id: number) {
    return this.http.get(`${this.host}/${id}?d=${encodeURIComponent(new Date().toDateString())}`).pipe(map((response: any) =>
      response.data), catchError((err) => { throw err }))
  }

  put (id: number, params) {
    return this.http.put(`${this.host}/${id}`, params).pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }
}


/* ===== FILE: ./frontend/src/app/Services/security-answer.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing'
import { fakeAsync, inject, TestBed, tick } from '@angular/core/testing'

import { SecurityAnswerService } from './security-answer.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('SecurityAnswerService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [],
      providers: [SecurityAnswerService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
  })

  it('should be created', inject([SecurityAnswerService], (service: SecurityAnswerService) => {
    expect(service).toBeTruthy()
  }))

  it('should create feedback directly via the rest api', inject([SecurityAnswerService, HttpTestingController],
    fakeAsync((service: SecurityAnswerService, httpMock: HttpTestingController) => {
      let res: any
      service.save(null).subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/api/SecurityAnswers/')
      req.flush({ data: 'apiResponse' })

      tick()
      expect(req.request.method).toBe('POST')
      expect(req.request.body).toBeFalsy()
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))
})


/* ===== FILE: ./frontend/src/app/Services/code-snippet.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { environment } from '../../environments/environment'
import { Injectable } from '@angular/core'
import { HttpClient } from '@angular/common/http'
import { catchError, map } from 'rxjs/operators'
import { type Observable } from 'rxjs'

export interface CodeSnippet {
  vulnLines?: number[]
  snippet: string
}

export interface Solved {
  challenges: string[]
}

@Injectable({
  providedIn: 'root'
})
export class CodeSnippetService {
  private readonly hostServer = environment.hostServer
  private readonly host = this.hostServer + '/snippets'

  constructor (private readonly http: HttpClient) { }

  get (key: string): Observable<CodeSnippet> {
    return this.http.get<CodeSnippet>(`${this.host}/${key}`).pipe(map((response: CodeSnippet) => response), catchError((err) => { throw err }))
  }
}


/* ===== FILE: ./frontend/src/app/Services/address.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { environment } from '../../environments/environment'
import { Injectable } from '@angular/core'
import { HttpClient } from '@angular/common/http'
import { catchError, map } from 'rxjs/operators'

@Injectable({
  providedIn: 'root'
})
export class AddressService {
  private readonly hostServer = environment.hostServer
  private readonly host = this.hostServer + '/api/Addresss'

  constructor (private readonly http: HttpClient) { }

  get () {
    return this.http.get(this.host).pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }

  getById (id) {
    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
    return this.http.get(`${this.host}/${id}`).pipe(map((response: any) => response.data), catchError((err: Error) => { throw err }))
  }

  save (params) {
    return this.http.post(this.host + '/', params).pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }

  put (id, params) {
    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
    return this.http.put(`${this.host}/${id}`, params).pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }

  del (id: number) {
    return this.http.delete(`${this.host}/${id}`).pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }
}


/* ===== FILE: ./frontend/src/app/Services/recycle.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { environment } from '../../environments/environment'
import { HttpClient } from '@angular/common/http'
import { Injectable } from '@angular/core'
import { catchError, map } from 'rxjs/operators'

@Injectable({
  providedIn: 'root'
})
export class RecycleService {
  private readonly hostServer = environment.hostServer
  private readonly host = this.hostServer + '/api/Recycles'

  constructor (private readonly http: HttpClient) { }

  find (params?: any) {
    return this.http.get(this.host + '/', {
      params
    }).pipe(map((response: any) => response.data), catchError((error) => { throw error }))
  }

  save (params: any) {
    return this.http.post(this.host + '/', params).pipe(map((response: any) => response.data), catchError((error) => { throw error }))
  }
}


/* ===== FILE: ./frontend/src/app/Services/photo-wall.service.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { environment } from '../../environments/environment'
import { Injectable } from '@angular/core'
import { HttpClient } from '@angular/common/http'
import { catchError, map } from 'rxjs/operators'

@Injectable({
  providedIn: 'root'
})
export class PhotoWallService {
  private readonly hostServer = environment.hostServer
  private readonly host = this.hostServer + '/rest/memories'

  constructor (private readonly http: HttpClient) { }

  addMemory (caption: string, image: File) {
    const postData = new FormData()
    postData.append('image', image, caption)
    postData.append('caption', caption)
    return this.http.post(this.host, postData).pipe(map((response: any) => response.data), catchError((err) => { throw err }))
  }

  get () {
    return this.http.get(this.host + '/').pipe(map((response: any) => response.data), catchError((err: Error) => { throw err }))
  }
}


/* ===== FILE: ./frontend/src/app/Services/administration.service.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { HttpTestingController, provideHttpClientTesting } from '@angular/common/http/testing'
import { fakeAsync, inject, TestBed, tick } from '@angular/core/testing'

import { AdministrationService } from './administration.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('AdministrationService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [],
      providers: [AdministrationService, provideHttpClient(withInterceptorsFromDi()), provideHttpClientTesting()]
    })
  })

  it('should be created', inject([AdministrationService], (service: AdministrationService) => {
    expect(service).toBeTruthy()
  }))

  it('should get application version directly from the rest api', inject([AdministrationService, HttpTestingController],
    fakeAsync((service: AdministrationService, httpMock: HttpTestingController) => {
      let res: any
      service.getApplicationVersion().subscribe((data) => (res = data))
      const req = httpMock.expectOne('http://localhost:3000/rest/admin/application-version')
      req.flush({ version: 'apiResponse' })
      tick()

      expect(req.request.method).toBe('GET')
      expect(res).toBe('apiResponse')
      httpMock.verify()
    })
  ))
})


/* ===== FILE: ./frontend/src/app/welcome-banner/welcome-banner.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<h1>{{title}}</h1>
<div class="text-justify" [innerHtml]="message"></div>
<div class="button-footer">
  <button
    *ngIf="showHackingInstructor"
    mat-raised-button color="warn"
    (click)="startHackingInstructor()"
    [matTooltip]="('SCORE_BOARD_HACKING_INSTRUCTOR' | translate)"
    matTooltipPosition="above">
    <mat-icon>
      school
    </mat-icon>
    <span fxShow fxHide.lt-lg>{{"BTN_GETTING_STARTED" | translate}}</span>
  </button>
  <button mat-raised-button class="close-dialog" (click)="closeWelcome()" color="primary"
          *ngIf="showDismissBtn"
          aria-label="Close Welcome Banner">
    <mat-icon>
      visibility_off
    </mat-icon>
    <span fxShow fxHide.lt-sm>{{"BTN_DISMISS" | translate }}</span>
  </button>
</div>


/* ===== FILE: ./frontend/src/app/welcome-banner/welcome-banner.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateModule } from '@ngx-translate/core'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { CookieModule, CookieService } from 'ngy-cookie'

import { type ComponentFixture, fakeAsync, TestBed, waitForAsync } from '@angular/core/testing'

import { WelcomeBannerComponent } from './welcome-banner.component'
import { MatDialogRef } from '@angular/material/dialog'
import { MatIconModule } from '@angular/material/icon'
import { MatTooltipModule } from '@angular/material/tooltip'
import { of, throwError } from 'rxjs'
import { ConfigurationService } from '../Services/configuration.service'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('WelcomeBannerComponent', () => {
  let component: WelcomeBannerComponent
  let fixture: ComponentFixture<WelcomeBannerComponent>
  let cookieService: any
  let matDialogRef: MatDialogRef<WelcomeBannerComponent>
  let configurationService: any

  beforeEach(waitForAsync(() => {
    configurationService = jasmine.createSpyObj('ConfigurationService', ['getApplicationConfiguration'])
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { } }))
    matDialogRef = jasmine.createSpyObj('MatDialogRef', ['close'])
    TestBed.configureTestingModule({
      imports: [TranslateModule.forRoot(),
        CookieModule.forRoot(),
        MatIconModule,
        MatTooltipModule,
        WelcomeBannerComponent],
      providers: [
        { provide: MatDialogRef, useValue: matDialogRef },
        { provide: ConfigurationService, useValue: configurationService },
        CookieService,
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()

    cookieService = TestBed.inject(CookieService)
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(WelcomeBannerComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should not dismiss if cookie not set', () => {
    component.ngOnInit()
    expect(matDialogRef.close).toHaveBeenCalledTimes(0)
  })

  it('should dismiss and add cookie when closed', () => {
    component.closeWelcome()
    expect(cookieService.get('welcomebanner_status')).toBe('dismiss')
    expect(matDialogRef.close).toHaveBeenCalled()
  })

  it('should dismiss and add cookie when starting hacking instructor', () => {
    component.startHackingInstructor()
    expect(cookieService.get('welcomebanner_status')).toBe('dismiss')
    expect(matDialogRef.close).toHaveBeenCalled()
  })

  it('should set banner properties as obtained from configuration', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({ application: { welcomeBanner: { title: 'Title', message: 'Message' } } }))
    component.ngOnInit()

    expect(component.title).toBe('Title')
    expect(component.message).toBe('Message')
  })

  it('should show hacking instructor if enabled in configuration', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({ hackingInstructor: { isEnabled: true } }))
    component.ngOnInit()

    expect(component.showHackingInstructor).toBe(true)
  })

  it('should prevent dismissing banner in tutorial mode', () => {
    configurationService.getApplicationConfiguration.and.returnValue(of({ challenges: { restrictToTutorialsFirst: true }, hackingInstructor: { isEnabled: true } }))
    component.ngOnInit()

    expect(component.dialogRef.disableClose).toBe(true)
    expect(component.showDismissBtn).toBe(false)
  })

  it('should log error on failure in retrieving configuration from backend', fakeAsync(() => {
    configurationService.getApplicationConfiguration.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.ngOnInit()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))
})


/* ===== FILE: ./frontend/src/app/welcome-banner/welcome-banner.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Component, type OnInit } from '@angular/core'
import { ConfigurationService } from '../Services/configuration.service'
import { MatDialogRef } from '@angular/material/dialog'
import { CookieService } from 'ngy-cookie'
import { TranslateModule } from '@ngx-translate/core'
import { ExtendedModule } from '@angular/flex-layout/extended'
import { MatIconModule } from '@angular/material/icon'
import { MatTooltip } from '@angular/material/tooltip'
import { MatButtonModule } from '@angular/material/button'
import { NgIf } from '@angular/common'

@Component({
  selector: 'app-welcome-banner',
  templateUrl: 'welcome-banner.component.html',
  styleUrls: ['./welcome-banner.component.scss'],
  imports: [NgIf, MatButtonModule, MatTooltip, MatIconModule, ExtendedModule, TranslateModule]
})
export class WelcomeBannerComponent implements OnInit {
  public title: string = 'Welcome to OWASP Juice Shop'
  public message: string = "<p>Being a web application with a vast number of intended security vulnerabilities, the <strong>OWASP Juice Shop</strong> is supposed to be the opposite of a best practice or template application for web developers: It is an awareness, training, demonstration and exercise tool for security risks in modern web applications. The <strong>OWASP Juice Shop</strong> is an open-source project hosted by the non-profit <a href='https://owasp.org' target='_blank'>Open Worldwide Application Security Project (OWASP)</a> and is developed and maintained by volunteers. Check out the link below for more information and documentation on the project.</p><h1><a href='https://owasp-juice.shop' target='_blank'>https://owasp-juice.shop</a></h1>"
  public showHackingInstructor: boolean = true
  public showDismissBtn: boolean = true

  private readonly welcomeBannerStatusCookieKey = 'welcomebanner_status'

  constructor (
    public dialogRef: MatDialogRef<WelcomeBannerComponent>,
    private readonly configurationService: ConfigurationService,
    private readonly cookieService: CookieService) { }

  ngOnInit (): void {
    this.configurationService.getApplicationConfiguration().subscribe((config) => {
      if (config?.application?.welcomeBanner) {
        this.title = config.application.welcomeBanner.title
        this.message = config.application.welcomeBanner.message
      }
      this.showHackingInstructor = config?.hackingInstructor?.isEnabled
      // Don't allow to skip the tutorials when restrictToTutorialsFirst and showHackingInstructor are enabled
      if (this.showHackingInstructor && config?.challenges?.restrictToTutorialsFirst) {
        this.dialogRef.disableClose = true
        this.showDismissBtn = false
      }
    }, (err) => { console.log(err) })
  }

  startHackingInstructor () {
    this.closeWelcome()
    console.log('Starting instructions for challenge "Score Board"')
    import(/* webpackChunkName: "tutorial" */ '../../hacking-instructor').then(module => {
      module.startHackingInstructorFor('Score Board')
    })
  }

  closeWelcome (): void {
    this.dialogRef.close()
    const expires = new Date()
    expires.setFullYear(expires.getFullYear() + 1)
    this.cookieService.put(this.welcomeBannerStatusCookieKey, 'dismiss', { expires })
  }
}


/* ===== FILE: ./frontend/src/app/order-history/order-history.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Component, NgZone, type OnInit } from '@angular/core'
import { OrderHistoryService } from '../Services/order-history.service'
import { MatTableDataSource, MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow } from '@angular/material/table'
import { BasketService } from '../Services/basket.service'
import { ProductDetailsComponent } from '../product-details/product-details.component'
import { MatDialog } from '@angular/material/dialog'
import { type Product } from '../Models/product.model'
import { ProductService } from '../Services/product.service'
import { Router } from '@angular/router'
import { MatIconModule } from '@angular/material/icon'
import { MatTooltip } from '@angular/material/tooltip'
import { MatIconButton } from '@angular/material/button'
import { TranslateModule } from '@ngx-translate/core'
import { FlexModule } from '@angular/flex-layout/flex'
import { NgIf, NgFor } from '@angular/common'
import { MatCardModule, MatCardTitle, MatCardContent } from '@angular/material/card'

export interface StrippedProduct {
  id: number
  name: string
  price: number
  quantity: number
  total: number
}

export interface Order {
  orderId: string
  totalPrice: number
  bonus: number
  products: MatTableDataSource<StrippedProduct>
  delivered: boolean
}

@Component({
  selector: 'app-order-history',
  templateUrl: './order-history.component.html',
  styleUrls: ['./order-history.component.scss'],
  imports: [MatCardModule, MatCardTitle, NgIf, FlexModule, NgFor, TranslateModule, MatIconButton, MatTooltip, MatIconModule, MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow, MatCardContent]
})
export class OrderHistoryComponent implements OnInit {
  public tableColumns = ['product', 'price', 'quantity', 'total price', 'review']
  public orders: Order[] = []
  public emptyState: boolean = true

  constructor (private readonly router: Router, private readonly dialog: MatDialog, private readonly orderHistoryService: OrderHistoryService, private readonly basketService: BasketService, private readonly productService: ProductService, private readonly ngZone: NgZone) { }

  ngOnInit (): void {
    this.orderHistoryService.get().subscribe((orders) => {
      orders = orders.reverse()
      if (orders.length === 0) {
        this.emptyState = true
      } else {
        this.emptyState = false
      }
      for (const order of orders) {
        const products: StrippedProduct[] = []
        for (const product of order.products) {
          products.push({
            id: product.id,
            name: product.name,
            price: product.price,
            quantity: product.quantity,
            total: product.total
          })
        }
        this.orders.push({
          orderId: order.orderId,
          totalPrice: order.totalPrice,
          bonus: order.bonus,
          products: new MatTableDataSource<StrippedProduct>(products),
          delivered: order.delivered
        })
      }
    }, (err) => { console.log(err) })
  }

  showDetail (id: number) {
    this.productService.get(id).subscribe((product) => {
      const element: Product = {
        id: product.id,
        name: product.name,
        description: product.description,
        image: product.image,
        price: product.price,
        points: Math.round(product.price / 10)
      }
      this.dialog.open(ProductDetailsComponent, {
        width: '500px',
        height: 'max-content',
        data: {
          productData: element
        }
      })
    }, (err) => { console.log(err) })
  }

  openConfirmationPDF (orderId: string) {
    const redirectUrl = `${this.basketService.hostServer}/ftp/order_${orderId}.pdf`
    window.open(redirectUrl, '_blank')
  }

  trackOrder (orderId) {
    this.ngZone.run(async () => await this.router.navigate(['/track-result'], {
      queryParams: {
        id: orderId
      }
    }))
  }
}


/* ===== FILE: ./frontend/src/app/order-history/order-history.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
-->

<mat-card appearance="outlined" class="card1 mat-elevation-z6 ">
  <div class="mdc-card mat-card-cvr">
    <mat-card-title>
      {{"LABEL_ORDER_HISTORY" | translate}}
    </mat-card-title>
    <div *ngIf="!emptyState; else emptyResult" fxLayout="column" fxLayoutGap="20px">
      <div *ngFor="let order of orders">
        <div class="table-container mat-elevation-z4 custom-slate">
          <div class="heading">
            <div fxLayout="row">
              <div fxFlex="40%" fxLayout="column">
                <div>{{"LABEL_ORDER_ID" | translate}}</div>
                <div>#{{ order.orderId }}</div>
              </div>
              <div fxFlex="15%" fxLayout="column">
                <div>{{"LABEL_TOTAL_PRICE" | translate}}</div>
                <div>{{ order.totalPrice.toFixed(2) }}&curren;</div>
              </div>
              <div fxFlex="15%" fxLayout="column">
                <div >{{"LABEL_BONUS" | translate}}</div>
                <div>{{ order.bonus }}</div>
              </div>
              <div fxFlex="20%">
                <div *ngIf="!order.delivered" class="error">{{"LABEL_IN_TRANSIT" | translate}}</div>
                <div *ngIf="order.delivered" class="confirmation" > {{"LABEL_DELIVERED" | translate}}</div>
              </div>
              <div fxFlex="5%" fxLayoutAlign="end">
                <button mat-icon-button aria-label="Track Your Order" matTooltip="{{ 'LABEL_TRACK_ORDER' | translate }}" matTooltipPosition="below" (click)= "trackOrder(order.orderId)">
                  <mat-icon>
                    local_shipping
                  </mat-icon>
                </button>
              </div>
              <div fxFlex="5%" fxLayoutAlign="end">
                <button mat-icon-button aria-label="Print order confirmation" matTooltip="{{ 'PRINT_ORDER_CONFIRMATION' | translate }}" matTooltipPosition="below" (click)= "openConfirmationPDF(order.orderId)">
                  <mat-icon>
                    note
                  </mat-icon>
                </button>
              </div>
            </div>
            <div class="border"></div>
          </div>
          <mat-table [dataSource]="order.products">
            <ng-container matColumnDef="product">
              <mat-header-cell *matHeaderCellDef  fxFlex="40%">{{"LABEL_PRODUCT" | translate}}</mat-header-cell>
              <mat-cell *matCellDef="let element" fxFlex="40%">{{element.name}} </mat-cell>
            </ng-container>
            <ng-container matColumnDef="price">
              <mat-header-cell *matHeaderCellDef  fxFlex="15%">{{"LABEL_PRICE" | translate}}</mat-header-cell>
              <mat-cell *matCellDef="let element" fxFlex="15%">{{element.price}}&curren;</mat-cell>
            </ng-container>
            <ng-container matColumnDef="quantity">
              <mat-header-cell *matHeaderCellDef  fxFlex="15%">{{"LABEL_QUANTITY" | translate}}</mat-header-cell>
              <mat-cell *matCellDef="let element" fxFlex="15%">
                <span>{{element.quantity}}</span>
              </mat-cell>
            </ng-container>
            <ng-container matColumnDef="total price">
              <mat-header-cell *matHeaderCellDef  fxFlex="15%">{{"LABEL_TOTAL_PRICE" | translate}}</mat-header-cell>
              <mat-cell *matCellDef="let element" class="price-align" fxFlex="13%">{{ (element.total).toFixed(2) }}&curren;</mat-cell>
            </ng-container>
            <ng-container matColumnDef="review">
              <mat-header-cell *matHeaderCellDef fxFlex="15%"> </mat-header-cell>
              <mat-cell *matCellDef="let element" fxFlex="15%">
                <button mat-icon-button aria-label="Print order confirmation" matTooltip="{{ 'WRITE_REVIEW' | translate }}" matTooltipPosition="below"
                (click)= "showDetail(element.id)">
                  <mat-icon>
                    rate_review
                  </mat-icon>
                </button>
              </mat-cell>
            </ng-container>
            <mat-header-row *matHeaderRowDef="tableColumns"></mat-header-row>
            <mat-row *matRowDef="let row; columns: tableColumns;"></mat-row>
          </mat-table>
        </div>
      </div>
    </div>
    <ng-template #emptyResult>
      <mat-card appearance="outlined" class="mat-elevation-z6 emptyState">
        <div class="mdc-card">
          <img alt="No results found"
          class="img-responsive noResult"
          src="assets/public/images/products/no-results.png">
          <mat-card-title>
            <span class="noResultText">
              {{"NO_SEARCH_RESULT" | translate}}
            </span>
          </mat-card-title>
          <mat-card-content>
            <span class="noResultText" translate>
              {{"NO_ORDERS_PLACED" | translate}}
            </span>
          </mat-card-content>
        </div>
      </mat-card>
    </ng-template>
  </div>
</mat-card>

/* ===== FILE: ./frontend/src/app/order-history/order-history.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateModule } from '@ngx-translate/core'
import { MatDividerModule } from '@angular/material/divider'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { type ComponentFixture, fakeAsync, TestBed, waitForAsync } from '@angular/core/testing'
import { ProductService } from '../Services/product.service'
import { RouterTestingModule } from '@angular/router/testing'
import { MatGridListModule } from '@angular/material/grid-list'
import { MatCardModule } from '@angular/material/card'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'
import { MatTableModule } from '@angular/material/table'
import { MatPaginatorModule } from '@angular/material/paginator'
import { of } from 'rxjs'
import { MatFormFieldModule } from '@angular/material/form-field'
import { throwError } from 'rxjs/internal/observable/throwError'
import { OrderHistoryService } from '../Services/order-history.service'
import { OrderHistoryComponent } from './order-history.component'
import { type Product } from '../Models/product.model'
import { ProductDetailsComponent } from '../product-details/product-details.component'
import { MatIconModule } from '@angular/material/icon'
import { MatTooltipModule } from '@angular/material/tooltip'
import { MatDialog, MatDialogModule } from '@angular/material/dialog'
import { MatExpansionModule } from '@angular/material/expansion'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('AccountingComponent', () => {
  let component: OrderHistoryComponent
  let fixture: ComponentFixture<OrderHistoryComponent>
  let productService
  let orderHistoryService
  let dialog: any

  beforeEach(waitForAsync(() => {
    dialog = jasmine.createSpyObj('MatDialog', ['open'])
    dialog.open.and.returnValue(null)
    productService = jasmine.createSpyObj('ProductService', ['get'])
    productService.get.and.returnValue(of({}))
    orderHistoryService = jasmine.createSpyObj('OrderHistoryService', ['get'])
    orderHistoryService.get.and.returnValue(of([]))

    TestBed.configureTestingModule({
      imports: [RouterTestingModule,
        TranslateModule.forRoot(),
        BrowserAnimationsModule,
        MatTableModule,
        MatPaginatorModule,
        MatFormFieldModule,
        MatDividerModule,
        MatGridListModule,
        MatCardModule,
        MatIconModule,
        MatTooltipModule,
        MatDialogModule,
        MatExpansionModule,
        OrderHistoryComponent],
      providers: [
        { provide: ProductService, useValue: productService },
        { provide: OrderHistoryService, useValue: orderHistoryService },
        { provide: MatDialog, useValue: dialog },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(OrderHistoryComponent)
    component = fixture.componentInstance
    component.ngOnInit()
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should make emptyState true and hold no orders when get Order History gives empty response', () => {
    orderHistoryService.get.and.returnValue(of([]))
    component.ngOnInit()
    expect(component.emptyState).toBe(true)
    expect(component.orders).toEqual([])
  })

  it('should make emptyState false when get Order History gives non empty response', () => {
    orderHistoryService.get.and.returnValue(of([{ orderId: 'a', totalPrice: 1, bonus: 0, products: [{}], delivered: true }]))
    component.ngOnInit()
    expect(component.emptyState).toBe(false)
  })

  it('should log error from get order history API call directly to browser console', fakeAsync(() => {
    orderHistoryService.get.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.ngOnInit()
    fixture.detectChanges()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should log error from get product API call directly to browser console', fakeAsync(() => {
    productService.get.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.showDetail(1)
    fixture.detectChanges()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should open a modal dialog when showDetail is called', () => {
    productService.get.and.returnValue(of({ id: 42, name: 'A', description: 'B', image: 'C', price: 10 } as Product))
    component.showDetail(42)
    expect(productService.get).toHaveBeenCalled()
    expect(dialog.open).toHaveBeenCalledWith(ProductDetailsComponent, {
      width: '500px',
      height: 'max-content',
      data: {
        productData: { id: 42, name: 'A', description: 'B', image: 'C', price: 10, points: 1 }
      }
    })
  })
})


/* ===== FILE: ./frontend/src/app/challenge-status-badge/challenge-status-badge.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<button *ngIf="!challenge.disabledEnv && challenge.solved"
        [id]="challenge.name + '.solved'"
        mat-raised-button color="accent"
        (click)="repeatNotification()"
        [matTooltip]="allowRepeatNotifications ? ('NOTIFICATION_RESEND_INSTRUCTIONS' | translate) : null"
        matTooltipPosition="above">
            <mat-icon [hidden]="!allowRepeatNotifications">flag</mat-icon>
            <mat-icon [hidden]="allowRepeatNotifications">check_box</mat-icon>
            <span fxShow fxHide.lt-lg>{{'STATUS_SOLVED' | translate}}</span>
</button>

<button *ngIf="!challenge.disabledEnv && !challenge.solved"
        [id]="challenge.name + '.notSolved'"
        mat-raised-button color="primary"
        (click)="openHint()"
        [matTooltip]="showChallengeHints ? challenge.hint : null"
        matTooltipPosition="above">
            <mat-icon [hidden]="!showChallengeHints || !challenge.hintUrl">book</mat-icon>
            <mat-icon [hidden]="showChallengeHints && challenge.hintUrl">check_box_outline_blank</mat-icon>
            <span fxShow fxHide.lt-lg>{{'STATUS_UNSOLVED' | translate}}</span>
</button>

<button *ngIf="challenge.disabledEnv" [id]="challenge.name + '.unavailable'" mat-raised-button
        [matTooltip]="challenge.hint" matTooltipPosition="above">
  <span>
    <i *ngIf="challenge.disabledEnv !== 'Windows'" class="{{ 'icon-' + challenge.disabledEnv?.toString().toLowerCase() }}"></i>
    <i *ngIf="challenge.disabledEnv === 'Windows'" class="{{ 'fab fa-' + challenge.disabledEnv?.toString().toLowerCase() }}"></i>
    {{'STATUS_UNAVAILABLE' | translate}}
  </span>
</button>


/* ===== FILE: ./frontend/src/app/challenge-status-badge/challenge-status-badge.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Component, Input } from '@angular/core'
import { WindowRefService } from '../Services/window-ref.service'
import { ChallengeService } from '../Services/challenge.service'
import { library } from '@fortawesome/fontawesome-svg-core'
import { faWindows } from '@fortawesome/free-brands-svg-icons'

import { Challenge } from '../Models/challenge.model'
import { TranslateModule } from '@ngx-translate/core'
import { ExtendedModule } from '@angular/flex-layout/extended'
import { MatIconModule } from '@angular/material/icon'
import { MatTooltip } from '@angular/material/tooltip'
import { MatButtonModule } from '@angular/material/button'
import { NgIf } from '@angular/common'

library.add(faWindows)

@Component({
  selector: 'app-challenge-status-badge',
  templateUrl: './challenge-status-badge.component.html',
  styleUrls: ['./challenge-status-badge.component.scss'],
  imports: [NgIf, MatButtonModule, MatTooltip, MatIconModule, ExtendedModule, TranslateModule]
})
export class ChallengeStatusBadgeComponent {
  @Input() public challenge: Challenge = { } as Challenge
  @Input() public allowRepeatNotifications: boolean = false
  @Input() public showChallengeHints: boolean = true

  constructor (private readonly challengeService: ChallengeService, private readonly windowRefService: WindowRefService) { }

  repeatNotification () {
    if (this.allowRepeatNotifications) {
      this.challengeService.repeatNotification(encodeURIComponent(this.challenge.name)).subscribe(() => {
        this.windowRefService.nativeWindow.scrollTo(0, 0)
      }, (err) => { console.log(err) })
    }
  }

  openHint () {
    if (this.showChallengeHints && this.challenge.hintUrl) {
      this.windowRefService.nativeWindow.open(this.challenge.hintUrl, '_blank')
    }
  }
}


/* ===== FILE: ./frontend/src/app/challenge-status-badge/challenge-status-badge.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { ChallengeService } from '../Services/challenge.service'
import { type ComponentFixture, fakeAsync, TestBed, waitForAsync } from '@angular/core/testing'

import { ChallengeStatusBadgeComponent } from './challenge-status-badge.component'
import { of, throwError } from 'rxjs'
import { TranslateModule, TranslateService } from '@ngx-translate/core'
import { WindowRefService } from '../Services/window-ref.service'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { MatIconModule } from '@angular/material/icon'
import { EventEmitter } from '@angular/core'
import { type Challenge } from '../Models/challenge.model'
import { MatButtonModule } from '@angular/material/button'
import { MatTooltipModule } from '@angular/material/tooltip'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('ChallengeStatusBadgeComponent', () => {
  let challengeService: any
  let translateService: any
  let windowRefService: any
  let component: ChallengeStatusBadgeComponent
  let fixture: ComponentFixture<ChallengeStatusBadgeComponent>

  beforeEach(waitForAsync(() => {
    challengeService = jasmine.createSpyObj('ChallengeService', ['repeatNotification'])
    challengeService.repeatNotification.and.returnValue(of({}))
    translateService = jasmine.createSpyObj('TranslateService', ['get'])
    translateService.get.and.returnValue(of({}))
    translateService.onLangChange = new EventEmitter()
    translateService.onTranslationChange = new EventEmitter()
    translateService.onDefaultLangChange = new EventEmitter()

    TestBed.configureTestingModule({
      imports: [TranslateModule.forRoot(),
        MatButtonModule,
        MatTooltipModule,
        MatIconModule,
        ChallengeStatusBadgeComponent],
      providers: [
        { provide: TranslateService, useValue: translateService },
        { provide: ChallengeService, useValue: challengeService },
        WindowRefService,
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()

    windowRefService = TestBed.inject(WindowRefService)
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(ChallengeStatusBadgeComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should show notification for selected challenge when enabled', () => {
    component.allowRepeatNotifications = true
    component.challenge = { name: 'Challenge #1', solved: true } as Challenge
    component.repeatNotification()
    expect(challengeService.repeatNotification).toHaveBeenCalledWith(encodeURIComponent('Challenge #1'))
  })

  it('should scroll to top of screen when notification is repeated', () => {
    component.allowRepeatNotifications = true
    component.challenge = { name: 'Challenge #1', solved: true } as Challenge
    spyOn(windowRefService.nativeWindow, 'scrollTo')
    component.repeatNotification()
    expect(windowRefService.nativeWindow.scrollTo).toHaveBeenCalledWith(0, 0)
  })

  it('should log the error from backend on failing to repeat notification', fakeAsync(() => {
    component.allowRepeatNotifications = true
    component.challenge = { name: 'Challenge #1', solved: true } as Challenge
    challengeService.repeatNotification.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.repeatNotification()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should happen when challenge has a hint URL', () => {
    component.showChallengeHints = true
    component.challenge = { name: 'Challenge #1', hintUrl: 'hint://c1.test' } as Challenge
    spyOn(windowRefService.nativeWindow, 'open')
    component.openHint()
    expect(windowRefService.nativeWindow.open).toHaveBeenCalledWith('hint://c1.test', '_blank')
  })

  it('should not happen when challenge has no hint URL', () => {
    component.showChallengeHints = true
    component.challenge = { name: 'Challenge #2' } as Challenge
    spyOn(windowRefService.nativeWindow, 'open')
    component.openHint()
    expect(windowRefService.nativeWindow.open).not.toHaveBeenCalled()
  })

  it('should not happen when hints are not turned on in configuration', () => {
    component.showChallengeHints = false
    component.challenge = { name: 'Challenge #1', hintUrl: 'hint://c1.test' } as Challenge
    spyOn(windowRefService.nativeWindow, 'open')
    component.openHint()
    expect(windowRefService.nativeWindow.open).not.toHaveBeenCalled()
  })
})


/* ===== FILE: ./frontend/src/app/purchase-basket/purchase-basket.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateModule, TranslateService } from '@ngx-translate/core'
import { MatInputModule } from '@angular/material/input'
import { BasketService } from '../Services/basket.service'
import { type ComponentFixture, fakeAsync, TestBed, waitForAsync } from '@angular/core/testing'
import { MatCardModule } from '@angular/material/card'
import { MatTableModule } from '@angular/material/table'
import { MatButtonModule } from '@angular/material/button'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { ReactiveFormsModule } from '@angular/forms'
import { of } from 'rxjs'
import { throwError } from 'rxjs/internal/observable/throwError'
import { MatButtonToggleModule } from '@angular/material/button-toggle'
import { PurchaseBasketComponent } from '../purchase-basket/purchase-basket.component'
import { UserService } from '../Services/user.service'
import { DeluxeGuard } from '../app.guard'
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar'
import { EventEmitter } from '@angular/core'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

describe('PurchaseBasketComponent', () => {
  let component: PurchaseBasketComponent
  let fixture: ComponentFixture<PurchaseBasketComponent>
  let basketService
  let userService
  let translateService: any
  let deluxeGuard
  let snackBar: any

  beforeEach(waitForAsync(() => {
    basketService = jasmine.createSpyObj('BasketService', ['find', 'del', 'get', 'put', 'updateNumberOfCartItems'])
    basketService.find.and.returnValue(of({ Products: [] }))
    basketService.del.and.returnValue(of({}))
    basketService.get.and.returnValue(of({}))
    basketService.put.and.returnValue(of({}))
    basketService.updateNumberOfCartItems.and.returnValue(of({}))
    userService = jasmine.createSpyObj('UserService', ['whoAmI'])
    userService.whoAmI.and.returnValue(of({}))
    translateService = jasmine.createSpyObj('TranslateService', ['get'])
    translateService.get.and.returnValue(of({}))
    translateService.onLangChange = new EventEmitter()
    translateService.onTranslationChange = new EventEmitter()
    translateService.onDefaultLangChange = new EventEmitter()
    deluxeGuard = jasmine.createSpyObj('', ['isDeluxe'])
    deluxeGuard.isDeluxe.and.returnValue(false)
    snackBar = jasmine.createSpyObj('MatSnackBar', ['open'])

    TestBed.configureTestingModule({
      imports: [TranslateModule.forRoot(),
        BrowserAnimationsModule,
        ReactiveFormsModule,
        MatInputModule,
        MatCardModule,
        MatTableModule,
        MatButtonModule,
        MatButtonToggleModule,
        MatSnackBarModule,
        PurchaseBasketComponent],
      providers: [
        { provide: TranslateService, useValue: translateService },
        { provide: BasketService, useValue: basketService },
        { provide: MatSnackBar, useValue: snackBar },
        { provide: UserService, useValue: userService },
        { provide: DeluxeGuard, useValue: deluxeGuard },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(PurchaseBasketComponent)
    component = fixture.componentInstance
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should load user email when being created', () => {
    userService.whoAmI.and.returnValue(of({ email: 'a@a' }))
    component.ngOnInit()
    expect(component.userEmail).toBe('(a@a)')
  })

  it('should log an error if userService fails to fetch the user', fakeAsync(() => {
    userService.whoAmI.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.ngOnInit()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should hold products returned by backend API', () => {
    basketService.find.and.returnValue(of({ Products: [{ name: 'Product1', price: 1, deluxePrice: 1, BasketItem: { quantity: 1 } }, { name: 'Product2', price: 2, deluxePrice: 2, BasketItem: { quantity: 2 } }] }))
    component.load()
    expect(component.dataSource.length).toBe(2)
    expect(component.dataSource[0].name).toBe('Product1')
    expect(component.dataSource[0].price).toBe(1)
    expect(component.dataSource[0].BasketItem.quantity).toBe(1)
    expect(component.dataSource[1].name).toBe('Product2')
    expect(component.dataSource[1].price).toBe(2)
    expect(component.dataSource[1].BasketItem.quantity).toBe(2)
  })

  it('should have price equal to deluxePrice for deluxe users', () => {
    deluxeGuard.isDeluxe.and.returnValue(true)
    basketService.find.and.returnValue(of({ Products: [{ name: 'Product1', price: 2, deluxePrice: 1, BasketItem: { quantity: 1 } }] }))
    component.load()
    expect(component.dataSource.length).toBe(1)
    expect(component.dataSource[0].name).toBe('Product1')
    expect(component.dataSource[0].price).toBe(1)
  })

  it('should have price different from deluxePrice for non-deluxe users', () => {
    deluxeGuard.isDeluxe.and.returnValue(false)
    basketService.find.and.returnValue(of({ Products: [{ name: 'Product1', price: 2, deluxePrice: 1, BasketItem: { quantity: 1 } }] }))
    component.load()
    expect(component.dataSource.length).toBe(1)
    expect(component.dataSource[0].name).toBe('Product1')
    expect(component.dataSource[0].price).toBe(2)
  })

  it('should hold no products on error in backend API', fakeAsync(() => {
    basketService.find.and.returnValue(throwError('Error'))
    component.load()
    expect(component.dataSource.length).toBe(0)
  }))

  it('should hold no products when none are returned by backend API', () => {
    basketService.find.and.returnValue(of({ Products: [] }))
    component.load()
    expect(component.dataSource).toEqual([])
  })

  it('should log error while getting Products from backend API directly to browser console', fakeAsync(() => {
    basketService.find.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.load()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should pass delete request for basket item via BasketService', () => {
    component.delete(1)
    expect(basketService.del).toHaveBeenCalledWith(1)
  })

  it('should load again after deleting a basket item', () => {
    basketService.find.and.returnValue(of({ Products: [{ name: 'Product1', price: 1, deluxePrice: 1, BasketItem: { quantity: 1 } }, { name: 'Product2', price: 2, deluxePrice: 2, BasketItem: { quantity: 2 } }] }))
    component.delete(1)
    expect(component.dataSource.length).toBe(2)
    expect(component.dataSource[0].name).toBe('Product1')
    expect(component.dataSource[0].price).toBe(1)
    expect(component.dataSource[0].BasketItem.quantity).toBe(1)
    expect(component.dataSource[1].name).toBe('Product2')
    expect(component.dataSource[1].price).toBe(2)
    expect(component.dataSource[1].BasketItem.quantity).toBe(2)
  })

  it('should log error while deleting basket item directly to browser console', fakeAsync(() => {
    basketService.del.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.delete(1)
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should update basket item with increased quantity after adding another item of same type', () => {
    basketService.find.and.returnValue(of({ Products: [{ name: 'Product1', price: 1, deluxePrice: 1, BasketItem: { id: 1, quantity: 1 } }] }))
    basketService.get.and.returnValue(of({ id: 1, quantity: 1 }))
    component.inc(1)
    expect(basketService.get).toHaveBeenCalledWith(1)
    expect(basketService.put).toHaveBeenCalledWith(1, { quantity: 2 })
  })

  it('should not increase quantity on error retrieving basket item and log the error', fakeAsync(() => {
    basketService.get.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.inc(1)
    expect(console.log).toHaveBeenCalledWith('Error')
    expect(basketService.put).not.toHaveBeenCalled()
  }))

  it('should not increase quantity on error updating basket item and log the error', fakeAsync(() => {
    basketService.find.and.returnValue(of({ Products: [{ BasketItem: { id: 1, quantity: 1 } }] }))
    basketService.get.and.returnValue(of({ id: 1, quantity: 1 }))
    basketService.put.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.inc(1)
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should load again after increasing product quantity', () => {
    basketService.find.and.returnValue(of({ Products: [{ BasketItem: { id: 1, quantity: 2 } }] }))
    basketService.get.and.returnValue(of({ id: 1, quantity: 2 }))
    basketService.put.and.returnValue(of({ id: 1, quantity: 3 }))
    component.inc(1)
    expect(basketService.find).toHaveBeenCalled()
  })

  it('should update basket item with decreased quantity after removing an item', () => {
    basketService.find.and.returnValue(of({ Products: [{ BasketItem: { id: 1, quantity: 2 } }] }))
    basketService.get.and.returnValue(of({ id: 1, quantity: 2 }))
    basketService.put.and.returnValue(of({ id: 1, quantity: 1 }))
    component.dec(1)
    expect(basketService.get).toHaveBeenCalledWith(1)
    expect(basketService.put).toHaveBeenCalledWith(1, { quantity: 1 })
  })

  it('should always keep one item of any product in the basket when reducing quantity via UI', () => {
    basketService.find.and.returnValue(of({ Products: [{ BasketItem: { id: 1, quantity: 1 } }] }))
    basketService.get.and.returnValue(of({ id: 1, quantity: 1 }))
    basketService.put.and.returnValue(of({ id: 1, quantity: 1 }))
    component.dec(1)
    expect(basketService.get).toHaveBeenCalledWith(1)
    expect(basketService.put).toHaveBeenCalledWith(1, { quantity: 1 })
  })

  it('should not decrease quantity on error retrieving basket item and log the error', fakeAsync(() => {
    basketService.get.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.dec(1)
    expect(console.log).toHaveBeenCalledWith('Error')
    expect(basketService.put).not.toHaveBeenCalled()
  }))

  it('should not decrease quantity on error updating basket item and log the error', fakeAsync(() => {
    basketService.find.and.returnValue(of({ Products: [{ BasketItem: { id: 1, quantity: 1 } }] }))
    basketService.get.and.returnValue(of({ id: 1, quantity: 1 }))
    basketService.put.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.dec(1)
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should load again after decreasing product quantity', () => {
    basketService.find.and.returnValue(of({ Products: [{ BasketItem: { id: 1, quantity: 2 } }] }))
    basketService.get.and.returnValue(of({ id: 1, quantity: 2 }))
    basketService.put.and.returnValue(of({ id: 1, quantity: 1 }))
    component.dec(1)
    expect(basketService.find).toHaveBeenCalled()
  })

  it('should reset quantity to 1 when decreasing for quantity tampered to be negative', () => {
    basketService.find.and.returnValue(of({ Products: [{ BasketItem: { id: 1, quantity: -100 } }] }))
    basketService.get.and.returnValue(of({ id: 1, quantity: -100 }))
    basketService.put.and.returnValue(of({ id: 1, quantity: 1 }))
    component.dec(1)
    expect(basketService.get).toHaveBeenCalledWith(1)
    expect(basketService.put).toHaveBeenCalledWith(1, { quantity: 1 })
  })

  it('should reset quantity to 1 when increasing for quantity tampered to be negative', () => {
    basketService.find.and.returnValue(of({ Products: [{ BasketItem: { id: 1, quantity: -100 } }] }))
    basketService.get.and.returnValue(of({ id: 1, quantity: -100 }))
    basketService.put.and.returnValue(of({ id: 1, quantity: 1 }))
    component.inc(1)
    expect(basketService.get).toHaveBeenCalledWith(1)
    expect(basketService.put).toHaveBeenCalledWith(1, { quantity: 1 })
  })
})


/* ===== FILE: ./frontend/src/app/purchase-basket/purchase-basket.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->


<h1>
  {{"TITLE_BASKET" | translate}}
  <small>{{userEmail}}</small>
</h1>
<mat-table [dataSource]="dataSource">
  <ng-container matColumnDef="image">
    <mat-header-cell *matHeaderCellDef style="display: none;"></mat-header-cell>
    <mat-cell *matCellDef="let element" fxShow fxHide.lt-md fxFlex="20%" class="content-align">
      <img [src]="'assets/public/images/products/'+element.image" alt={{element.name}}
           class="img-responsive img-thumbnail">
    </mat-cell>
    <mat-footer-cell *matFooterCellDef fxShow fxHide.lt-md fxFlex="20%" class="content-align"></mat-footer-cell>
  </ng-container>
  <ng-container matColumnDef="product">
    <mat-header-cell *matHeaderCellDef style="display: none;"></mat-header-cell>
    <mat-cell *matCellDef="let element" fxFlex="35%" fxFlex.lt-md="30%" style="font-size: initial;"> {{element.name}}
    </mat-cell>
    <mat-footer-cell *matFooterCellDef fxFlex="35%" fxFlex.lt-md="30%"></mat-footer-cell>
  </ng-container>
  <ng-container matColumnDef="quantity">
    <mat-header-cell *matHeaderCellDef style="display: none;"></mat-header-cell>
    <mat-cell *matCellDef="let element" fxFlex="16%" fxFlex.lt-md="35%" class="content-align">
      <button mat-icon-button (click)="dec(element.BasketItem.id)" *ngIf="allowEdit"><i class="fas fa-minus-square"></i>
      </button>
      <span style="font-size: initial;"> {{element.BasketItem.quantity}}</span>
      <button mat-icon-button (click)="inc(element.BasketItem.id)" *ngIf="allowEdit"><i class="fas fa-plus-square"></i>
      </button>
    </mat-cell>
    <mat-footer-cell *matFooterCellDef fxFlex="16%" fxFlex.lt-md="35%" class="header-align">TOTAL</mat-footer-cell>
  </ng-container>
  <ng-container matColumnDef="price">
    <mat-header-cell *matHeaderCellDef style="display: none;"></mat-header-cell>
    <mat-cell *matCellDef="let element" fxShow fxHide.lt-md fxFlex="16%" style="font-size: initial;"> {{element.price}}&curren;</mat-cell>
    <mat-footer-cell *matFooterCellDef fxShow fxHide.lt-md fxFlex="16%"></mat-footer-cell>
  </ng-container>
  <ng-container matColumnDef="remove" *ngIf="allowEdit">
    <mat-header-cell *matHeaderCellDef style="display: none;"></mat-header-cell>
    <mat-cell *matCellDef="let element" fxFlex="10%" fxFlex.lt-md="15%">
      <button mat-icon-button (click)="delete(element.BasketItem.id)"><i class="far fa-trash-alt"></i></button>
    </mat-cell>
    <mat-footer-cell *matFooterCellDef fxFlex="10%" fxFlex.lt-md="15%"></mat-footer-cell>
  </ng-container>
  <mat-header-row *matHeaderRowDef="tableColumns"></mat-header-row>
  <mat-row *matRowDef="let row; columns: tableColumns;"></mat-row>
  <span *ngIf="displayTotal">
				<mat-footer-row mat-footer-row *matFooterRowDef="tableColumns"></mat-footer-row>
		 </span>

</mat-table>
<div *ngIf="totalPrice" id="price">{{"LABEL_TOTAL_PRICE"| translate }}: {{itemTotal}}¤</div>


/* ===== FILE: ./frontend/src/app/purchase-basket/purchase-basket.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { Component, EventEmitter, Input, type OnInit, Output } from '@angular/core'
import { BasketService } from '../Services/basket.service'
import { UserService } from '../Services/user.service'
import { library } from '@fortawesome/fontawesome-svg-core'
import { faTrashAlt } from '@fortawesome/free-regular-svg-icons/'
import { faMinusSquare, faPlusSquare } from '@fortawesome/free-solid-svg-icons'
import { DeluxeGuard } from '../app.guard'
import { SnackBarHelperService } from '../Services/snack-bar-helper.service'
import { TranslateModule } from '@ngx-translate/core'
import { MatIconButton } from '@angular/material/button'
import { NgIf } from '@angular/common'
import { FlexModule } from '@angular/flex-layout/flex'
import { ExtendedModule } from '@angular/flex-layout/extended'
import { MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, MatFooterCellDef, MatFooterCell, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow, MatFooterRowDef, MatFooterRow } from '@angular/material/table'

library.add(faTrashAlt, faMinusSquare, faPlusSquare)

@Component({
  selector: 'app-purchase-basket',
  templateUrl: './purchase-basket.component.html',
  styleUrls: ['./purchase-basket.component.scss'],
  imports: [MatTable, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, ExtendedModule, FlexModule, MatFooterCellDef, MatFooterCell, NgIf, MatIconButton, MatHeaderRowDef, MatHeaderRow, MatRowDef, MatRow, MatFooterRowDef, MatFooterRow, TranslateModule]
})
export class PurchaseBasketComponent implements OnInit {
  @Input('allowEdit') public allowEdit: boolean = false
  @Input('displayTotal') public displayTotal: boolean = false
  @Input('totalPrice') public totalPrice: boolean = true
  @Output() emitTotal = new EventEmitter()
  @Output() emitProductCount = new EventEmitter()
  public tableColumns = ['image', 'product', 'quantity', 'price']
  public dataSource = []
  public bonus = 0
  public itemTotal = 0
  public userEmail: string
  constructor (private readonly deluxeGuard: DeluxeGuard, private readonly basketService: BasketService,
    private readonly userService: UserService, private readonly snackBarHelperService: SnackBarHelperService) { }

  ngOnInit (): void {
    if (this.allowEdit && !this.tableColumns.includes('remove')) {
      this.tableColumns.push('remove')
    }
    this.load()
    this.userService.whoAmI().subscribe((data) => {
      this.userEmail = data.email || 'anonymous'
      this.userEmail = '(' + this.userEmail + ')'
    }, (err) => { console.log(err) })
  }

  load () {
    this.basketService.find(parseInt(sessionStorage.getItem('bid'), 10)).subscribe((basket) => {
      if (this.isDeluxe()) {
        basket.Products.forEach(product => {
          product.price = product.deluxePrice
        })
      }
      this.dataSource = basket.Products
      // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
      this.itemTotal = basket.Products.reduce((itemTotal, product) => itemTotal + product.price * product.BasketItem.quantity, 0)
      // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
      this.bonus = basket.Products.reduce((bonusPoints, product) => bonusPoints + Math.round(product.price / 10) * product.BasketItem.quantity, 0)
      this.sendToParent(this.dataSource.length)
    }, (err) => { console.log(err) })
  }

  delete (id) {
    this.basketService.del(id).subscribe(() => {
      this.load()
      this.basketService.updateNumberOfCartItems()
    }, (err) => { console.log(err) })
  }

  inc (id) {
    this.addToQuantity(id, 1)
  }

  dec (id) {
    this.addToQuantity(id, -1)
  }

  addToQuantity (id, value) {
    this.basketService.get(id).subscribe((basketItem) => {
      // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
      const newQuantity = basketItem.quantity + value
      this.basketService.put(id, { quantity: newQuantity < 1 ? 1 : newQuantity }).subscribe(() => {
        this.load()
        this.basketService.updateNumberOfCartItems()
      }, (err) => {
        this.snackBarHelperService.open(err.error?.error, 'errorBar')
        console.log(err)
      })
    }, (err) => { console.log(err) })
  }

  sendToParent (count) {
    this.emitTotal.emit([this.itemTotal, this.bonus])
    this.emitProductCount.emit(count)
  }

  isDeluxe () {
    return this.deluxeGuard.isDeluxe()
  }
}


/* ===== FILE: ./frontend/src/app/search-result/search-result.component.spec.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { TranslateModule, TranslateService } from '@ngx-translate/core'
import { MatDividerModule } from '@angular/material/divider'
import { provideHttpClientTesting } from '@angular/common/http/testing'
import { type ComponentFixture, fakeAsync, TestBed, waitForAsync } from '@angular/core/testing'
import { SearchResultComponent } from './search-result.component'
import { ProductService } from '../Services/product.service'
import { RouterTestingModule } from '@angular/router/testing'
import { MatGridListModule } from '@angular/material/grid-list'
import { MatCardModule } from '@angular/material/card'
import { MatSnackBar } from '@angular/material/snack-bar'

import { BrowserAnimationsModule } from '@angular/platform-browser/animations'
import { MatTableModule } from '@angular/material/table'
import { MatPaginatorModule } from '@angular/material/paginator'
import { MatDialog, MatDialogModule } from '@angular/material/dialog'
import { of } from 'rxjs'
import { DomSanitizer } from '@angular/platform-browser'
import { throwError } from 'rxjs/internal/observable/throwError'
import { ProductDetailsComponent } from 'src/app/product-details/product-details.component'
import { BasketService } from '../Services/basket.service'
import { EventEmitter } from '@angular/core'
import { ActivatedRoute } from '@angular/router'
import { SocketIoService } from '../Services/socket-io.service'
import { type Product } from '../Models/product.model'
import { QuantityService } from '../Services/quantity.service'
import { DeluxeGuard } from '../app.guard'
import { provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'

class MockSocket {
  on (str: string, callback: any) {
    callback(str)
  }

  emit (a: any, b: any) {
    return null
  }
}

class MockActivatedRoute {
  snapshot = { queryParams: { q: '' } }

  setQueryParameter (arg: string) {
    this.snapshot.queryParams.q = arg
  }
}

describe('SearchResultComponent', () => {
  let component: SearchResultComponent
  let fixture: ComponentFixture<SearchResultComponent>
  let productService: any
  let basketService: any
  let translateService: any
  let activatedRoute: MockActivatedRoute
  let dialog: any
  let sanitizer: any
  let socketIoService: any
  let mockSocket: any
  let quantityService
  let deluxeGuard
  let snackBar: any

  beforeEach(waitForAsync(() => {
    dialog = jasmine.createSpyObj('MatDialog', ['open'])
    dialog.open.and.returnValue(null)
    quantityService = jasmine.createSpyObj('QuantityService', ['getAll'])
    quantityService.getAll.and.returnValue(of([]))
    snackBar = jasmine.createSpyObj('MatSnackBar', ['open'])
    productService = jasmine.createSpyObj('ProductService', ['search', 'get'])
    productService.search.and.returnValue(of([]))
    productService.get.and.returnValue(of({}))
    basketService = jasmine.createSpyObj('BasketService', ['find', 'get', 'put', 'save', 'updateNumberOfCartItems'])
    basketService.find.and.returnValue(of({ Products: [] }))
    basketService.get.and.returnValue(of({ quantinty: 1 }))
    basketService.put.and.returnValue(of({ ProductId: 1 }))
    basketService.save.and.returnValue(of({ ProductId: 1 }))
    basketService.updateNumberOfCartItems.and.returnValue(of({}))
    translateService = jasmine.createSpyObj('TranslateService', ['get'])
    translateService.get.and.returnValue(of({}))
    translateService.onLangChange = new EventEmitter()
    translateService.onTranslationChange = new EventEmitter()
    translateService.onDefaultLangChange = new EventEmitter()
    sanitizer = jasmine.createSpyObj('DomSanitizer', ['bypassSecurityTrustHtml', 'sanitize'])
    sanitizer.bypassSecurityTrustHtml.and.returnValue(of({}))
    sanitizer.sanitize.and.returnValue({})
    activatedRoute = new MockActivatedRoute()
    mockSocket = new MockSocket()
    socketIoService = jasmine.createSpyObj('SocketIoService', ['socket'])
    socketIoService.socket.and.returnValue(mockSocket)
    deluxeGuard = jasmine.createSpyObj('', ['isDeluxe'])
    deluxeGuard.isDeluxe.and.returnValue(of(false))

    TestBed.configureTestingModule({
      imports: [RouterTestingModule,
        TranslateModule.forRoot(),
        BrowserAnimationsModule,
        MatTableModule,
        MatPaginatorModule,
        MatDialogModule,
        MatDividerModule,
        MatGridListModule,
        MatCardModule,
        SearchResultComponent],
      providers: [
        { provide: TranslateService, useValue: translateService },
        { provide: MatDialog, useValue: dialog },
        { provide: MatSnackBar, useValue: snackBar },
        { provide: BasketService, useValue: basketService },
        { provide: ProductService, useValue: productService },
        { provide: DomSanitizer, useValue: sanitizer },
        { provide: ActivatedRoute, useValue: activatedRoute },
        { provide: SocketIoService, useValue: socketIoService },
        { provide: QuantityService, useValue: quantityService },
        { provide: DeluxeGuard, useValue: deluxeGuard },
        provideHttpClient(withInterceptorsFromDi()),
        provideHttpClientTesting()
      ]
    })
      .compileComponents()
  }))

  beforeEach(() => {
    fixture = TestBed.createComponent(SearchResultComponent)
    component = fixture.componentInstance
    component.ngAfterViewInit()
    fixture.detectChanges()
  })

  it('should create', () => {
    expect(component).toBeTruthy()
  })

  it('should render product descriptions as trusted HTML', () => {
    productService.search.and.returnValue(of([{ description: '<script>alert("XSS")</script>' }]))
    component.ngAfterViewInit()
    fixture.detectChanges()
    expect(sanitizer.bypassSecurityTrustHtml).toHaveBeenCalledWith('<script>alert("XSS")</script>')
  })

  it('should hold no products when product search API call fails', () => {
    productService.search.and.returnValue(throwError('Error'))
    component.ngAfterViewInit()
    fixture.detectChanges()
    expect(component.tableData).toEqual([])
  })

  it('should log error from product search API call directly to browser console', fakeAsync(() => {
    productService.search.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.ngAfterViewInit()
    fixture.detectChanges()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should hold no products when quantity getAll API call fails', () => {
    quantityService.getAll.and.returnValue(throwError('Error'))
    component.ngAfterViewInit()
    fixture.detectChanges()
    expect(component.tableData).toEqual([])
  })

  it('should log error from quantity getAll API call directly to browser console', fakeAsync(() => {
    quantityService.getAll.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    component.ngAfterViewInit()
    fixture.detectChanges()
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should notify socket if search query includes DOM XSS payload while filtering table', () => {
    activatedRoute.setQueryParameter('<iframe src="javascript:alert(`xss`)"> Payload')
    spyOn(mockSocket, 'emit')
    component.filterTable()
    expect(mockSocket.emit.calls.mostRecent().args[0]).toBe('verifyLocalXssChallenge')
    expect(mockSocket.emit.calls.mostRecent().args[1]).toBe(activatedRoute.snapshot.queryParams.q)
  })

  it('should trim the queryparameter while filtering the datasource', () => {
    activatedRoute.setQueryParameter('  Product Search   ')
    component.filterTable()
    expect(component.dataSource.filter).toEqual('product search')
  })

  it('should pass the search query as trusted HTML', () => {
    activatedRoute.setQueryParameter('<script>scripttag</script>')
    component.filterTable()
    expect(sanitizer.bypassSecurityTrustHtml).toHaveBeenCalledWith('<script>scripttag</script>')
  })

  it('should open a modal dialog with product details', () => {
    component.showDetail({ id: 42 } as Product)
    expect(dialog.open).toHaveBeenCalledWith(ProductDetailsComponent, {
      width: '500px',
      height: 'max-content',
      data: {
        productData: { id: 42 }
      }
    })
  })

  it('should add new product to basket', () => {
    basketService.find.and.returnValue(of({ Products: [] }))
    productService.search.and.returnValue(of([]))
    basketService.save.and.returnValue(of({ ProductId: 1 }))
    productService.get.and.returnValue(of({ name: 'Cherry Juice' }))
    sessionStorage.setItem('bid', '4711')
    component.addToBasket(1)
    expect(basketService.find).toHaveBeenCalled()
    expect(basketService.save).toHaveBeenCalled()
    expect(productService.get).toHaveBeenCalled()
    expect(translateService.get).toHaveBeenCalledWith('BASKET_ADD_PRODUCT', { product: 'Cherry Juice' })
  })

  it('should translate BASKET_ADD_PRODUCT message', () => {
    basketService.find.and.returnValue(of({ Products: [] }))
    productService.search.and.returnValue(of([]))
    basketService.save.and.returnValue(of({ ProductId: 1 }))
    productService.get.and.returnValue(of({ name: 'Cherry Juice' }))
    translateService.get.and.returnValue(of('Translation of BASKET_ADD_PRODUCT'))
    sessionStorage.setItem('bid', '4711')
    component.addToBasket(1)
    expect(basketService.find).toHaveBeenCalled()
    expect(basketService.save).toHaveBeenCalled()
    expect(productService.get).toHaveBeenCalled()
    expect(snackBar.open).toHaveBeenCalled()
  })

  it('should add similar product to basket', () => {
    basketService.find.and.returnValue(of({ Products: [{ id: 1 }, { id: 2, name: 'Tomato Juice', BasketItem: { id: 42 } }] }))
    basketService.get.and.returnValue(of({ id: 42, quantity: 5 }))
    basketService.put.and.returnValue(of({ ProductId: 2 }))
    productService.get.and.returnValue(of({ name: 'Tomato Juice' }))
    translateService.get.and.returnValue(of(undefined))
    sessionStorage.setItem('bid', '4711')
    component.addToBasket(2)
    expect(basketService.find).toHaveBeenCalled()
    expect(basketService.get).toHaveBeenCalled()
    expect(basketService.put).toHaveBeenCalled()
    expect(productService.get).toHaveBeenCalled()
    expect(translateService.get).toHaveBeenCalledWith('BASKET_ADD_SAME_PRODUCT', { product: 'Tomato Juice' })
  })

  it('should translate BASKET_ADD_SAME_PRODUCT message', () => {
    basketService.find.and.returnValue(of({ Products: [{ id: 1 }, { id: 2, name: 'Tomato Juice', BasketItem: { id: 42 } }] }))
    basketService.get.and.returnValue(of({ id: 42, quantity: 5 }))
    basketService.put.and.returnValue(of({ ProductId: 2 }))
    productService.get.and.returnValue(of({ name: 'Tomato Juice' }))
    translateService.get.and.returnValue(of('Translation of BASKET_ADD_SAME_PRODUCT'))
    sessionStorage.setItem('bid', '4711')
    component.addToBasket(2)
    expect(basketService.find).toHaveBeenCalled()
    expect(basketService.get).toHaveBeenCalled()
    expect(basketService.put).toHaveBeenCalled()
    expect(productService.get).toHaveBeenCalled()
  })

  it('should not add anything to basket on error retrieving basket', fakeAsync(() => {
    basketService.find.and.returnValue(throwError('Error'))
    sessionStorage.setItem('bid', '815')
    component.addToBasket(undefined)
    expect(snackBar.open).not.toHaveBeenCalled()
  }))

  it('should log errors retrieving basket directly to browser console', fakeAsync(() => {
    basketService.find.and.returnValue(throwError('Error'))
    sessionStorage.setItem('bid', '815')
    console.log = jasmine.createSpy('log')
    component.addToBasket(2)
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should not add anything to basket on error retrieving existing basket item', fakeAsync(() => {
    basketService.find.and.returnValue(of({ Products: [{ id: 1 }, { id: 2, name: 'Tomato Juice', BasketItem: { id: 42 } }] }))
    basketService.get.and.returnValue(throwError('Error'))
    sessionStorage.setItem('bid', '4711')
    component.addToBasket(2)
    expect(snackBar.open).not.toHaveBeenCalled()
  }))

  it('should log errors retrieving basket item directly to browser console', fakeAsync(() => {
    basketService.find.and.returnValue(of({ Products: [{ id: 1 }, { id: 2, name: 'Tomato Juice', BasketItem: { id: 42 } }] }))
    basketService.get.and.returnValue(throwError('Error'))
    sessionStorage.setItem('bid', '4711')
    console.log = jasmine.createSpy('log')
    component.addToBasket(2)
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should log errors updating basket directly to browser console', fakeAsync(() => {
    basketService.find.and.returnValue(of({ Products: [{ id: 1 }, { id: 2, name: 'Tomato Juice', BasketItem: { id: 42 } }] }))
    basketService.put.and.returnValue(throwError('Error'))
    sessionStorage.setItem('bid', '4711')
    console.log = jasmine.createSpy('log')
    component.addToBasket(2)
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should not add anything to basket on error retrieving product associated with basket item', fakeAsync(() => {
    basketService.find.and.returnValue(of({ Products: [{ id: 1 }, { id: 2, name: 'Tomato Juice', BasketItem: { id: 42 } }] }))
    productService.get.and.returnValue(throwError('Error'))
    sessionStorage.setItem('bid', '4711')
    component.addToBasket(2)
    expect(snackBar.open).not.toHaveBeenCalled()
  }))

  it('should log errors retrieving product associated with basket item directly to browser console', fakeAsync(() => {
    basketService.find.and.returnValue(of({ Products: [{ id: 1 }, { id: 2, name: 'Tomato Juice', BasketItem: { id: 42 } }] }))
    productService.get.and.returnValue(throwError('Error'))
    sessionStorage.setItem('bid', '4711')
    console.log = jasmine.createSpy('log')
    component.addToBasket(2)
    expect(console.log).toHaveBeenCalledWith('Error')
  }))

  it('should not add anything on error creating new basket item', fakeAsync(() => {
    basketService.find.and.returnValue(of({ Products: [] }))
    basketService.save.and.returnValue(throwError('Error'))
    sessionStorage.setItem('bid', '4711')
    component.addToBasket(2)
    expect(snackBar.open).toHaveBeenCalled()
  }))

  it('should log errors creating new basket item directly to browser console', fakeAsync(() => {
    basketService.find.and.returnValue(of({ Products: [] }))
    basketService.save.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    sessionStorage.setItem('bid', '4711')
    component.addToBasket(2)
    expect(snackBar.open).toHaveBeenCalled()
  }))

  it('should not add anything on error retrieving product after creating new basket item', fakeAsync(() => {
    basketService.find.and.returnValue(of({ Products: [] }))
    productService.get.and.returnValue(throwError('Error'))
    sessionStorage.setItem('bid', '4711')
    component.addToBasket(2)
    expect(snackBar.open).not.toHaveBeenCalled()
  }))

  it('should log errors retrieving product after creating new basket item directly to browser console', fakeAsync(() => {
    basketService.find.and.returnValue(of({ Products: [] }))
    productService.get.and.returnValue(throwError('Error'))
    console.log = jasmine.createSpy('log')
    sessionStorage.setItem('bid', '4711')
    component.addToBasket(2)
    expect(console.log).toHaveBeenCalledWith('Error')
  }))
})


/* ===== FILE: ./frontend/src/app/search-result/search-result.component.html ===== */

<!--
  ~ Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
  ~ SPDX-License-Identifier: MIT
  -->

<div fxLayoutAlign="center">

  <div class="table-container custom-slate">

    <div class="heading mat-elevation-z6">
      <div *ngIf="searchValue">
        <span>{{"TITLE_SEARCH_RESULTS" | translate}} - </span>
        <span id="searchValue" [innerHTML]="searchValue"></span>
      </div>
      <div *ngIf="!searchValue">{{"TITLE_ALL_PRODUCTS" | translate}}</div>
      <div id="search-result-heading"></div>
    </div>
    <div *ngIf=" !emptyState; else emptyResult">
      <mat-grid-list #table (window:resize)="onResize($event)" [cols]="breakpoint" gutterSize="30px">
        <mat-grid-tile *ngFor="let item of gridDataSource | async">
          <mat-card appearance="outlined" [style.width]="'100%'" class="mat-elevation-z6 ribbon-card">
            <div class="mdc-card">
              <div class="ribbon ribbon-top-left" *ngIf="item.quantity <= 5 && item.quantity > 0"><span translate
                                                                                                        [translateParams]="{quantity: item.quantity}">LABEL_ONLY_QUANTITY_LEFT</span>
              </div>
              <div class="ribbon ribbon-top-left ribbon-sold" *ngIf="item.quantity <= 0"><span
                >{{"LABEL_SOLD_OUT" | translate }}</span></div>
              <div (click)="showDetail(item)" aria-label="Click for more information about the product" class="product"
                  matTooltip="Click for more information" matTooltipPosition="above">
                <img mat-card-image [src]="'assets/public/images/products/'+item.image" alt={{item.name}}
                      class="img-responsive img-thumbnail" role="button">
                <div fxFlexAlign="center" fxFlex="40%">
                  <div class="item-name">
                    {{item.name}}
                  </div>
                  <div class="item-price">
                    <span *ngIf="!isDeluxe() || item.price === item.deluxePrice">{{item.price}}&curren;</span>
                    <span *ngIf="isDeluxe() && item.price !== item.deluxePrice"><s>{{item.price}}</s> {{ item.deluxePrice }}&curren;</span>
                  </div>
                </div>
              </div>
              <div style="display: flex; justify-content: center;" class="basket-btn-container">
                <button (click)="addToBasket(item.id)" *ngIf="isLoggedIn()" aria-label="Add to Basket" class="btn-basket"
                        color="primary" mat-button mat-raised-button>
                  <span>{{"ADD_BASKET" | translate}}</span>
                </button>
              </div>
            </div>
          </mat-card>
        </mat-grid-tile>
      </mat-grid-list>
    </div>

    <ng-template #emptyResult>
      <mat-card appearance="outlined" class="mat-elevation-z6 emptyState">
        <div class="mdc-card">
          <img alt=" No results found"
              class="img-responsive noResult"
              src="assets/public/images/products/no-results.png">
          <mat-card-title>
            <span class="noResultText" >
              {{"NO_SEARCH_RESULT" | translate}}
            </span>
          </mat-card-title>
          <mat-card-content>
            <span class="noResultText">
              {{"EMPTY_SEARCH_RESULT" | translate}}
            </span>
          </mat-card-content>
        </div>
      </mat-card>
    </ng-template>

    <mat-divider></mat-divider>

    <mat-paginator #paginator
                   [pageSize]="12"
                   [pageSizeOptions]="pageSizeOptions"
                   [length]="resultsLength"
                   class="mat-elevation-z6"
                   color="accent">
    </mat-paginator>
  </div>
</div>


/* ===== FILE: ./frontend/src/app/search-result/search-result.component.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { ProductDetailsComponent } from '../product-details/product-details.component'
import { ActivatedRoute, Router } from '@angular/router'
import { ProductService } from '../Services/product.service'
import { BasketService } from '../Services/basket.service'
import { type AfterViewInit, Component, NgZone, type OnDestroy, ViewChild, ChangeDetectorRef } from '@angular/core'
import { MatPaginator } from '@angular/material/paginator'
import { forkJoin, type Subscription } from 'rxjs'
import { MatTableDataSource } from '@angular/material/table'
import { MatDialog } from '@angular/material/dialog'
import { DomSanitizer, type SafeHtml } from '@angular/platform-browser'
import { TranslateService, TranslateModule } from '@ngx-translate/core'
import { SocketIoService } from '../Services/socket-io.service'
import { SnackBarHelperService } from '../Services/snack-bar-helper.service'

import { library } from '@fortawesome/fontawesome-svg-core'
import { faCartPlus, faEye } from '@fortawesome/free-solid-svg-icons'
import { type Product } from '../Models/product.model'
import { QuantityService } from '../Services/quantity.service'
import { DeluxeGuard } from '../app.guard'
import { MatDivider } from '@angular/material/divider'
import { MatButtonModule } from '@angular/material/button'
import { MatTooltip } from '@angular/material/tooltip'
import { MatCardModule, MatCardImage, MatCardTitle, MatCardContent } from '@angular/material/card'
import { MatGridList, MatGridTile } from '@angular/material/grid-list'
import { NgIf, NgFor, AsyncPipe } from '@angular/common'
import { FlexModule } from '@angular/flex-layout/flex'

library.add(faEye, faCartPlus)

interface TableEntry {
  name: string
  price: number
  deluxePrice: number
  id: number
  image: string
  description: string
  quantity?: number
}

@Component({
  selector: 'app-search-result',
  templateUrl: './search-result.component.html',
  styleUrls: ['./search-result.component.scss'],
  imports: [FlexModule, NgIf, MatGridList, NgFor, MatGridTile, MatCardModule, TranslateModule, MatTooltip, MatCardImage, MatButtonModule, MatCardTitle, MatCardContent, MatDivider, MatPaginator, AsyncPipe]
})
export class SearchResultComponent implements OnDestroy, AfterViewInit {
  public displayedColumns = ['Image', 'Product', 'Description', 'Price', 'Select']
  public tableData!: any[]
  public pageSizeOptions: number[] = []
  public dataSource!: MatTableDataSource<TableEntry>
  public gridDataSource!: any
  public searchValue?: SafeHtml
  public resultsLength = 0
  @ViewChild(MatPaginator, { static: true }) paginator: MatPaginator | null = null
  private readonly productSubscription?: Subscription
  private routerSubscription?: Subscription
  public breakpoint: number = 6
  public emptyState = false

  constructor (private readonly deluxeGuard: DeluxeGuard, private readonly dialog: MatDialog, private readonly productService: ProductService,
    private readonly quantityService: QuantityService, private readonly basketService: BasketService, private readonly translateService: TranslateService,
    private readonly router: Router, private readonly route: ActivatedRoute, private readonly sanitizer: DomSanitizer, private readonly ngZone: NgZone, private readonly io: SocketIoService,
    private readonly snackBarHelperService: SnackBarHelperService, private readonly cdRef: ChangeDetectorRef) { }

  // vuln-code-snippet start restfulXssChallenge
  ngAfterViewInit () {
    const products = this.productService.search('')
    const quantities = this.quantityService.getAll()
    forkJoin([quantities, products]).subscribe(([quantities, products]) => {
      const dataTable: TableEntry[] = []
      this.tableData = products
      this.trustProductDescription(products) // vuln-code-snippet neutral-line restfulXssChallenge
      for (const product of products) {
        dataTable.push({
          name: product.name,
          price: product.price,
          deluxePrice: product.deluxePrice,
          id: product.id,
          image: product.image,
          description: product.description
        })
      }
      for (const quantity of quantities) {
        const entry = dataTable.find((dataTableEntry) => {
          return dataTableEntry.id === quantity.ProductId
        })
        if (entry === undefined) {
          continue
        }
        entry.quantity = quantity.quantity
      }
      this.dataSource = new MatTableDataSource<TableEntry>(dataTable)
      for (let i = 1; i <= Math.ceil(this.dataSource.data.length / 12); i++) {
        this.pageSizeOptions.push(i * 12)
      }
      this.paginator.pageSizeOptions = this.pageSizeOptions
      this.dataSource.paginator = this.paginator
      this.gridDataSource = this.dataSource.connect()
      this.resultsLength = this.dataSource.data.length
      this.filterTable()
      this.routerSubscription = this.router.events.subscribe(() => {
        this.filterTable()
      })
      const challenge: string = this.route.snapshot.queryParams.challenge // vuln-code-snippet hide-start
      if (challenge && this.route.snapshot.url.join('').match(/hacking-instructor/)) {
        this.startHackingInstructor(decodeURIComponent(challenge))
      } // vuln-code-snippet hide-end
      if (window.innerWidth < 2600) {
        this.breakpoint = 4
        if (window.innerWidth < 1740) {
          this.breakpoint = 3
          if (window.innerWidth < 1280) {
            this.breakpoint = 2
            if (window.innerWidth < 850) {
              this.breakpoint = 1
            }
          }
        }
      } else {
        this.breakpoint = 6
      }
      this.cdRef.detectChanges()
    }, (err) => { console.log(err) })
  }

  trustProductDescription (tableData: any[]) { // vuln-code-snippet neutral-line restfulXssChallenge
    for (let i = 0; i < tableData.length; i++) { // vuln-code-snippet neutral-line restfulXssChallenge
      tableData[i].description = this.sanitizer.bypassSecurityTrustHtml(tableData[i].description) // vuln-code-snippet vuln-line restfulXssChallenge
    } // vuln-code-snippet neutral-line restfulXssChallenge
  } // vuln-code-snippet neutral-line restfulXssChallenge
  // vuln-code-snippet end restfulXssChallenge

  ngOnDestroy () {
    if (this.routerSubscription) {
      this.routerSubscription.unsubscribe()
    }
    if (this.productSubscription) {
      this.productSubscription.unsubscribe()
    }
    if (this.dataSource) {
      this.dataSource.disconnect()
    }
  }

  // vuln-code-snippet start localXssChallenge xssBonusChallenge
  filterTable () {
    let queryParam: string = this.route.snapshot.queryParams.q
    if (queryParam) {
      queryParam = queryParam.trim()
      this.ngZone.runOutsideAngular(() => { // vuln-code-snippet hide-start
        this.io.socket().emit('verifyLocalXssChallenge', queryParam)
      }) // vuln-code-snippet hide-end
      this.dataSource.filter = queryParam.toLowerCase()
      this.searchValue = this.sanitizer.bypassSecurityTrustHtml(queryParam) // vuln-code-snippet vuln-line localXssChallenge xssBonusChallenge
      this.gridDataSource.subscribe((result: any) => {
        if (result.length === 0) {
          this.emptyState = true
        } else {
          this.emptyState = false
        }
      })
    } else {
      this.dataSource.filter = ''
      this.searchValue = undefined
      this.emptyState = false
    }
  }
  // vuln-code-snippet end localXssChallenge xssBonusChallenge

  startHackingInstructor (challengeName: string) {
    console.log(`Starting instructions for challenge "${challengeName}"`)
    import(/* webpackChunkName: "tutorial" */ '../../hacking-instructor').then(module => {
      module.startHackingInstructorFor(challengeName)
    })
  }

  showDetail (element: Product) {
    this.dialog.open(ProductDetailsComponent, {
      width: '500px',
      height: 'max-content',
      data: {
        productData: element
      }
    })
  }

  addToBasket (id?: number) {
    this.basketService.find(Number(sessionStorage.getItem('bid'))).subscribe((basket) => {
      const productsInBasket: any = basket.Products
      let found = false
      for (let i = 0; i < productsInBasket.length; i++) {
        if (productsInBasket[i].id === id) {
          found = true
          this.basketService.get(productsInBasket[i].BasketItem.id).subscribe((existingBasketItem) => {
            // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
            const newQuantity = existingBasketItem.quantity + 1
            this.basketService.put(existingBasketItem.id, { quantity: newQuantity }).subscribe((updatedBasketItem) => {
              this.productService.get(updatedBasketItem.ProductId).subscribe((product) => {
                this.translateService.get('BASKET_ADD_SAME_PRODUCT', { product: product.name }).subscribe((basketAddSameProduct) => {
                  this.snackBarHelperService.open(basketAddSameProduct, 'confirmBar')
                  this.basketService.updateNumberOfCartItems()
                }, (translationId) => {
                  this.snackBarHelperService.open(translationId, 'confirmBar')
                  this.basketService.updateNumberOfCartItems()
                })
              }, (err) => { console.log(err) })
            }, (err) => {
              this.snackBarHelperService.open(err.error?.error, 'errorBar')
              console.log(err)
            })
          }, (err) => { console.log(err) })
          break
        }
      }
      if (!found) {
        this.basketService.save({ ProductId: id, BasketId: sessionStorage.getItem('bid'), quantity: 1 }).subscribe((newBasketItem) => {
          this.productService.get(newBasketItem.ProductId).subscribe((product) => {
            this.translateService.get('BASKET_ADD_PRODUCT', { product: product.name }).subscribe((basketAddProduct) => {
              this.snackBarHelperService.open(basketAddProduct, 'confirmBar')
              this.basketService.updateNumberOfCartItems()
            }, (translationId) => {
              this.snackBarHelperService.open(translationId, 'confirmBar')
              this.basketService.updateNumberOfCartItems()
            })
          }, (err) => { console.log(err) })
        }, (err) => {
          this.snackBarHelperService.open(err.error?.error, 'errorBar')
          console.log(err)
        })
      }
    }, (err) => { console.log(err) })
  }

  isLoggedIn () {
    return localStorage.getItem('token')
  }

  onResize (event: any) {
    if (event.target.innerWidth < 2600) {
      this.breakpoint = 4
      if (event.target.innerWidth < 1740) {
        this.breakpoint = 3
        if (event.target.innerWidth < 1280) {
          this.breakpoint = 2
          if (event.target.innerWidth < 850) {
            this.breakpoint = 1
          }
        }
      }
    } else {
      this.breakpoint = 6
    }
  }

  isDeluxe () {
    return this.deluxeGuard.isDeluxe()
  }
}


/* ===== FILE: ./frontend/src/main.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { enableProdMode, importProvidersFrom } from '@angular/core'
import { platformBrowserDynamic } from '@angular/platform-browser-dynamic'

import { AppModule, HttpLoaderFactory } from './app/app.module'
import { environment } from './environments/environment'
import { AppComponent } from './app/app.component';
import { MatAutocompleteModule } from '@angular/material/autocomplete';
import { MatChipsModule } from '@angular/material/chips';
import { MatSlideToggleModule } from '@angular/material/slide-toggle';
import { MatTabsModule } from '@angular/material/tabs';
import { MatSliderModule } from '@angular/material/slider';
import { MatSnackBarModule } from '@angular/material/snack-bar';
import { MatRadioModule } from '@angular/material/radio';
import { MatBadgeModule } from '@angular/material/badge';
import { MatGridListModule } from '@angular/material/grid-list';
import { LayoutModule } from '@angular/cdk/layout';
import { MatButtonToggleModule } from '@angular/material/button-toggle';
import { MatListModule } from '@angular/material/list';
import { MatMenuModule } from '@angular/material/menu';
import { MatTooltipModule } from '@angular/material/tooltip';
import { MatProgressBarModule } from '@angular/material/progress-bar';
import { MatExpansionModule } from '@angular/material/expansion';
import { MatDatepickerModule } from '@angular/material/datepicker';
import { MatDividerModule } from '@angular/material/divider';
import { MatDialogModule } from '@angular/material/dialog';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatInputModule } from '@angular/material/input';
import { MatCardModule } from '@angular/material/card';
import { MatPaginatorModule } from '@angular/material/paginator';
import { MatTableModule } from '@angular/material/table';
import { MatRippleModule, MatNativeDateModule } from '@angular/material/core';
import { MatSidenavModule } from '@angular/material/sidenav';
import { MatButtonModule } from '@angular/material/button';
import { MatSelectModule } from '@angular/material/select';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatIconModule } from '@angular/material/icon';
import { MatToolbarModule } from '@angular/material/toolbar';
import { ClipboardModule } from 'ngx-clipboard';
import { FileUploadModule } from 'ng2-file-upload';
import { QrCodeModule } from 'ng-qrcode';
import { NgxTextDiffModule } from '@winarg/ngx-text-diff';
import { GalleryModule } from 'ng-gallery';
import { provideAnimations } from '@angular/platform-browser/animations';
import { ReactiveFormsModule, FormsModule } from '@angular/forms';
import { FlexLayoutModule } from '@angular/flex-layout';
import { TranslateHttpLoader } from '@ngx-translate/http-loader';
import { TranslateModule, TranslateLoader } from '@ngx-translate/core';
import { Routing } from './app/app.routing';
import { BrowserModule, bootstrapApplication } from '@angular/platform-browser';
import { PhotoWallService } from './app/Services/photo-wall.service';
import { DeliveryService } from './app/Services/delivery.service';
import { OrderHistoryService } from './app/Services/order-history.service';
import { WalletService } from './app/Services/wallet.service';
import { QuantityService } from './app/Services/quantity.service';
import { AddressService } from './app/Services/address.service';
import { KeysService } from './app/Services/keys.service';
import { ImageCaptchaService } from './app/Services/image-captcha.service';
import { PaymentService } from './app/Services/payment.service';
import { AdminGuard, LoginGuard, AccountingGuard, DeluxeGuard } from './app/app.guard';
import { CookieService, CookieModule } from 'ngy-cookie';
import { ChallengeService } from './app/Services/challenge.service';
import { BasketService } from './app/Services/basket.service';
import { RecycleService } from './app/Services/recycle.service';
import { TrackOrderService } from './app/Services/track-order.service';
import { ChatbotService } from './app/Services/chatbot.service';
import { ComplaintService } from './app/Services/complaint.service';
import { ProductReviewService } from './app/Services/product-review.service';
import { WindowRefService } from './app/Services/window-ref.service';
import { FeedbackService } from './app/Services/feedback.service';
import { CaptchaService } from './app/Services/captcha.service';
import { SecurityAnswerService } from './app/Services/security-answer.service';
import { UserService } from './app/Services/user.service';
import { DataSubjectService } from './app/Services/data-subject.service';
import { SecurityQuestionService } from './app/Services/security-question.service';
import { AdministrationService } from './app/Services/administration.service';
import { ConfigurationService } from './app/Services/configuration.service';
import { ProductService } from './app/Services/product.service';
import { HIGHLIGHT_OPTIONS, HighlightModule } from 'ngx-highlightjs';
import { RequestInterceptor } from './app/Services/request.interceptor';
import { HTTP_INTERCEPTORS, HttpClient, withInterceptorsFromDi, provideHttpClient } from '@angular/common/http';

if (environment.production) {
  enableProdMode()
}

bootstrapApplication(AppComponent, {
    providers: [
        importProvidersFrom(BrowserModule, Routing, TranslateModule.forRoot({
            loader: {
                provide: TranslateLoader,
                useFactory: HttpLoaderFactory,
                deps: [HttpClient]
            }
        }), CookieModule.forRoot(), FlexLayoutModule, ReactiveFormsModule, GalleryModule, NgxTextDiffModule, QrCodeModule, FileUploadModule, ClipboardModule, MatToolbarModule, MatIconModule, FormsModule, MatFormFieldModule, MatSelectModule, MatButtonModule, MatSidenavModule, MatRippleModule, MatTableModule, MatPaginatorModule, MatCardModule, MatInputModule, MatCheckboxModule, MatDialogModule, MatDividerModule, MatDatepickerModule, MatNativeDateModule, MatExpansionModule, MatProgressBarModule, MatTooltipModule, MatMenuModule, MatListModule, MatButtonToggleModule, LayoutModule, MatGridListModule, MatBadgeModule, MatRadioModule, MatSnackBarModule, MatSliderModule, MatTabsModule, MatSlideToggleModule, MatChipsModule, MatAutocompleteModule, HighlightModule),
        {
            provide: HTTP_INTERCEPTORS,
            useClass: RequestInterceptor,
            multi: true
        },
        {
            provide: HIGHLIGHT_OPTIONS,
            useValue: {
                coreLibraryLoader: async () => await import('highlight.js/lib/core'),
                lineNumbersLoader: async () => await import('highlightjs-line-numbers.js'),
                languages: {
                    typescript: async () => await import('highlight.js/lib/languages/typescript'),
                    javascript: async () => await import('highlight.js/lib/languages/javascript'),
                    yaml: async () => await import('highlight.js/lib/languages/yaml')
                }
            }
        },
        ProductService,
        ConfigurationService,
        AdministrationService,
        SecurityQuestionService,
        DataSubjectService,
        UserService,
        SecurityAnswerService,
        CaptchaService,
        FeedbackService,
        WindowRefService,
        ProductReviewService,
        ComplaintService,
        ChatbotService,
        TrackOrderService,
        RecycleService,
        BasketService,
        ChallengeService,
        CookieService,
        AdminGuard,
        LoginGuard,
        PaymentService,
        AccountingGuard,
        DeluxeGuard,
        ImageCaptchaService,
        KeysService,
        AddressService,
        QuantityService,
        WalletService,
        OrderHistoryService,
        DeliveryService,
        PhotoWallService,
        provideHttpClient(withInterceptorsFromDi()),
        provideAnimations()
    ]
})
  .catch((err: Error) => console.log(err))


/* ===== FILE: ./frontend/src/environments/environment.prod.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

export const environment = {
  production: true,
  hostServer: '.'
}


/* ===== FILE: ./frontend/src/environments/environment.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

// This file can be replaced during build by using the `fileReplacements` array.
// `ng build ---prod` replaces `environment.ts` with `environment.prod.ts`.
// The list of file replacements can be found in `angular.json`.

export const environment = {
  production: false,
  hostServer: 'http://localhost:3000'
}

/*
 * In development mode, to ignore zone related error stack frames such as
 * `zone.run`, `zoneDelegate.invokeTask` for easier debugging, you can
 * import the following file, but please comment it out in production mode
 * because it will have performance impact when throw error
 */
// import 'zone.js/plugins/zone-error';  // Included with Angular CLI.


/* ===== FILE: ./frontend/src/test.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

// This file is required by karma.conf.js and loads recursively all the .spec and framework files

import 'zone.js/testing'
import { getTestBed } from '@angular/core/testing'
import {
  BrowserDynamicTestingModule,
  platformBrowserDynamicTesting,
} from '@angular/platform-browser-dynamic/testing'

declare const require: any

// First, initialize the Angular testing environment.
getTestBed().initTestEnvironment(
  BrowserDynamicTestingModule,
  platformBrowserDynamicTesting(),
  {
    teardown: { destroyAfterEach: false }
  }
)
// Then we find all the tests.
// const context = require.context('./', true, /\.spec\.ts$/)
// // And load the modules.
// context.keys().map(context)


/* ===== FILE: ./frontend/src/confetti/index.ts ===== */

import confetti from 'canvas-confetti'

const timeout = (ms: number) => {
    return new Promise((resolve,reject) => {
        setTimeout(resolve,ms)
    })
}
export const shootConfetti = () => {
    const canvas = document.createElement('canvas')
    canvas.style.position = "fixed"
    canvas.style.left = "0"
    canvas.style.right = "0"
    canvas.style.width = "100%"
    canvas.style.height = "100%"
    canvas.style.pointerEvents = "none"
    canvas.style.zIndex = "2000"

    document.body.appendChild(canvas)

    const shoot = confetti.create(canvas,{
        resize: true
    })
    shoot({
        origin:{
            x:1,
            y:1
        },
        particleCount: 225
    })

    shoot({
        origin:{
            y:1,
            x:0
        },
        particleCount: 225
    })

    timeout(6000).then(() => {
        canvas.remove()
    })
}

/* ===== FILE: ./frontend/src/karma.conf.js ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

// Karma configuration file, see link for more information
// https://karma-runner.github.io/1.0/config/configuration-file.html

module.exports = function (config) {
  config.set({
    basePath: '',
    frameworks: ['jasmine', '@angular-devkit/build-angular'],
    plugins: [
      require('karma-jasmine'),
      require('karma-chrome-launcher'),
      require('karma-jasmine-html-reporter'),
      require('karma-coverage'),
      require('@angular-devkit/build-angular/plugins/karma')
    ],
    client: {
      clearContext: false // leave Jasmine Spec Runner output visible in browser
    },
    coverageReporter: {
      dir: require('path').join(__dirname, '../../build/reports/coverage/frontend-tests'),
      subdir: '.',
      reporters: [
        { type: 'html' },
        { type: 'lcovonly' }
      ]
    },
    reporters: ['progress', 'kjhtml'],
    port: 9876,
    colors: true,
    logLevel: config.LOG_INFO,
    autoWatch: true,
    browsers: ['ChromeHeadless'],
    singleRun: false,
    restartOnFileChange: true
  })
}


/* ===== FILE: ./rsn/rsnUtil.ts ===== */

import fs from 'node:fs'
import colors from 'colors/safe'
import { diffLines, structuredPatch } from 'diff'

import { retrieveCodeSnippet } from '../routes/vulnCodeSnippet'

const fixesPath = 'data/static/codefixes'
const cacheFile = 'rsn/cache.json'

type CacheData = Record<string, {
  added: number[]
  removed: number[]
}>

function readFiles () {
  const files = fs.readdirSync(fixesPath)
  const keys = files.filter((file: string) => !file.endsWith('.info.yml') && !file.endsWith('.editorconfig'))
  return keys
}

function writeToFile (json: CacheData) {
  fs.writeFileSync(cacheFile, JSON.stringify(json, null, '\t'))
}

function getDataFromFile () {
  const data = fs.readFileSync(cacheFile).toString()
  return JSON.parse(data)
}

function filterString (text: string) {
  text = text.replace(/\r/g, '')
  return text
}

const checkDiffs = async (keys: string[]) => {
  const data: CacheData = keys.reduce((prev, curr) => {
    return {
      ...prev,
      [curr]: {
        added: [],
        removed: []
      }
    }
  }, {})
  for (const val of keys) {
    await retrieveCodeSnippet(val.split('_')[0])
      .then(snippet => {
        if (snippet == null) return
        process.stdout.write(val + ': ')
        const fileData = fs.readFileSync(fixesPath + '/' + val).toString()
        const diff = diffLines(filterString(fileData), filterString(snippet.snippet))
        let line = 0
        for (const part of diff) {
          if (!part.count) continue
          if (part.removed) continue
          const prev = line
          line += part.count
          if (!(part.added)) continue
          for (let i = 0; i < part.count; i++) {
            if (!snippet.vulnLines.includes(prev + i + 1) && !snippet.neutralLines.includes(prev + i + 1)) {
              process.stdout.write(colors.red(colors.inverse(prev + i + 1 + '')))
              process.stdout.write(' ')
              data[val].added.push(prev + i + 1)
            } else if (snippet.vulnLines.includes(prev + i + 1)) {
              process.stdout.write(colors.red(colors.bold(prev + i + 1 + ' ')))
            } else if (snippet.neutralLines.includes(prev + i + 1)) {
              process.stdout.write(colors.red(prev + i + 1 + ' '))
            }
          }
        }
        line = 0
        let norm = 0
        for (const part of diff) {
          if (!part.count) continue
          if (part.added) {
            norm--
            continue
          }
          const prev = line
          line += part.count
          if (!(part.removed)) continue
          let temp = norm
          for (let i = 0; i < part.count; i++) {
            if (!snippet.vulnLines.includes(prev + i + 1 - norm) && !snippet.neutralLines.includes(prev + i + 1 - norm)) {
              process.stdout.write(colors.green(colors.inverse((prev + i + 1 - norm + ''))))
              process.stdout.write(' ')
              data[val].removed.push(prev + i + 1 - norm)
            } else if (snippet.vulnLines.includes(prev + i + 1 - norm)) {
              process.stdout.write(colors.green(colors.bold(prev + i + 1 - norm + ' ')))
            } else if (snippet.neutralLines.includes(prev + i + 1 - norm)) {
              process.stdout.write(colors.green(prev + i + 1 - norm + ' '))
            }
            temp++
          }
          norm = temp
        }
        process.stdout.write('\n')
      })
      .catch(err => {
        console.log(err)
      })
  }
  return data
}

async function seePatch (file: string) {
  const fileData = fs.readFileSync(fixesPath + '/' + file).toString()
  const snippet = await retrieveCodeSnippet(file.split('_')[0])
  if (snippet == null) return
  const patch = structuredPatch(file, file, filterString(snippet.snippet), filterString(fileData))
  console.log(colors.bold(file + '\n'))
  for (const hunk of patch.hunks) {
    for (const line of hunk.lines) {
      if (line[0] === '-') {
        console.log(colors.red(line))
      } else if (line[0] === '+') {
        console.log(colors.green(line))
      } else {
        console.log(line)
      }
    }
  }
  console.log('---------------------------------------')
}

function checkData (data: CacheData, fileData: CacheData) {
  const filesWithDiff = []
  for (const key in data) {
    const fileDataValueAdded = fileData[key].added.sort((a, b) => a - b)
    const dataValueAdded = data[key].added.sort((a, b) => a - b)
    const fileDataValueRemoved = fileData[key].added.sort((a, b) => a - b)
    const dataValueAddedRemoved = data[key].added.sort((a, b) => a - b)
    if (fileDataValueAdded.length === dataValueAdded.length && fileDataValueRemoved.length === dataValueAddedRemoved.length) {
      if (!dataValueAdded.every((val: number, ind: number) => fileDataValueAdded[ind] === val)) {
        console.log(colors.red(key))
        filesWithDiff.push(key)
      }
      if (!dataValueAddedRemoved.every((val: number, ind: number) => fileDataValueRemoved[ind] === val)) {
        console.log(colors.red(key))
        filesWithDiff.push(key)
      }
    } else {
      console.log(colors.red(key))
      filesWithDiff.push(key)
    }
  }
  return filesWithDiff
}

export {
  checkDiffs,
  writeToFile,
  getDataFromFile,
  readFiles,
  seePatch,
  checkData
}


/* ===== FILE: ./rsn/rsn-verbose.ts ===== */

import { readFiles, checkDiffs, getDataFromFile, checkData, seePatch } from './rsnUtil'
import colors from 'colors/safe'

const keys = readFiles()
checkDiffs(keys)
  .then(data => {
    console.log('---------------------------------------')
    const fileData = getDataFromFile()
    const filesWithDiff = checkData(data, fileData)
    if (filesWithDiff.length === 0) {
      console.log(`${colors.green(colors.bold('No new file diffs recognized since last lock!'))} No action required.`)
    } else {
      console.log(`${colors.red(colors.bold('New file diffs recognized since last lock!'))} Double-check and amend listed files and lock new state with ${colors.bold('npm run rsn:update')}`)
      console.log(`Be aware that diffs for the ${filesWithDiff.length} affected files below contain ${colors.bold('all changes')} including locked & cached ones! Compare carefully!`)
      console.log('---------------------------------------')
      // eslint-disable-next-line @typescript-eslint/no-misused-promises
      filesWithDiff.forEach(async file => { await seePatch(file) })
      process.exitCode = 1
    }
  })
  .catch(err => {
    console.log(err)
    process.exitCode = 1
  })


/* ===== FILE: ./rsn/rsn.ts ===== */

import { readFiles, checkDiffs, getDataFromFile, checkData } from './rsnUtil'
import colors from 'colors/safe'

const keys = readFiles()
checkDiffs(keys)
  .then(data => {
    console.log('---------------------------------------')
    const fileData = getDataFromFile()
    const filesWithDiff = checkData(data, fileData)
    if (filesWithDiff.length === 0) {
      console.log(`${colors.green(colors.bold('No new file diffs recognized since last lock!'))} No action required.`)
    } else {
      console.log(`${colors.red(colors.bold('New file diffs recognized since last lock!'))} Double-check and amend listed files and lock new state with ${colors.bold('npm run rsn:update')}`)
      console.log('---------------------------------------')
      process.exitCode = 1
    }
  })
  .catch(err => {
    console.log(err)
    process.exitCode = 1
  })


/* ===== FILE: ./rsn/rsn-update.ts ===== */

import { readFiles, checkDiffs, writeToFile } from './rsnUtil'
import colors from 'colors/safe'

const keys = readFiles()
checkDiffs(keys)
  .then(data => {
    console.log(('---------------------------------------'))
    writeToFile(data)
    console.log(`${colors.bold('All file diffs have been locked!')} Commit changed cache.json to git.`)
  })
  .catch(err => {
    console.log(err)
    process.exitCode = 1
  })


/* ===== FILE: ./app.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

async function app () {
  const { default: validateDependencies } = await import('./lib/startup/validateDependenciesBasic')
  await validateDependencies()

  const server = await import('./server')
  await server.start()
}

app()
  .catch(err => {
    throw err
  })


/* ===== FILE: ./models/wallet.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

/* jslint node: true */
import {
  Model,
  type InferAttributes,
  type InferCreationAttributes,
  DataTypes,
  type CreationOptional,
  type Sequelize
} from 'sequelize'

class Wallet extends Model<
InferAttributes<Wallet>,
InferCreationAttributes<Wallet>
> {
  declare UserId: number
  declare id: CreationOptional<number>
  declare balance: CreationOptional<number>
}

const WalletModelInit = (sequelize: Sequelize) => {
  Wallet.init(
    {
      UserId: {
        type: DataTypes.INTEGER
      },
      id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
      },
      balance: {
        type: DataTypes.INTEGER,
        validate: {
          isInt: true
        },
        defaultValue: 0
      }
    },
    {
      tableName: 'Wallets',
      sequelize
    }
  )
}

export { Wallet as WalletModel, WalletModelInit }


/* ===== FILE: ./models/recycle.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

/* jslint node: true */

import {
  Model,
  type InferAttributes,
  type InferCreationAttributes,
  DataTypes,
  type CreationOptional,
  type Sequelize
} from 'sequelize'

class Recycle extends Model<
InferAttributes<Recycle>,
InferCreationAttributes<Recycle>
> {
  declare id: CreationOptional<number>
  declare UserId: number
  declare AddressId: number
  declare quantity: number
  declare isPickup: boolean
  declare date: string
}

const RecycleModelInit = (sequelize: Sequelize) => {
  Recycle.init(
    {
      UserId: {
        type: DataTypes.INTEGER
      },
      AddressId: {
        type: DataTypes.INTEGER
      },
      id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
      },
      quantity: DataTypes.INTEGER,
      isPickup: { type: DataTypes.BOOLEAN, defaultValue: false },
      date: DataTypes.DATE
    },
    {
      tableName: 'Recycles',
      sequelize
    }
  )
}

export { Recycle as RecycleModel, RecycleModelInit }


/* ===== FILE: ./models/securityQuestion.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

/* jslint node: true */
import {
  Model,
  type InferAttributes,
  type InferCreationAttributes,
  DataTypes,
  type CreationOptional,
  type Sequelize
} from 'sequelize'

class SecurityQuestion extends Model<
InferAttributes<SecurityQuestion>,
InferCreationAttributes<SecurityQuestion>
> {
  declare id: CreationOptional<number>
  declare question: string
}

const SecurityQuestionModelInit = (sequelize: Sequelize) => {
  SecurityQuestion.init(
    {
      id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
      },
      question: {
        type: DataTypes.STRING
      }
    },
    {
      tableName: 'SecurityQuestions',
      sequelize
    }
  )
}

export { SecurityQuestion as SecurityQuestionModel, SecurityQuestionModelInit }


/* ===== FILE: ./models/challenge.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

/* jslint node: true */
import {
  Model,
  type InferAttributes,
  type InferCreationAttributes,
  DataTypes,
  type CreationOptional,
  type Sequelize
} from 'sequelize'

const CHALLENGE_KEYS = [
  'restfulXssChallenge',
  'accessLogDisclosureChallenge',
  'registerAdminChallenge',
  'adminSectionChallenge',
  'fileWriteChallenge',
  'resetPasswordBjoernOwaspChallenge',
  'tokenSaleChallenge',
  'nftUnlockChallenge',
  'nftMintChallenge',
  'web3WalletChallenge',
  'web3SandboxChallenge',
  'rceChallenge',
  'captchaBypassChallenge',
  'changePasswordBenderChallenge',
  'christmasSpecialChallenge',
  'usernameXssChallenge',
  'persistedXssUserChallenge',
  'directoryListingChallenge',
  'localXssChallenge',
  'dbSchemaChallenge',
  'deprecatedInterfaceChallenge',
  'easterEggLevelOneChallenge',
  'emailLeakChallenge',
  'emptyUserRegistration',
  'ephemeralAccountantChallenge',
  'errorHandlingChallenge',
  'manipulateClockChallenge',
  'extraLanguageChallenge',
  'feedbackChallenge',
  'forgedCouponChallenge',
  'forgedFeedbackChallenge',
  'forgedReviewChallenge',
  'jwtForgedChallenge',
  'forgottenDevBackupChallenge',
  'forgottenBackupChallenge',
  'typosquattingAngularChallenge',
  'ghostLoginChallenge',
  'dataExportChallenge',
  'httpHeaderXssChallenge',
  'continueCodeChallenge',
  'dlpPasswordSprayingChallenge',
  'dlpPastebinDataLeakChallenge',
  'typosquattingNpmChallenge',
  'loginAdminChallenge',
  'loginAmyChallenge',
  'loginBenderChallenge',
  'oauthUserPasswordChallenge',
  'loginJimChallenge',
  'loginRapperChallenge',
  'loginSupportChallenge',
  'basketManipulateChallenge',
  'misplacedSignatureFileChallenge',
  'timingAttackChallenge',
  'easterEggLevelTwoChallenge',
  'noSqlCommandChallenge',
  'noSqlOrdersChallenge',
  'noSqlReviewsChallenge',
  'redirectCryptoCurrencyChallenge',
  'weakPasswordChallenge',
  'negativeOrderChallenge',
  'premiumPaywallChallenge',
  'privacyPolicyChallenge',
  'privacyPolicyProofChallenge',
  'changeProductChallenge',
  'reflectedXssChallenge',
  'passwordRepeatChallenge',
  'resetPasswordBenderChallenge',
  'resetPasswordBjoernChallenge',
  'resetPasswordJimChallenge',
  'resetPasswordMortyChallenge',
  'retrieveBlueprintChallenge',
  'ssrfChallenge',
  'sstiChallenge',
  'scoreBoardChallenge',
  'securityPolicyChallenge',
  'persistedXssFeedbackChallenge',
  'hiddenImageChallenge',
  'rceOccupyChallenge',
  'supplyChainAttackChallenge',
  'twoFactorAuthUnsafeSecretStorageChallenge',
  'jwtUnsignedChallenge',
  'uploadSizeChallenge',
  'uploadTypeChallenge',
  'unionSqlInjectionChallenge',
  'videoXssChallenge',
  'basketAccessChallenge',
  'knownVulnerableComponentChallenge',
  'weirdCryptoChallenge',
  'redirectChallenge',
  'xxeFileDisclosureChallenge',
  'xxeDosChallenge',
  'yamlBombChallenge',
  'zeroStarsChallenge',
  'missingEncodingChallenge',
  'svgInjectionChallenge',
  'exposedMetricsChallenge',
  'freeDeluxeChallenge',
  'csrfChallenge',
  'xssBonusChallenge',
  'resetPasswordUvoginChallenge',
  'geoStalkingMetaChallenge',
  'geoStalkingVisualChallenge',
  'killChatbotChallenge',
  'nullByteChallenge',
  'bullyChatbotChallenge',
  'lfrChallenge',
  'closeNotificationsChallenge',
  'csafChallenge',
  'exposedCredentialsChallenge',
  'leakedApiKeyChallenge'
] as const

export type ChallengeKey = typeof CHALLENGE_KEYS[number]

class Challenge extends Model<
InferAttributes<Challenge>,
InferCreationAttributes<Challenge>
> {
  declare id: CreationOptional<number>
  declare name: string
  declare category: string
  declare description: string
  declare difficulty: number
  declare hint: string | null
  declare hintUrl: string | null
  declare mitigationUrl: CreationOptional<string> | null
  declare key: ChallengeKey
  declare disabledEnv: CreationOptional<string> | null
  declare tutorialOrder: CreationOptional<number> | null
  declare tags: string | undefined
  declare solved: CreationOptional<boolean>
  declare codingChallengeStatus: CreationOptional<number>
  declare hasCodingChallenge: boolean
}

const ChallengeModelInit = (sequelize: Sequelize) => {
  Challenge.init(
    {
      id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
      },
      key: {
        type: DataTypes.ENUM,
        values: CHALLENGE_KEYS
      },
      name: DataTypes.STRING,
      category: DataTypes.STRING,
      tags: DataTypes.STRING,
      description: DataTypes.STRING,
      difficulty: DataTypes.INTEGER,
      hint: DataTypes.STRING,
      hintUrl: DataTypes.STRING,
      mitigationUrl: DataTypes.STRING,
      solved: DataTypes.BOOLEAN,
      disabledEnv: DataTypes.STRING,
      tutorialOrder: DataTypes.NUMBER,
      codingChallengeStatus: DataTypes.NUMBER,
      hasCodingChallenge: DataTypes.BOOLEAN
    },
    {
      tableName: 'Challenges',
      sequelize
    }
  )
}

export { Challenge as ChallengeModel, ChallengeModelInit }


/* ===== FILE: ./models/basketitem.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

/* jslint node: true */
import {
  Model,
  type InferAttributes,
  type InferCreationAttributes,
  DataTypes,
  type CreationOptional,
  type Sequelize
} from 'sequelize'

class BasketItem extends Model<
InferAttributes<BasketItem>,
InferCreationAttributes<BasketItem>
> {
  declare ProductId: number
  declare BasketId: number
  declare id: CreationOptional<number>
  declare quantity: number
}

const BasketItemModelInit = (sequelize: Sequelize) => {
  BasketItem.init(
    {
      ProductId: {
        type: DataTypes.INTEGER
      },
      BasketId: {
        type: DataTypes.INTEGER
      },
      id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
      },
      quantity: DataTypes.INTEGER
    },
    {
      tableName: 'BasketItems',
      sequelize
    }
  )
}

export { BasketItem as BasketItemModel, BasketItemModelInit }


/* ===== FILE: ./models/complaint.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

/* jslint node: true */

import {
  Model,
  type InferAttributes,
  type InferCreationAttributes,
  DataTypes,
  type CreationOptional,
  type Sequelize
} from 'sequelize'

class Complaint extends Model<
InferAttributes<Complaint>,
InferCreationAttributes<Complaint>
> {
  declare UserId: number
  declare id: CreationOptional<number>
  declare message: string
  declare file: CreationOptional<string>
}

const ComplaintModelInit = (sequelize: Sequelize) => {
  Complaint.init(
    {
      UserId: {
        type: DataTypes.INTEGER
      },
      id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
      },
      message: DataTypes.STRING,
      file: DataTypes.STRING
    },
    {
      tableName: 'Complaints',
      sequelize
    }
  )
}

export { Complaint as ComplaintModel, ComplaintModelInit }


/* ===== FILE: ./models/quantity.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

/* jslint node: true */

import {
  Model,
  type InferAttributes,
  type InferCreationAttributes,
  DataTypes,
  type CreationOptional,
  type Sequelize
} from 'sequelize'

class Quantity extends Model<
InferAttributes<Quantity>,
InferCreationAttributes<Quantity>
> {
  declare ProductId: number
  declare id: CreationOptional<number>
  declare quantity: number
  declare limitPerUser: number | null
}

const QuantityModelInit = (sequelize: Sequelize) => {
  Quantity.init(
    {
      ProductId: {
        type: DataTypes.INTEGER
      },
      id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
      },
      quantity: {
        type: DataTypes.INTEGER,
        validate: {
          isInt: true
        }
      },
      limitPerUser: {
        type: DataTypes.INTEGER,
        validate: {
          isInt: true
        },
        defaultValue: null
      }
    },
    {
      tableName: 'Quantities',
      sequelize
    }
  )
}

export { Quantity as QuantityModel, QuantityModelInit }


/* ===== FILE: ./models/product.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

/* jslint node: true */
import * as utils from '../lib/utils'
import * as challengeUtils from '../lib/challengeUtils'
import {
  Model,
  type InferAttributes,
  type InferCreationAttributes,
  DataTypes,
  type CreationOptional,
  type Sequelize
} from 'sequelize'
import { type BasketItemModel } from './basketitem'
import { challenges } from '../data/datacache'
import * as security from '../lib/insecurity'

class Product extends Model<
InferAttributes<Product>,
InferCreationAttributes<Product>
> {
  declare id: CreationOptional<number>
  declare name: string
  declare description: string
  declare price: number
  declare deluxePrice: number
  declare image: string
  declare BasketItem?: CreationOptional<BasketItemModel> // Note this is optional since it's only populated when explicitly requested in code
}

const ProductModelInit = (sequelize: Sequelize) => {
  Product.init(
    {
      id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
      },
      name: DataTypes.STRING,
      description: {
        type: DataTypes.STRING,
        set (description: string) {
          if (utils.isChallengeEnabled(challenges.restfulXssChallenge)) {
            challengeUtils.solveIf(challenges.restfulXssChallenge, () => {
              return utils.contains(
                description,
                '<iframe src="javascript:alert(`xss`)">'
              )
            })
          } else {
            description = security.sanitizeSecure(description)
          }
          this.setDataValue('description', description)
        }
      },
      price: DataTypes.DECIMAL,
      deluxePrice: DataTypes.DECIMAL,
      image: DataTypes.STRING
    },
    {
      tableName: 'Products',
      sequelize,
      paranoid: true
    }
  )
}

export { Product as ProductModel, ProductModelInit }


/* ===== FILE: ./models/basket.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

/* jslint node: true */

import {
  Model,
  type InferAttributes,
  type InferCreationAttributes,
  DataTypes,
  type CreationOptional,
  type NonAttribute,
  type Sequelize
} from 'sequelize'
import { type ProductModel } from './product'

class Basket extends Model<
InferAttributes<Basket>,
InferCreationAttributes<Basket>
> {
  declare UserId: CreationOptional<number>
  declare id: CreationOptional<number>
  declare coupon: CreationOptional<string> | null
  declare Products?: NonAttribute<ProductModel[]>
}

const BasketModelInit = (sequelize: Sequelize) => {
  Basket.init(
    {
      id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
      },
      coupon: DataTypes.STRING,
      UserId: {
        type: DataTypes.INTEGER
      }
    },
    {
      tableName: 'Baskets',
      sequelize
    }
  )
}

export { Basket as BasketModel, BasketModelInit }


/* ===== FILE: ./models/captcha.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import {
  Model,
  type InferAttributes,
  type InferCreationAttributes,
  DataTypes,
  type Sequelize
} from 'sequelize'

class Captcha extends Model<
InferAttributes<Captcha>,
InferCreationAttributes<Captcha>
> {
  declare captchaId: number
  declare captcha: string
  declare answer: string
}

const CaptchaModelInit = (sequelize: Sequelize) => {
  Captcha.init(
    {
      captchaId: {
        type: DataTypes.INTEGER
      },
      captcha: DataTypes.STRING,
      answer: DataTypes.STRING
    },
    {
      tableName: 'Captchas',
      sequelize
    }
  )
}

export { Captcha as CaptchaModel, CaptchaModelInit }


/* ===== FILE: ./models/card.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

/* jslint node: true */
import {
  Model,
  type InferAttributes,
  type InferCreationAttributes,
  DataTypes,
  type CreationOptional,
  type Sequelize
} from 'sequelize'
class Card extends Model<
InferAttributes<Card>,
InferCreationAttributes<Card>
> {
  declare UserId: number
  declare id: CreationOptional<number>
  declare fullName: string
  declare cardNum: number
  declare expMonth: number
  declare expYear: number
}

const CardModelInit = (sequelize: Sequelize) => {
  Card.init(
    {
      UserId: {
        type: DataTypes.INTEGER
      },
      id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
      },
      fullName: DataTypes.STRING,
      cardNum: {
        type: DataTypes.INTEGER,
        validate: {
          isInt: true,
          min: 1000000000000000,
          max: 9999999999999998
        }
      },
      expMonth: {
        type: DataTypes.INTEGER,
        validate: {
          isInt: true,
          min: 1,
          max: 12
        }
      },
      expYear: {
        type: DataTypes.INTEGER,
        validate: {
          isInt: true,
          min: 2080,
          max: 2099
        }
      }
    },
    {
      tableName: 'Cards',
      sequelize
    }
  )
}

export { Card as CardModel, CardModelInit }


/* ===== FILE: ./models/relations.ts ===== */

import { type Sequelize } from 'sequelize/types'
import { AddressModel } from './address'
import { BasketModel } from './basket'
import { BasketItemModel } from './basketitem'
import { CardModel } from './card'
import { ComplaintModel } from './complaint'
import { FeedbackModel } from './feedback'
import { ImageCaptchaModel } from './imageCaptcha'
import { MemoryModel } from './memory'
import { PrivacyRequestModel } from './privacyRequests'
import { ProductModel } from './product'
import { QuantityModel } from './quantity'
import { RecycleModel } from './recycle'
import { SecurityAnswerModel } from './securityAnswer'
import { SecurityQuestionModel } from './securityQuestion'
import { UserModel } from './user'
import { WalletModel } from './wallet'

import { makeKeyNonUpdatable } from '../lib/noUpdate'

const relationsInit = (_sequelize: Sequelize) => {
  AddressModel.belongsTo(UserModel, {
    constraints: true,
    foreignKeyConstraint: true,
    foreignKey: {
      name: 'UserId'
    }
  })

  BasketModel.belongsTo(UserModel, {
    constraints: true,
    foreignKeyConstraint: true,
    foreignKey: {
      name: 'UserId'
    }
  })
  BasketModel.belongsToMany(ProductModel, {
    through: BasketItemModel,
    as: 'Products',
    foreignKey: {
      name: 'BasketId'
    }
  })
  // @ts-expect-error FIXME type mismatch
  makeKeyNonUpdatable(BasketItemModel, 'BasketId')

  CardModel.belongsTo(UserModel, {
    constraints: true,
    foreignKeyConstraint: true,
    foreignKey: {
      name: 'UserId'
    }
  })

  ComplaintModel.belongsTo(UserModel, {
    constraints: true,
    foreignKeyConstraint: true,
    foreignKey: {
      name: 'UserId'
    }
  })

  FeedbackModel.belongsTo(UserModel, {
    foreignKey: {
      name: 'UserId'
    }
  }) // no FK constraint to allow anonymous feedback posts

  ImageCaptchaModel.belongsTo(UserModel, {
    foreignKey: {
      name: 'UserId'
    }
  })

  MemoryModel.belongsTo(UserModel, {
    constraints: true,
    foreignKeyConstraint: true,
    foreignKey: {
      name: 'UserId'
    }
  })

  PrivacyRequestModel.belongsTo(UserModel, {
    constraints: true,
    foreignKeyConstraint: true,
    foreignKey: {
      name: 'UserId'
    }
  })

  ProductModel.belongsToMany(BasketModel, {
    through: BasketItemModel,
    foreignKey: {
      name: 'ProductId'
    }
  })
  // @ts-expect-error FIXME type mismatch
  makeKeyNonUpdatable(BasketItemModel, 'ProductId')

  QuantityModel.belongsTo(ProductModel, {
    constraints: true,
    foreignKeyConstraint: true,
    foreignKey: {
      name: 'ProductId'
    }
  })

  RecycleModel.belongsTo(UserModel, {
    constraints: true,
    foreignKeyConstraint: true,
    foreignKey: {
      name: 'UserId'
    }
  })
  RecycleModel.belongsTo(AddressModel, {
    constraints: true,
    foreignKeyConstraint: true,
    foreignKey: {
      name: 'AddressId'
    }
  })

  SecurityAnswerModel.belongsTo(UserModel, {
    foreignKey: {
      name: 'UserId'
    }
  })
  SecurityAnswerModel.belongsTo(SecurityQuestionModel, {
    constraints: true,
    foreignKeyConstraint: true,
    foreignKey: {
      name: 'SecurityQuestionId'
    }
  })

  WalletModel.belongsTo(UserModel, {
    constraints: true,
    foreignKeyConstraint: true,
    foreignKey: {
      name: 'UserId'
    }
  })
}

export { relationsInit }


/* ===== FILE: ./models/privacyRequests.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

/* jslint node: true */

import {
  Model,
  type InferAttributes,
  type InferCreationAttributes,
  DataTypes,
  type CreationOptional,
  type Sequelize
} from 'sequelize'

class PrivacyRequestModel extends Model<
InferAttributes<PrivacyRequestModel>,
InferCreationAttributes<PrivacyRequestModel>
> {
  declare id: CreationOptional<number>
  declare UserId: number
  declare deletionRequested: boolean
}
const PrivacyRequestModelInit = (sequelize: Sequelize) => {
  PrivacyRequestModel.init(
    {
      id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
      },
      UserId: {
        type: DataTypes.INTEGER
      },
      deletionRequested: {
        type: DataTypes.BOOLEAN,
        defaultValue: false
      }
    },
    {
      tableName: 'PrivacyRequests',
      sequelize
    }
  )
}

export { PrivacyRequestModel, PrivacyRequestModelInit }


/* ===== FILE: ./models/feedback.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

/* jslint node: true */
import * as utils from '../lib/utils'
import * as challengeUtils from '../lib/challengeUtils'
import {
  Model,
  type InferAttributes,
  type InferCreationAttributes,
  DataTypes,
  type CreationOptional,
  type Sequelize
} from 'sequelize'
import { challenges } from '../data/datacache'
import * as security from '../lib/insecurity'

class Feedback extends Model<
InferAttributes<Feedback>,
InferCreationAttributes<Feedback>
> {
  declare UserId: number | null
  declare id: CreationOptional<number>
  declare comment: string
  declare rating: number
}
const FeedbackModelInit = (sequelize: Sequelize) => {
  Feedback.init(
    {
      UserId: {
        type: DataTypes.INTEGER
      },
      id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
      },
      comment: {
        type: DataTypes.STRING,
        set (comment: string) {
          let sanitizedComment: string
          if (utils.isChallengeEnabled(challenges.persistedXssFeedbackChallenge)) {
            sanitizedComment = security.sanitizeHtml(comment)
            challengeUtils.solveIf(challenges.persistedXssFeedbackChallenge, () => {
              return utils.contains(
                sanitizedComment,
                '<iframe src="javascript:alert(`xss`)">'
              )
            })
          } else {
            sanitizedComment = security.sanitizeSecure(comment)
          }
          this.setDataValue('comment', sanitizedComment)
        }
      },
      rating: {
        type: DataTypes.INTEGER,
        allowNull: false,
        set (rating: number) {
          this.setDataValue('rating', rating)
          challengeUtils.solveIf(challenges.zeroStarsChallenge, () => {
            return Number(rating) === 0
          })
        }
      }
    },
    {
      tableName: 'Feedbacks',
      sequelize
    }
  )
}

export { Feedback as FeedbackModel, FeedbackModelInit }


/* ===== FILE: ./models/imageCaptcha.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import {
  Model,
  type InferAttributes,
  type InferCreationAttributes,
  DataTypes,
  type CreationOptional,
  type Sequelize
} from 'sequelize'

class ImageCaptcha extends Model<
InferAttributes<ImageCaptcha>,
InferCreationAttributes<ImageCaptcha>
> {
  declare id: CreationOptional<number>
  declare image: string
  declare answer: string
  declare UserId: number
  declare createdAt: CreationOptional<Date>
}

const ImageCaptchaModelInit = (sequelize: Sequelize) => {
  ImageCaptcha.init(
    {
      id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
      },
      image: DataTypes.STRING,
      answer: DataTypes.STRING,
      UserId: { type: DataTypes.INTEGER },
      createdAt: DataTypes.DATE
    },
    {
      tableName: 'ImageCaptchas',
      sequelize
    }
  )
}

export { ImageCaptcha as ImageCaptchaModel, ImageCaptchaModelInit }


/* ===== FILE: ./models/memory.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

/* jslint node: true */

import {
  Model,
  type InferAttributes,
  type InferCreationAttributes,
  DataTypes,
  type CreationOptional,
  type Sequelize
} from 'sequelize'

class Memory extends Model<
InferAttributes<Memory>,
InferCreationAttributes<Memory>
> {
  declare UserId: number
  declare id: CreationOptional<number>
  declare caption: string
  declare imagePath: string
}

const MemoryModelInit = (sequelize: Sequelize) => {
  Memory.init(
    {
      UserId: {
        type: DataTypes.INTEGER
      },
      id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
      },
      caption: DataTypes.STRING,
      imagePath: DataTypes.STRING
    },
    {
      tableName: 'Memories',
      sequelize
    }
  )
}

export { Memory as MemoryModel, MemoryModelInit }


/* ===== FILE: ./models/index.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { AddressModelInit } from './address'
import { BasketModelInit } from './basket'
import { BasketItemModelInit } from './basketitem'
import { CaptchaModelInit } from './captcha'
import { CardModelInit } from './card'
import { ChallengeModelInit } from './challenge'
import { ComplaintModelInit } from './complaint'
import { DeliveryModelInit } from './delivery'
import { FeedbackModelInit } from './feedback'
import { ImageCaptchaModelInit } from './imageCaptcha'
import { MemoryModelInit } from './memory'
import { PrivacyRequestModelInit } from './privacyRequests'
import { ProductModelInit } from './product'
import { QuantityModelInit } from './quantity'
import { RecycleModelInit } from './recycle'
import { relationsInit } from './relations'
import { SecurityAnswerModelInit } from './securityAnswer'
import { SecurityQuestionModelInit } from './securityQuestion'
import { UserModelInit } from './user'
import { WalletModelInit } from './wallet'
import { Sequelize, Transaction } from 'sequelize'

/* jslint node: true */
const sequelize = new Sequelize('database', 'username', 'password', {
  dialect: 'sqlite',
  retry: {
    match: [/SQLITE_BUSY/],
    name: 'query',
    max: 5
  },
  transactionType: Transaction.TYPES.IMMEDIATE,
  storage: 'data/juiceshop.sqlite',
  logging: false
})
AddressModelInit(sequelize)
BasketModelInit(sequelize)
BasketItemModelInit(sequelize)
CaptchaModelInit(sequelize)
CardModelInit(sequelize)
ChallengeModelInit(sequelize)
ComplaintModelInit(sequelize)
DeliveryModelInit(sequelize)
FeedbackModelInit(sequelize)
ImageCaptchaModelInit(sequelize)
MemoryModelInit(sequelize)
PrivacyRequestModelInit(sequelize)
ProductModelInit(sequelize)
QuantityModelInit(sequelize)
RecycleModelInit(sequelize)
SecurityAnswerModelInit(sequelize)
SecurityQuestionModelInit(sequelize)
UserModelInit(sequelize)
WalletModelInit(sequelize)

relationsInit(sequelize)

export { sequelize }


/* ===== FILE: ./models/securityAnswer.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

/* jslint node: true */
import {
  Model,
  type InferAttributes,
  type InferCreationAttributes,
  DataTypes,
  type CreationOptional,
  type Sequelize
} from 'sequelize'
import * as security from '../lib/insecurity'

class SecurityAnswer extends Model<
InferAttributes<SecurityAnswer>,
InferCreationAttributes<SecurityAnswer>
> {
  declare SecurityQuestionId: number
  declare UserId: number
  declare id: CreationOptional<number>
  declare answer: string
}

const SecurityAnswerModelInit = (sequelize: Sequelize) => {
  SecurityAnswer.init(
    {
      UserId: {
        type: DataTypes.INTEGER,
        unique: true
      },
      SecurityQuestionId: {
        type: DataTypes.INTEGER
      },

      id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
      },
      answer: {
        type: DataTypes.STRING,
        set (answer: string) {
          this.setDataValue('answer', security.hmac(answer))
        }
      }
    },
    {
      tableName: 'SecurityAnswers',
      sequelize
    }
  )
}

export { SecurityAnswer as SecurityAnswerModel, SecurityAnswerModelInit }


/* ===== FILE: ./models/user.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

/* jslint node: true */
import config from 'config'
import {
  type InferAttributes,
  type InferCreationAttributes,
  Model,
  DataTypes,
  type CreationOptional,
  type Sequelize
} from 'sequelize'
import * as challengeUtils from '../lib/challengeUtils'
import * as utils from '../lib/utils'
import { challenges } from '../data/datacache'
import * as security from '../lib/insecurity'

class User extends Model<
InferAttributes<User>,
InferCreationAttributes<User>
> {
  declare id: CreationOptional<number>
  declare username: string | undefined
  declare email: CreationOptional<string>
  declare password: CreationOptional<string>
  declare role: CreationOptional<string>
  declare deluxeToken: CreationOptional<string>
  declare lastLoginIp: CreationOptional<string>
  declare profileImage: CreationOptional<string>
  declare totpSecret: CreationOptional<string>
  declare isActive: CreationOptional<boolean>
}

const UserModelInit = (sequelize: Sequelize) => { // vuln-code-snippet start weakPasswordChallenge
  User.init(
    { // vuln-code-snippet hide-start
      id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
      },
      username: {
        type: DataTypes.STRING,
        defaultValue: '',
        set (username: string) {
          if (utils.isChallengeEnabled(challenges.persistedXssUserChallenge)) {
            username = security.sanitizeLegacy(username)
          } else {
            username = security.sanitizeSecure(username)
          }
          this.setDataValue('username', username)
        }
      },
      email: {
        type: DataTypes.STRING,
        unique: true,
        set (email: string) {
          if (utils.isChallengeEnabled(challenges.persistedXssUserChallenge)) {
            challengeUtils.solveIf(challenges.persistedXssUserChallenge, () => {
              return utils.contains(
                email,
                '<iframe src="javascript:alert(`xss`)">'
              )
            })
          } else {
            email = security.sanitizeSecure(email)
          }
          this.setDataValue('email', email)
        }
      }, // vuln-code-snippet hide-end
      password: {
        type: DataTypes.STRING,
        set (clearTextPassword: string) {
          this.setDataValue('password', security.hash(clearTextPassword)) // vuln-code-snippet vuln-line weakPasswordChallenge
        }
      }, // vuln-code-snippet end weakPasswordChallenge
      role: {
        type: DataTypes.STRING,
        defaultValue: 'customer',
        validate: {
          isIn: [['customer', 'deluxe', 'accounting', 'admin']]
        },
        set (role: string) {
          const profileImage = this.getDataValue('profileImage')
          if (
            role === security.roles.admin &&
          (!profileImage ||
            profileImage === '/assets/public/images/uploads/default.svg')
          ) {
            this.setDataValue(
              'profileImage',
              '/assets/public/images/uploads/defaultAdmin.png'
            )
          }
          this.setDataValue('role', role)
        }
      },
      deluxeToken: {
        type: DataTypes.STRING,
        defaultValue: ''
      },
      lastLoginIp: {
        type: DataTypes.STRING,
        defaultValue: '0.0.0.0'
      },
      profileImage: {
        type: DataTypes.STRING,
        defaultValue: '/assets/public/images/uploads/default.svg'
      },
      totpSecret: {
        type: DataTypes.STRING,
        defaultValue: ''
      },
      isActive: {
        type: DataTypes.BOOLEAN,
        defaultValue: true
      }
    },
    {
      tableName: 'Users',
      paranoid: true,
      sequelize
    }
  )

  User.addHook('afterValidate', async (user: User) => {
    if (
      user.email &&
    user.email.toLowerCase() ===
      `acc0unt4nt@${config.get<string>('application.domain')}`.toLowerCase()
    ) {
      await Promise.reject(
        new Error(
          'Nice try, but this is not how the "Ephemeral Accountant" challenge works!'
        )
      )
    }
  })
}

export { User as UserModel, UserModelInit }


/* ===== FILE: ./models/delivery.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import {
  Model,
  type InferAttributes,
  type InferCreationAttributes,
  DataTypes,
  type CreationOptional,
  type Sequelize
} from 'sequelize'

class Delivery extends Model<
InferAttributes<Delivery>,
InferCreationAttributes<Delivery>
> {
  declare id: CreationOptional<number>
  declare name: string
  declare price: number
  declare deluxePrice: number
  declare eta: number
  declare icon: string
}

const DeliveryModelInit = (sequelize: Sequelize) => {
  Delivery.init(
    {
      id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
      },
      name: DataTypes.STRING,
      price: DataTypes.FLOAT,
      deluxePrice: DataTypes.FLOAT,
      eta: DataTypes.FLOAT,
      icon: DataTypes.STRING
    },
    {
      tableName: 'Deliveries',
      sequelize
    }
  )
}

export { Delivery as DeliveryModel, DeliveryModelInit }


/* ===== FILE: ./models/address.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import {
  type CreationOptional,
  type InferAttributes,
  type InferCreationAttributes,
  Model,
  DataTypes,
  type Sequelize
} from 'sequelize'
/* jslint node: true */
class Address extends Model<
InferAttributes<Address>,
InferCreationAttributes<Address>
> {
  declare UserId: number
  declare id: CreationOptional<number>
  declare fullName: string
  declare mobileNum: number
  declare zipCode: string
  declare streetAddress: string
  declare city: string
  declare state: string | null
  declare country: string
}

const AddressModelInit = (sequelize: Sequelize) => {
  Address.init(
    {
      UserId: {
        type: DataTypes.INTEGER
      },
      id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
      },
      fullName: {
        type: DataTypes.STRING
      },
      mobileNum: {
        type: DataTypes.INTEGER,
        validate: {
          isInt: true,
          min: 1000000,
          max: 9999999999
        }
      },
      zipCode: {
        type: DataTypes.STRING,
        validate: {
          len: [1, 8]
        }
      },
      streetAddress: {
        type: DataTypes.STRING,
        validate: {
          len: [1, 160]
        }
      },
      city: DataTypes.STRING,
      state: DataTypes.STRING,
      country: DataTypes.STRING
    },
    {
      tableName: 'Addresses',
      sequelize
    }
  )
}

export { Address as AddressModel, AddressModelInit }


/* ===== FILE: ./lib/is-windows.ts ===== */

// from https://github.com/jonschlinkert/is-windows MIT Licensed
// inlined to avoid import problems in cypress

export default function isWindows () {
  return process && (process.platform === 'win32' || /^(msys|cygwin)$/.test(process.env.OSTYPE ?? ''))
}


/* ===== FILE: ./lib/accuracy.ts ===== */

/*
 * Copyright (c) 2014-2021 Bjoern Kimminich.
 * SPDX-License-Identifier: MIT
 */

import { type ChallengeKey } from 'models/challenge'
import logger from './logger'
import colors from 'colors/safe'
const solves: Record<string, { 'find it': boolean, 'fix it': boolean, attempts: { 'find it': number, 'fix it': number } }> = {}

type Phase = 'find it' | 'fix it'

export const storeFindItVerdict = (challengeKey: ChallengeKey, verdict: boolean) => {
  storeVerdict(challengeKey, 'find it', verdict)
}

export const storeFixItVerdict = (challengeKey: ChallengeKey, verdict: boolean) => {
  storeVerdict(challengeKey, 'fix it', verdict)
}

export const calculateFindItAccuracy = (challengeKey: ChallengeKey) => {
  return calculateAccuracy(challengeKey, 'find it')
}

export const calculateFixItAccuracy = (challengeKey: ChallengeKey) => {
  return calculateAccuracy(challengeKey, 'fix it')
}

export const totalFindItAccuracy = () => {
  return totalAccuracy('find it')
}

export const totalFixItAccuracy = () => {
  return totalAccuracy('fix it')
}

export const getFindItAttempts = (challengeKey: ChallengeKey) => {
  return solves[challengeKey] ? solves[challengeKey].attempts['find it'] : 0
}

function totalAccuracy (phase: Phase) {
  let sumAccuracy = 0
  let totalSolved = 0
  Object.entries(solves).forEach(([key, value]) => {
    if (value[phase]) {
      sumAccuracy += 1 / value.attempts[phase]
      totalSolved++
    }
  })
  return sumAccuracy / totalSolved
}

function calculateAccuracy (challengeKey: ChallengeKey, phase: Phase) {
  let accuracy = 0
  if (solves[challengeKey][phase]) {
    accuracy = 1 / solves[challengeKey].attempts[phase]
  }
  logger.info(`Accuracy for '${phase === 'fix it' ? 'Fix It' : 'Find It'}' phase of coding challenge ${colors.cyan(challengeKey)}: ${accuracy > 0.5 ? colors.green(accuracy.toString()) : (accuracy > 0.25 ? colors.yellow(accuracy.toString()) : colors.red(accuracy.toString()))}`)
  return accuracy
}

function storeVerdict (challengeKey: ChallengeKey, phase: Phase, verdict: boolean) {
  if (!solves[challengeKey]) {
    solves[challengeKey] = { 'find it': false, 'fix it': false, attempts: { 'find it': 0, 'fix it': 0 } }
  }
  if (!solves[challengeKey][phase]) {
    solves[challengeKey][phase] = verdict
    solves[challengeKey].attempts[phase]++
  }
}


/* ===== FILE: ./lib/config.types.ts ===== */

// manually typed definitions for the config file
// todo(@jannik.hollenbach) migrate the config schema to something which can automatically generate the types

export interface ServerConfig {
  port: number
  basePath: string
  baseUrl: string
}

export interface ApplicationConfig {
  domain: string
  name: string
  logo: string
  favicon: string
  theme: string
  showVersionNumber: boolean
  showGitHubLinks: boolean
  localBackupEnabled: boolean
  numberOfRandomFakeUsers: number
  altcoinName: string
  privacyContactEmail: string
  customMetricsPrefix: string
  chatBot: {
    name: string
    greeting: string
    trainingData: string
    defaultResponse: string
    avatar: string
  }
  social: {
    twitterUrl: string
    facebookUrl: string
    slackUrl: string
    redditUrl: string
    pressKitUrl: string
    nftUrl: string | null
    questionnaireUrl: string | null
  }
  recyclePage: {
    topProductImage: string
    bottomProductImage: string
  }
  welcomeBanner: {
    showOnFirstStart: boolean
    title: string
    message: string
  }
  cookieConsent: {
    message: string
    dismissText: string
    linkText: string
    linkUrl: string
  }
  securityTxt: {
    contact: string
    encryption: string
    acknowledgements: string
    hiring: string
    csaf: string
  }
  promotion: {
    video: string
    subtitles: string
  }
  easterEggPlanet: {
    name: string
    overlayMap: string
  }
  googleOauth: {
    clientId: string
    authorizedRedirects: Array<{ uri: string, proxy?: string }>
  }
}

export interface ChallengesConfig {
  showSolvedNotifications: boolean
  showHints: boolean
  showMitigations: boolean
  codingChallengesEnabled: 'never' | 'solved' | 'always'
  restrictToTutorialsFirst: boolean
  overwriteUrlForProductTamperingChallenge: string
  xssBonusPayload: string
  safetyOverride: boolean
  showFeedbackButtons: boolean
  csafHashValue: string
}

export interface HackingInstructorConfig {
  isEnabled: boolean
  avatarImage: string
  hintPlaybackSpeed: 'faster' | 'fast' | 'normal' | 'slow' | 'slower'
}

export interface Product {
  name: string
  price: number
  deluxePrice?: number
  limitPerUser?: number
  description: string
  image: string
  reviews?: Array<{ text: string, author: string }>
  urlForProductTamperingChallenge?: string
  useForChristmasSpecialChallenge?: boolean
  keywordsForPastebinDataLeakChallenge?: string[]
  deletedDate?: string
  quantity?: number
  fileForRetrieveBlueprintChallenge?: string
  exifForBlueprintChallenge?: string[]
}

export interface Memory {
  image: string
  caption: string
  user?: string
  geoStalkingMetaSecurityQuestion?: number
  geoStalkingMetaSecurityAnswer?: string
  geoStalkingVisualSecurityQuestion?: number
  geoStalkingVisualSecurityAnswer?: string
}

export interface CtfConfig {
  showFlagsInNotifications: boolean
  showCountryDetailsInNotifications: 'none' | 'name' | 'flag' | 'both'
  countryMapping: Record<string, {
    name: string
    code: string
  }>
}

export interface AppConfig {
  server: ServerConfig
  application: ApplicationConfig
  challenges: ChallengesConfig
  hackingInstructor: HackingInstructorConfig
  products: Product[]
  memories: Memory[]
  ctf: CtfConfig
}


/* ===== FILE: ./lib/antiCheat.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import config from 'config'
import colors from 'colors/safe'
import { retrieveCodeSnippet } from '../routes/vulnCodeSnippet'
import { readFixes } from '../routes/vulnCodeFixes'
import { type Challenge } from '../data/types'
import { getCodeChallenges } from './codingChallenges'
import logger from './logger'
import { type NextFunction, type Request, type Response } from 'express'
import * as utils from './utils'
// @ts-expect-error FIXME due to non-existing type definitions for median
import median from 'median'
import { type ChallengeKey } from 'models/challenge'

const coupledChallenges = { // TODO prevent also near-identical challenges (e.g. all null byte file access or dom xss + bonus payload etc.) from counting as cheating
  loginAdminChallenge: ['weakPasswordChallenge'],
  nullByteChallenge: ['easterEggLevelOneChallenge', 'forgottenDevBackupChallenge', 'forgottenBackupChallenge', 'misplacedSignatureFileChallenge'],
  deprecatedInterfaceChallenge: ['uploadTypeChallenge', 'xxeFileDisclosureChallenge', 'xxeDosChallenge', 'yamlBombChallenge'],
  uploadSizeChallenge: ['uploadTypeChallenge', 'xxeFileDisclosureChallenge', 'xxeDosChallenge', 'yamlBombChallenge'],
  uploadTypeChallenge: ['uploadSizeChallenge', 'xxeFileDisclosureChallenge', 'xxeDosChallenge', 'yamlBombChallenge']
}
const trivialChallenges = ['errorHandlingChallenge', 'privacyPolicyChallenge', 'closeNotificationsChallenge']

const solves: Array<{ challenge: any, phase: string, timestamp: Date, cheatScore: number }> = [{ challenge: {}, phase: 'server start', timestamp: new Date(), cheatScore: 0 }] // seed with server start timestamp

const preSolveInteractions: Array<{ challengeKey: ChallengeKey, urlFragments: string[], interactions: boolean[] }> = [
  { challengeKey: 'missingEncodingChallenge', urlFragments: ['/assets/public/images/uploads/%F0%9F%98%BC-'], interactions: [false] },
  { challengeKey: 'directoryListingChallenge', urlFragments: ['/ftp'], interactions: [false] },
  { challengeKey: 'easterEggLevelOneChallenge', urlFragments: ['/ftp', '/ftp/eastere.gg'], interactions: [false, false] },
  { challengeKey: 'easterEggLevelTwoChallenge', urlFragments: ['/ftp', '/gur/qrif/ner/fb/shaal/gurl/uvq/na/rnfgre/rtt/jvguva/gur/rnfgre/rtt'], interactions: [false, false] },
  { challengeKey: 'forgottenDevBackupChallenge', urlFragments: ['/ftp', '/ftp/package.json.bak'], interactions: [false, false] },
  { challengeKey: 'forgottenBackupChallenge', urlFragments: ['/ftp', '/ftp/coupons_2013.md.bak'], interactions: [false, false] },
  { challengeKey: 'loginSupportChallenge', urlFragments: ['/ftp', '/ftp/incident-support.kdbx'], interactions: [false, false] },
  { challengeKey: 'misplacedSignatureFileChallenge', urlFragments: ['/ftp', '/ftp/suspicious_errors.yml'], interactions: [false, false] },
  { challengeKey: 'rceChallenge', urlFragments: ['/api-docs', '/b2b/v2/orders'], interactions: [false, false] },
  { challengeKey: 'rceOccupyChallenge', urlFragments: ['/api-docs', '/b2b/v2/orders'], interactions: [false, false] }
]

export const checkForPreSolveInteractions = () => ({ url }: Request, res: Response, next: NextFunction) => {
  preSolveInteractions.forEach((preSolveInteraction) => {
    for (let i = 0; i < preSolveInteraction.urlFragments.length; i++) {
      if (utils.endsWith(url, preSolveInteraction.urlFragments[i])) {
        preSolveInteraction.interactions[i] = true
      }
    }
  })
  next()
}

export const calculateCheatScore = (challenge: Challenge) => {
  const timestamp = new Date()
  let cheatScore = 0
  let timeFactor = 2
  timeFactor *= (config.get('challenges.showHints') ? 1 : 1.5)
  timeFactor *= (challenge.tutorialOrder && config.get('hackingInstructor.isEnabled') ? 0.5 : 1)
  if (areCoupled(challenge, previous().challenge) || isTrivial(challenge)) {
    timeFactor = 0
  }

  const minutesExpectedToSolve = challenge.difficulty * timeFactor
  const minutesSincePreviousSolve = (timestamp.getTime() - previous().timestamp.getTime()) / 60000
  cheatScore += Math.max(0, 1 - (minutesSincePreviousSolve / minutesExpectedToSolve))

  const preSolveInteraction = preSolveInteractions.find((preSolveInteraction) => preSolveInteraction.challengeKey === challenge.key)
  let percentPrecedingInteraction = -1
  if (preSolveInteraction) {
    percentPrecedingInteraction = preSolveInteraction.interactions.filter(Boolean).length / (preSolveInteraction.interactions.length)
    const multiplierForMissingExpectedInteraction = 1 + Math.max(0, 1 - percentPrecedingInteraction) / 2
    cheatScore *= multiplierForMissingExpectedInteraction
    cheatScore = Math.min(1, cheatScore)
  }

  logger.info(`Cheat score for ${areCoupled(challenge, previous().challenge) ? 'coupled ' : (isTrivial(challenge) ? 'trivial ' : '')}${challenge.tutorialOrder ? 'tutorial ' : ''}${colors.cyan(challenge.key)} solved in ${Math.round(minutesSincePreviousSolve)}min (expected ~${minutesExpectedToSolve}min) with${config.get('challenges.showHints') ? '' : 'out'} hints allowed${percentPrecedingInteraction > -1 ? (' and ' + percentPrecedingInteraction * 100 + '% expected preceding URL interaction') : ''}: ${cheatScore < 0.33 ? colors.green(cheatScore.toString()) : (cheatScore < 0.66 ? colors.yellow(cheatScore.toString()) : colors.red(cheatScore.toString()))}`)
  solves.push({ challenge, phase: 'hack it', timestamp, cheatScore })
  return cheatScore
}

export const calculateFindItCheatScore = async (challenge: Challenge) => {
  const timestamp = new Date()
  let timeFactor = 0.001
  timeFactor *= (challenge.key === 'scoreBoardChallenge' && config.get('hackingInstructor.isEnabled') ? 0.5 : 1)
  let cheatScore = 0

  const codeSnippet = await retrieveCodeSnippet(challenge.key)
  if (codeSnippet == null) {
    return 0
  }
  const { snippet, vulnLines } = codeSnippet
  timeFactor *= vulnLines.length
  const identicalSolved = await checkForIdenticalSolvedChallenge(challenge)
  if (identicalSolved) {
    timeFactor = 0.8 * timeFactor
  }
  const minutesExpectedToSolve = Math.ceil(snippet.length * timeFactor)
  const minutesSincePreviousSolve = (timestamp.getTime() - previous().timestamp.getTime()) / 60000
  cheatScore += Math.max(0, 1 - (minutesSincePreviousSolve / minutesExpectedToSolve))

  logger.info(`Cheat score for "Find it" phase of ${challenge.key === 'scoreBoardChallenge' && config.get('hackingInstructor.isEnabled') ? 'tutorial ' : ''}${colors.cyan(challenge.key)} solved in ${Math.round(minutesSincePreviousSolve)}min (expected ~${minutesExpectedToSolve}min): ${cheatScore < 0.33 ? colors.green(cheatScore.toString()) : (cheatScore < 0.66 ? colors.yellow(cheatScore.toString()) : colors.red(cheatScore.toString()))}`)
  solves.push({ challenge, phase: 'find it', timestamp, cheatScore })

  return cheatScore
}

export const calculateFixItCheatScore = async (challenge: Challenge) => {
  const timestamp = new Date()
  let cheatScore = 0

  const { fixes } = readFixes(challenge.key)
  const minutesExpectedToSolve = Math.floor(fixes.length / 2)
  const minutesSincePreviousSolve = (timestamp.getTime() - previous().timestamp.getTime()) / 60000
  cheatScore += Math.max(0, 1 - (minutesSincePreviousSolve / minutesExpectedToSolve))

  logger.info(`Cheat score for "Fix it" phase of ${colors.cyan(challenge.key)} solved in ${Math.round(minutesSincePreviousSolve)}min (expected ~${minutesExpectedToSolve}min): ${cheatScore < 0.33 ? colors.green(cheatScore.toString()) : (cheatScore < 0.66 ? colors.yellow(cheatScore.toString()) : colors.red(cheatScore.toString()))}`)
  solves.push({ challenge, phase: 'fix it', timestamp, cheatScore })
  return cheatScore
}

export const totalCheatScore = () => {
  return solves.length > 1 ? median(solves.map(({ cheatScore }) => cheatScore)) : 0
}

function areCoupled (challenge: Challenge, previousChallenge: Challenge) {
  // @ts-expect-error FIXME any type issues
  return coupledChallenges[challenge.key]?.indexOf(previousChallenge.key) > -1 || coupledChallenges[previousChallenge.key]?.indexOf(challenge.key) > -1
}

function isTrivial (challenge: Challenge) {
  return trivialChallenges.includes(challenge.key)
}

function previous () {
  return solves[solves.length - 1]
}

const checkForIdenticalSolvedChallenge = async (challenge: Challenge): Promise<boolean> => {
  const codingChallenges = await getCodeChallenges()
  if (!codingChallenges.has(challenge.key)) {
    return false
  }

  const codingChallengesToCompareTo = codingChallenges.get(challenge.key)
  if (!codingChallengesToCompareTo?.snippet) {
    return false
  }
  const snippetToCompareTo = codingChallengesToCompareTo.snippet

  for (const [challengeKey, { snippet }] of codingChallenges.entries()) {
    if (challengeKey === challenge.key) {
      // don't compare to itself
      continue
    }

    if (snippet === snippetToCompareTo) {
      for (const solvedChallenges of solves) {
        if (solvedChallenges.phase === 'find it') {
          return true
        }
      }
    }
  }
  return false
}


/* ===== FILE: ./lib/is-heroku.ts ===== */

// from https://github.com/sindresorhus/is-heroku/tree/main MIT Licensed
// inlined to avoid import problems in cypress

export default () => 'HEROKU' in process.env || ('DYNO' in process.env && process.env.HOME === '/app')


/* ===== FILE: ./lib/utils.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

/* jslint node: true */
import packageJson from '../package.json'
import fs from 'node:fs'
import logger from './logger'
import config from 'config'
import jsSHA from 'jssha'
import download from 'download'
import crypto from 'node:crypto'
import clarinet from 'clarinet'
import type { Challenge } from 'data/types'

import isHeroku from './is-heroku'
import isDocker from './is-docker'
import isWindows from './is-windows'
export { default as isDocker } from './is-docker'
export { default as isWindows } from './is-windows'
// import isGitpod from 'is-gitpod') // FIXME Roll back to this when https://github.com/dword-design/is-gitpod/issues/94 is resolve
const isGitpod = () => false

const months = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC']

export const queryResultToJson = <T>(
  data: T,
  status: string = 'success'
): { data: T, status: string } => {
  return {
    status,
    data
  }
}

export const isUrl = (url: string) => {
  return startsWith(url, 'http')
}

export const startsWith = (str: string, prefix: string) => str ? str.indexOf(prefix) === 0 : false

export const endsWith = (str?: string, suffix?: string) => (str && suffix) ? str.includes(suffix, str.length - suffix.length) : false

export const contains = (str: string, element: string) => str ? str.includes(element) : false // TODO Inline all usages as this function is not adding any functionality to String.includes

export const containsEscaped = function (str: string, element: string) {
  return contains(str, element.replace(/"/g, '\\"'))
}

export const containsOrEscaped = function (str: string, element: string) {
  return contains(str, element) || containsEscaped(str, element)
}

export const unquote = function (str: string) {
  if (str && startsWith(str, '"') && endsWith(str, '"')) {
    return str.substring(1, str.length - 1)
  } else {
    return str
  }
}

export const trunc = function (str: string, length: number) {
  str = str.replace(/(\r\n|\n|\r)/gm, '')
  return (str.length > length) ? str.substr(0, length - 1) + '...' : str
}

export const version = (module?: string) => {
  if (module) {
    // @ts-expect-error FIXME Ignoring any type issue on purpose
    return packageJson.dependencies[module]
  } else {
    return packageJson.version
  }
}

let cachedCtfKey: string | undefined
const getCtfKey = () => {
  if (!cachedCtfKey) {
    if (process.env.CTF_KEY !== undefined && process.env.CTF_KEY !== '') {
      cachedCtfKey = process.env.CTF_KEY
    } else {
      const data = fs.readFileSync('ctf.key', 'utf8')
      cachedCtfKey = data
    }
  }
  return cachedCtfKey
}
export const ctfFlag = (text: string) => {
  const shaObj = new jsSHA('SHA-1', 'TEXT') // eslint-disable-line new-cap
  shaObj.setHMACKey(getCtfKey(), 'TEXT')
  shaObj.update(text)
  return shaObj.getHMAC('HEX')
}

export const toMMMYY = (date: Date) => {
  const month = date.getMonth()
  const year = date.getFullYear()
  return months[month] + year.toString().substring(2, 4)
}

export const toISO8601 = (date: Date) => {
  let day = '' + date.getDate()
  let month = '' + (date.getMonth() + 1)
  const year = date.getFullYear()

  if (month.length < 2) month = '0' + month
  if (day.length < 2) day = '0' + day

  return [year, month, day].join('-')
}

export const extractFilename = (url: string) => {
  let file = decodeURIComponent(url.substring(url.lastIndexOf('/') + 1))
  if (contains(file, '?')) {
    file = file.substring(0, file.indexOf('?'))
  }
  return file
}

export const downloadToFile = async (url: string, dest: string) => {
  try {
    const data = await download(url)
    fs.writeFileSync(dest, data)
  } catch (err) {
    logger.warn('Failed to download ' + url + ' (' + getErrorMessage(err) + ')')
  }
}

export const jwtFrom = ({ headers }: { headers: any }) => {
  if (headers?.authorization) {
    const parts = headers.authorization.split(' ')
    if (parts.length === 2) {
      const scheme = parts[0]
      const token = parts[1]

      if (/^Bearer$/i.test(scheme)) {
        return token
      }
    }
  }
  return undefined
}

export const randomHexString = (length: number): string => {
  return crypto.randomBytes(Math.ceil(length / 2)).toString('hex').slice(0, length)
}

export interface ChallengeEnablementStatus {
  enabled: boolean
  disabledBecause: string | null
}

type SafetyModeSetting = 'enabled' | 'disabled' | 'auto'

type isEnvironmentFunction = () => boolean

export function getChallengeEnablementStatus (challenge: Challenge,
  safetyModeSetting: SafetyModeSetting = config.get<SafetyModeSetting>('challenges.safetyMode'),
  isEnvironmentFunctions: {
    isDocker: isEnvironmentFunction
    isHeroku: isEnvironmentFunction
    isWindows: isEnvironmentFunction
    isGitpod: isEnvironmentFunction
  } = { isDocker, isHeroku, isWindows, isGitpod }): ChallengeEnablementStatus {
  if (!challenge?.disabledEnv) {
    return { enabled: true, disabledBecause: null }
  }

  if (safetyModeSetting === 'disabled') {
    return { enabled: true, disabledBecause: null }
  }

  if (challenge.disabledEnv?.includes('Docker') && isEnvironmentFunctions.isDocker()) {
    return { enabled: false, disabledBecause: 'Docker' }
  }
  if (challenge.disabledEnv?.includes('Heroku') && isEnvironmentFunctions.isHeroku()) {
    return { enabled: false, disabledBecause: 'Heroku' }
  }
  if (challenge.disabledEnv?.includes('Windows') && isEnvironmentFunctions.isWindows()) {
    return { enabled: false, disabledBecause: 'Windows' }
  }
  if (challenge.disabledEnv?.includes('Gitpod') && isEnvironmentFunctions.isGitpod()) {
    return { enabled: false, disabledBecause: 'Gitpod' }
  }
  if (challenge.disabledEnv && safetyModeSetting === 'enabled') {
    return { enabled: false, disabledBecause: 'Safety Mode' }
  }

  return { enabled: true, disabledBecause: null }
}
export function isChallengeEnabled (challenge: Challenge): boolean {
  const { enabled } = getChallengeEnablementStatus(challenge)
  return enabled
}

export const parseJsonCustom = (jsonString: string) => {
  const parser = clarinet.parser()
  const result: any[] = []
  parser.onkey = parser.onopenobject = (k: any) => {
    result.push({ key: k, value: null })
  }
  parser.onvalue = (v: any) => {
    result[result.length - 1].value = v
  }
  parser.write(jsonString)
  parser.close()
  return result
}

export const toSimpleIpAddress = (ipv6: string) => {
  if (startsWith(ipv6, '::ffff:')) {
    return ipv6.substr(7)
  } else if (ipv6 === '::1') {
    return '127.0.0.1'
  } else {
    return ipv6
  }
}

export const getErrorMessage = (error: unknown) => {
  if (error instanceof Error) return error.message
  return String(error)
}

export const matchesSystemIniFile = (text: string) => {
  const match = text.match(/; for 16-bit app support/gi)
  return match !== null && match.length >= 1
}

export const matchesEtcPasswdFile = (text: string) => {
  const match = text.match(/(\w*:\w*:\d*:\d*:\w*:.*)|(Note that this file is consulted directly)/gi)
  return match !== null && match.length >= 1
}


/* ===== FILE: ./lib/insecurity.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import fs from 'node:fs'
import crypto from 'node:crypto'
import { type Request, type Response, type NextFunction } from 'express'
import { type UserModel } from 'models/user'
import expressJwt from 'express-jwt'
import jwt from 'jsonwebtoken'
import jws from 'jws'
import sanitizeHtmlLib from 'sanitize-html'
import sanitizeFilenameLib from 'sanitize-filename'
import * as utils from './utils'

/* jslint node: true */
// eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error
// @ts-expect-error FIXME no typescript definitions for z85 :(
import * as z85 from 'z85'

export const publicKey = fs ? fs.readFileSync('encryptionkeys/jwt.pub', 'utf8') : 'placeholder-public-key'
const privateKey = '-----BEGIN RSA PRIVATE KEY-----\r\nMIICXAIBAAKBgQDNwqLEe9wgTXCbC7+RPdDbBbeqjdbs4kOPOIGzqLpXvJXlxxW8iMz0EaM4BKUqYsIa+ndv3NAn2RxCd5ubVdJJcX43zO6Ko0TFEZx/65gY3BE0O6syCEmUP4qbSd6exou/F+WTISzbQ5FBVPVmhnYhG/kpwt/cIxK5iUn5hm+4tQIDAQABAoGBAI+8xiPoOrA+KMnG/T4jJsG6TsHQcDHvJi7o1IKC/hnIXha0atTX5AUkRRce95qSfvKFweXdJXSQ0JMGJyfuXgU6dI0TcseFRfewXAa/ssxAC+iUVR6KUMh1PE2wXLitfeI6JLvVtrBYswm2I7CtY0q8n5AGimHWVXJPLfGV7m0BAkEA+fqFt2LXbLtyg6wZyxMA/cnmt5Nt3U2dAu77MzFJvibANUNHE4HPLZxjGNXN+a6m0K6TD4kDdh5HfUYLWWRBYQJBANK3carmulBwqzcDBjsJ0YrIONBpCAsXxk8idXb8jL9aNIg15Wumm2enqqObahDHB5jnGOLmbasizvSVqypfM9UCQCQl8xIqy+YgURXzXCN+kwUgHinrutZms87Jyi+D8Br8NY0+Nlf+zHvXAomD2W5CsEK7C+8SLBr3k/TsnRWHJuECQHFE9RA2OP8WoaLPuGCyFXaxzICThSRZYluVnWkZtxsBhW2W8z1b8PvWUE7kMy7TnkzeJS2LSnaNHoyxi7IaPQUCQCwWU4U+v4lD7uYBw00Ga/xt+7+UqFPlPVdz1yyr4q24Zxaw0LgmuEvgU5dycq8N7JxjTubX0MIRR+G9fmDBBl8=\r\n-----END RSA PRIVATE KEY-----'

interface ResponseWithUser {
  status?: string
  data: UserModel
  iat?: number
  exp?: number
  bid?: number
}

interface IAuthenticatedUsers {
  tokenMap: Record<string, ResponseWithUser>
  idMap: Record<string, string>
  put: (token: string, user: ResponseWithUser) => void
  get: (token?: string) => ResponseWithUser | undefined
  tokenOf: (user: UserModel) => string | undefined
  from: (req: Request) => ResponseWithUser | undefined
  updateFrom: (req: Request, user: ResponseWithUser) => any
}

export const hash = (data: string) => crypto.createHash('md5').update(data).digest('hex')
export const hmac = (data: string) => crypto.createHmac('sha256', 'pa4qacea4VK9t9nGv7yZtwmj').update(data).digest('hex')

export const cutOffPoisonNullByte = (str: string) => {
  const nullByte = '%00'
  if (utils.contains(str, nullByte)) {
    return str.substring(0, str.indexOf(nullByte))
  }
  return str
}

export const isAuthorized = () => expressJwt(({ secret: publicKey }) as any)
export const denyAll = () => expressJwt({ secret: '' + Math.random() } as any)
export const authorize = (user = {}) => jwt.sign(user, privateKey, { expiresIn: '6h', algorithm: 'RS256' })
export const verify = (token: string) => token ? (jws.verify as ((token: string, secret: string) => boolean))(token, publicKey) : false
export const decode = (token: string) => { return jws.decode(token)?.payload }

export const sanitizeHtml = (html: string) => sanitizeHtmlLib(html)
export const sanitizeLegacy = (input = '') => input.replace(/<(?:\w+)\W+?[\w]/gi, '')
export const sanitizeFilename = (filename: string) => sanitizeFilenameLib(filename)
export const sanitizeSecure = (html: string): string => {
  const sanitized = sanitizeHtml(html)
  if (sanitized === html) {
    return html
  } else {
    return sanitizeSecure(sanitized)
  }
}

export const authenticatedUsers: IAuthenticatedUsers = {
  tokenMap: {},
  idMap: {},
  put: function (token: string, user: ResponseWithUser) {
    this.tokenMap[token] = user
    this.idMap[user.data.id] = token
  },
  get: function (token?: string) {
    return token ? this.tokenMap[utils.unquote(token)] : undefined
  },
  tokenOf: function (user: UserModel) {
    return user ? this.idMap[user.id] : undefined
  },
  from: function (req: Request) {
    const token = utils.jwtFrom(req)
    return token ? this.get(token) : undefined
  },
  updateFrom: function (req: Request, user: ResponseWithUser) {
    const token = utils.jwtFrom(req)
    this.put(token, user)
  }
}

export const userEmailFrom = ({ headers }: any) => {
  return headers ? headers['x-user-email'] : undefined
}

export const generateCoupon = (discount: number, date = new Date()) => {
  const coupon = utils.toMMMYY(date) + '-' + discount
  return z85.encode(coupon)
}

export const discountFromCoupon = (coupon?: string) => {
  if (!coupon) {
    return undefined
  }
  const decoded = z85.decode(coupon)
  if (decoded && (hasValidFormat(decoded.toString()) != null)) {
    const parts = decoded.toString().split('-')
    const validity = parts[0]
    if (utils.toMMMYY(new Date()) === validity) {
      const discount = parts[1]
      return parseInt(discount)
    }
  }
}

function hasValidFormat (coupon: string) {
  return coupon.match(/(JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)[0-9]{2}-[0-9]{2}/)
}

// vuln-code-snippet start redirectCryptoCurrencyChallenge redirectChallenge
export const redirectAllowlist = new Set([
  'https://github.com/juice-shop/juice-shop',
  'https://blockchain.info/address/1AbKfgvw9psQ41NbLi8kufDQTezwG8DRZm', // vuln-code-snippet vuln-line redirectCryptoCurrencyChallenge
  'https://explorer.dash.org/address/Xr556RzuwX6hg5EGpkybbv5RanJoZN17kW', // vuln-code-snippet vuln-line redirectCryptoCurrencyChallenge
  'https://etherscan.io/address/0x0f933ab9fcaaa782d0279c300d73750e1311eae6', // vuln-code-snippet vuln-line redirectCryptoCurrencyChallenge
  'http://shop.spreadshirt.com/juiceshop',
  'http://shop.spreadshirt.de/juiceshop',
  'https://www.stickeryou.com/products/owasp-juice-shop/794',
  'http://leanpub.com/juice-shop'
])

export const isRedirectAllowed = (url: string) => {
  let allowed = false
  for (const allowedUrl of redirectAllowlist) {
    allowed = allowed || url.includes(allowedUrl) // vuln-code-snippet vuln-line redirectChallenge
  }
  return allowed
}
// vuln-code-snippet end redirectCryptoCurrencyChallenge redirectChallenge

export const roles = {
  customer: 'customer',
  deluxe: 'deluxe',
  accounting: 'accounting',
  admin: 'admin'
}

export const deluxeToken = (email: string) => {
  const hmac = crypto.createHmac('sha256', privateKey)
  return hmac.update(email + roles.deluxe).digest('hex')
}

export const isAccounting = () => {
  return (req: Request, res: Response, next: NextFunction) => {
    const decodedToken = verify(utils.jwtFrom(req)) && decode(utils.jwtFrom(req))
    if (decodedToken?.data?.role === roles.accounting) {
      next()
    } else {
      res.status(403).json({ error: 'Malicious activity detected' })
    }
  }
}

export const isDeluxe = (req: Request) => {
  const decodedToken = verify(utils.jwtFrom(req)) && decode(utils.jwtFrom(req))
  return decodedToken?.data?.role === roles.deluxe && decodedToken?.data?.deluxeToken && decodedToken?.data?.deluxeToken === deluxeToken(decodedToken?.data?.email)
}

export const isCustomer = (req: Request) => {
  const decodedToken = verify(utils.jwtFrom(req)) && decode(utils.jwtFrom(req))
  return decodedToken?.data?.role === roles.customer
}

export const appendUserId = () => {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      req.body.UserId = authenticatedUsers.tokenMap[utils.jwtFrom(req)].data.id
      next()
    } catch (error: any) {
      res.status(401).json({ status: 'error', message: error })
    }
  }
}

export const updateAuthenticatedUsers = () => (req: Request, res: Response, next: NextFunction) => {
  const token = req.cookies.token || utils.jwtFrom(req)
  if (token) {
    jwt.verify(token, publicKey, (err: Error | null, decoded: any) => {
      if (err === null) {
        if (authenticatedUsers.get(token) === undefined) {
          authenticatedUsers.put(token, decoded)
          res.cookie('token', token)
        }
      }
    })
  }
  next()
}


/* ===== FILE: ./lib/is-docker.ts ===== */

// from https://github.com/sindresorhus/is-docker/tree/main MIT Licensed
// inlined to avoid import problems in cypress

import fs from 'node:fs'

let isDockerCached: boolean | undefined

function hasDockerEnv () {
  try {
    fs.statSync('/.dockerenv')
    return true
  } catch {
    return false
  }
}

function hasDockerCGroup () {
  try {
    return fs.readFileSync('/proc/self/cgroup', 'utf8').includes('docker')
  } catch {
    return false
  }
}

export default function isDocker () {
  // TODO: Use `??=` when targeting Node.js 16.
  if (isDockerCached === undefined) {
    isDockerCached = hasDockerEnv() || hasDockerCGroup()
  }
  return isDockerCached
}


/* ===== FILE: ./lib/logger.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import * as winston from 'winston'

export default winston.createLogger({
  transports: [
    new winston.transports.Console({ level: process.env.NODE_ENV === 'test' ? 'error' : 'info' })
  ],
  format: winston.format.simple()
})


/* ===== FILE: ./lib/challengeUtils.ts ===== */

import { Op } from 'sequelize'
import { type ChallengeKey, ChallengeModel } from '../models/challenge'
import logger from './logger'
import config from 'config'
import sanitizeHtml from 'sanitize-html'
import colors from 'colors/safe'
import * as utils from './utils'
import { calculateCheatScore, calculateFindItCheatScore, calculateFixItCheatScore } from './antiCheat'
import * as webhook from './webhook'
import * as accuracy from './accuracy'
import { type Server } from 'socket.io'
import { AllHtmlEntities as Entities } from 'html-entities'
import { challenges, notifications } from '../data/datacache'

const entities = new Entities()

const globalWithSocketIO = global as typeof globalThis & {
  io: SocketIOClientStatic & Server
}

export const solveIf = function (challenge: any, criteria: () => any, isRestore: boolean = false) {
  if (notSolved(challenge) && criteria()) {
    solve(challenge, isRestore)
  }
}

export const solve = function (challenge: any, isRestore = false) {
  challenge.solved = true
  challenge.save().then((solvedChallenge: { difficulty: number, key: string, name: string }) => {
    logger.info(`${isRestore ? colors.grey('Restored') : colors.green('Solved')} ${solvedChallenge.difficulty}-star ${colors.cyan(solvedChallenge.key)} (${solvedChallenge.name})`)
    sendNotification(solvedChallenge, isRestore)
    if (!isRestore) {
      const cheatScore = calculateCheatScore(challenge)
      if (process.env.SOLUTIONS_WEBHOOK) {
        webhook.notify(solvedChallenge, cheatScore).catch((error: unknown) => {
          logger.error('Webhook notification failed: ' + colors.red(utils.getErrorMessage(error)))
        })
      }
    }
  })
}

export const sendNotification = function (challenge: { difficulty?: number, key: any, name: any, description?: any }, isRestore: boolean) {
  if (!notSolved(challenge)) {
    const flag = utils.ctfFlag(challenge.name)
    const notification = {
      key: challenge.key,
      name: challenge.name,
      challenge: challenge.name + ' (' + entities.decode(sanitizeHtml(challenge.description, { allowedTags: [], allowedAttributes: {} })) + ')',
      flag,
      hidden: !config.get('challenges.showSolvedNotifications'),
      isRestore
    }
    const wasPreviouslyShown = notifications.some(({ key }) => key === challenge.key)
    notifications.push(notification)

    if (globalWithSocketIO.io && (isRestore || !wasPreviouslyShown)) {
      globalWithSocketIO.io.emit('challenge solved', notification)
    }
  }
}

export const sendCodingChallengeNotification = function (challenge: { key: string, codingChallengeStatus: 0 | 1 | 2 }) {
  if (challenge.codingChallengeStatus > 0) {
    const notification = {
      key: challenge.key,
      codingChallengeStatus: challenge.codingChallengeStatus
    }
    if (globalWithSocketIO.io) {
      globalWithSocketIO.io.emit('code challenge solved', notification)
    }
  }
}

export const notSolved = (challenge: any) => challenge && !challenge.solved

export const findChallengeByName = (challengeName: string) => {
  for (const challenge of Object.values(challenges)) {
    if (challenge.name === challengeName) {
      return challenge
    }
  }
  logger.warn('Missing challenge with name: ' + challengeName)
}

export const findChallengeById = (challengeId: number) => {
  for (const challenge of Object.values(challenges)) {
    if (challenge.id === challengeId) {
      return challenge
    }
  }
  logger.warn('Missing challenge with id: ' + challengeId)
}

export const solveFindIt = async function (key: ChallengeKey, isRestore: boolean = false) {
  const solvedChallenge = challenges[key]
  await ChallengeModel.update({ codingChallengeStatus: 1 }, { where: { key, codingChallengeStatus: { [Op.lt]: 2 } } })
  logger.info(`${isRestore ? colors.grey('Restored') : colors.green('Solved')} 'Find It' phase of coding challenge ${colors.cyan(solvedChallenge.key)} (${solvedChallenge.name})`)
  if (!isRestore) {
    accuracy.storeFindItVerdict(solvedChallenge.key, true)
    accuracy.calculateFindItAccuracy(solvedChallenge.key)
    await calculateFindItCheatScore(solvedChallenge)
    sendCodingChallengeNotification({ key, codingChallengeStatus: 1 })
  }
}

export const solveFixIt = async function (key: ChallengeKey, isRestore: boolean = false) {
  const solvedChallenge = challenges[key]
  await ChallengeModel.update({ codingChallengeStatus: 2 }, { where: { key } })
  logger.info(`${isRestore ? colors.grey('Restored') : colors.green('Solved')} 'Fix It' phase of coding challenge ${colors.cyan(solvedChallenge.key)} (${solvedChallenge.name})`)
  if (!isRestore) {
    accuracy.storeFixItVerdict(solvedChallenge.key, true)
    accuracy.calculateFixItAccuracy(solvedChallenge.key)
    await calculateFixItCheatScore(solvedChallenge)
    sendCodingChallengeNotification({ key, codingChallengeStatus: 2 })
  }
}


/* ===== FILE: ./lib/codingChallenges.ts ===== */

import fs from 'node:fs/promises'
import path from 'node:path'
import logger from './logger'

export const SNIPPET_PATHS = Object.freeze(['./server.ts', './routes', './lib', './data', './data/static/web3-snippets', './frontend/src/app', './models'])

interface FileMatch {
  path: string
  content: string
}

interface CachedCodeChallenge {
  snippet: string
  vulnLines: number[]
  neutralLines: number[]
}

export const findFilesWithCodeChallenges = async (paths: readonly string[]): Promise<FileMatch[]> => {
  const matches = []
  for (const currPath of paths) {
    if ((await fs.lstat(currPath)).isDirectory()) {
      const files = await fs.readdir(currPath)
      const moreMatches = await findFilesWithCodeChallenges(
        files.map(file => path.resolve(currPath, file))
      )
      matches.push(...moreMatches)
    } else {
      try {
        const code = await fs.readFile(currPath, 'utf8')
        if (
          // strings are split so that it doesn't find itself...
          code.includes('// vuln-code' + '-snippet start') ||
          code.includes('# vuln-code' + '-snippet start')
        ) {
          matches.push({ path: currPath, content: code })
        }
      } catch (e) {
        logger.warn(`File ${currPath} could not be read. it might have been moved or deleted. If coding challenges are contained in the file, they will not be available.`)
      }
    }
  }

  return matches
}

function getCodeChallengesFromFile (file: FileMatch) {
  const fileContent = file.content

  // get all challenges which are in the file by a regex capture group
  const challengeKeyRegex = /[/#]{0,2} vuln-code-snippet start (?<challenges>.*)/g
  const challenges = [...fileContent.matchAll(challengeKeyRegex)]
    .flatMap(match => match.groups?.challenges?.split(' ') ?? [])
    .filter(Boolean)

  return challenges.map((challengeKey) => getCodingChallengeFromFileContent(fileContent, challengeKey))
}

function getCodingChallengeFromFileContent (source: string, challengeKey: string) {
  const snippets = source.match(`[/#]{0,2} vuln-code-snippet start.*${challengeKey}([^])*vuln-code-snippet end.*${challengeKey}`)
  if (snippets == null) {
    throw new BrokenBoundary('Broken code snippet boundaries for: ' + challengeKey)
  }
  let snippet = snippets[0] // TODO Currently only a single code snippet is supported
  snippet = snippet.replace(/\s?[/#]{0,2} vuln-code-snippet start.*[\r\n]{0,2}/g, '')
  snippet = snippet.replace(/\s?[/#]{0,2} vuln-code-snippet end.*/g, '')
  snippet = snippet.replace(/.*[/#]{0,2} vuln-code-snippet hide-line[\r\n]{0,2}/g, '')
  snippet = snippet.replace(/.*[/#]{0,2} vuln-code-snippet hide-start([^])*[/#]{0,2} vuln-code-snippet hide-end[\r\n]{0,2}/g, '')
  snippet = snippet.trim()

  let lines = snippet.split('\r\n')
  if (lines.length === 1) lines = snippet.split('\n')
  if (lines.length === 1) lines = snippet.split('\r')
  const vulnLines = []
  const neutralLines = []
  for (let i = 0; i < lines.length; i++) {
    if (new RegExp(`vuln-code-snippet vuln-line.*${challengeKey}`).exec(lines[i]) != null) {
      vulnLines.push(i + 1)
    } else if (new RegExp(`vuln-code-snippet neutral-line.*${challengeKey}`).exec(lines[i]) != null) {
      neutralLines.push(i + 1)
    }
  }
  snippet = snippet.replace(/\s?[/#]{0,2} vuln-code-snippet vuln-line.*/g, '')
  snippet = snippet.replace(/\s?[/#]{0,2} vuln-code-snippet neutral-line.*/g, '')
  return { challengeKey, snippet, vulnLines, neutralLines }
}

class BrokenBoundary extends Error {
  constructor (message: string) {
    super(message)
    this.name = 'BrokenBoundary'
    this.message = message
  }
}

// dont use directly, use getCodeChallenges getter
let _internalCodeChallenges: Map<string, CachedCodeChallenge> | null = null
export async function getCodeChallenges (): Promise<Map<string, CachedCodeChallenge>> {
  if (_internalCodeChallenges === null) {
    _internalCodeChallenges = new Map<string, CachedCodeChallenge>()
    const filesWithCodeChallenges = await findFilesWithCodeChallenges(SNIPPET_PATHS)
    for (const fileMatch of filesWithCodeChallenges) {
      for (const codeChallenge of getCodeChallengesFromFile(fileMatch)) {
        _internalCodeChallenges.set(codeChallenge.challengeKey, {
          snippet: codeChallenge.snippet,
          vulnLines: codeChallenge.vulnLines,
          neutralLines: codeChallenge.neutralLines
        })
      }
    }
  }
  return _internalCodeChallenges
}


/* ===== FILE: ./lib/webhook.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import os from 'node:os'
import config from 'config'
import colors from 'colors/safe'

import logger from './logger'
import * as utils from './utils'
import { totalCheatScore } from './antiCheat'

export const notify = async (challenge: { key: any, name: any }, cheatScore = -1, webhook = process.env.SOLUTIONS_WEBHOOK) => {
  if (!webhook) {
    return
  }
  const res = await fetch(webhook, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      solution: {
        challenge: challenge.key,
        cheatScore,
        totalCheatScore: totalCheatScore(),
        issuedOn: new Date().toISOString()
      },
      ctfFlag: utils.ctfFlag(challenge.name),
      issuer: {
        hostName: os.hostname(),
        os: `${os.type()} (${os.release()})`,
        appName: config.get<string>('application.name'),
        config: process.env.NODE_ENV ?? 'default',
        version: utils.version()
      }
    })
  })
  logger.info(`Webhook ${colors.bold(webhook)} notified about ${colors.cyan(challenge.key)} being solved: ${res.ok ? colors.green(res.status.toString()) : colors.red(res.status.toString())}`)
}


/* ===== FILE: ./lib/noUpdate.ts ===== */

// Credit for the implementation in JS: https://github.com/daviddossantos/sequelize-notupdate-attributes
import { type Model, type ValidationErrorItemType } from 'sequelize/types'
import { type ValidationOptions } from 'sequelize/types/instance-validator'
// @ts-expect-error FIXME due to non-existing type definitions for sequelize/lib/errors
import { ValidationError, ValidationErrorItem } from 'sequelize/lib/errors'

interface ExtendedValidationOptions extends ValidationOptions {
  validate: boolean
}

interface ExtendedModel extends Model {
  _changed: Iterable<string> | ArrayLike<string>
  rawAttributes: Record<string, any>
  _previousDataValues: Record<string, null>
}

export const makeKeyNonUpdatable = (model: Model, column: string) => {
  model.addHook('beforeValidate', (instance: ExtendedModel, options: ExtendedValidationOptions) => {
    if (!options.validate) return

    if (instance.isNewRecord) return

    const changedKeys: unknown[] = []

    const instanceChanged = Array.from(instance._changed)

    instanceChanged.forEach((value) => changedKeys.push(value))

    if (changedKeys.length === 0) return

    const validationErrors: ValidationErrorItemType[] = []

    changedKeys.forEach((fieldName: any) => {
      const fieldDefinition = instance.rawAttributes[fieldName]

      if (
        instance._previousDataValues[fieldName] !== undefined &&
        instance._previousDataValues[fieldName] !== null &&
        (fieldDefinition.fieldName === column)
      ) {
        validationErrors.push(
          new ValidationErrorItem(
            `\`${fieldName}\` cannot be updated due \`noUpdate\` constraint`,
            'noUpdate Violation',
            fieldName
          )
        )
      }
    })

    if (validationErrors.length > 0) { throw new ValidationError(null, validationErrors) }
  })
}


/* ===== FILE: ./lib/startup/customizeApplication.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import fs from 'node:fs'
import config from 'config'
import * as utils from '../utils'
// @ts-expect-error FIXME due to non-existing type definitions for replace
import replace from 'replace'

const customizeApplication = async () => {
  if (config.get<string>('application.name')) {
    customizeTitle()
  }
  if (config.get('application.logo')) {
    void customizeLogo()
  }
  if (config.get('application.favicon')) {
    void customizeFavicon()
  }
  if (config.get('application.theme')) {
    customizeTheme()
  }
  if (config.get('application.cookieConsent')) {
    customizeCookieConsentBanner()
  }
  if (config.get('application.promotion')) {
    void customizePromotionVideo()
    void customizePromotionSubtitles()
  }
  if (config.get('hackingInstructor')) {
    void customizeHackingInstructorAvatar()
  }
  if (config.get('application.chatBot')) {
    void customizeChatbotAvatar()
  }
}

const customizeLogo = async () => {
  await retrieveCustomFile('application.logo', 'frontend/dist/frontend/assets/public/images')
}

const customizeChatbotAvatar = async () => {
  const avatarImage = await retrieveCustomFile('application.chatBot.avatar', 'frontend/dist/frontend/assets/public/images')
  fs.copyFileSync('frontend/dist/frontend/assets/public/images/' + avatarImage, 'frontend/dist/frontend/assets/public/images/ChatbotAvatar.png')
}

const customizeHackingInstructorAvatar = async () => {
  const avatarImage = await retrieveCustomFile('hackingInstructor.avatarImage', 'frontend/dist/frontend/assets/public/images')
  fs.copyFileSync('frontend/dist/frontend/assets/public/images/' + avatarImage, 'frontend/dist/frontend/assets/public/images/hackingInstructor.png')
}

const customizeFavicon = async () => {
  const favicon = await retrieveCustomFile('application.favicon', 'frontend/dist/frontend/assets/public')
  replace({
    regex: /type="image\/x-icon" href="assets\/public\/.*"/,
    replacement: `type="image/x-icon" href="assets/public/${favicon}"`,
    paths: ['frontend/dist/frontend/index.html'],
    recursive: false,
    silent: true
  })
}

const customizePromotionVideo = async () => {
  await retrieveCustomFile('application.promotion.video', 'frontend/dist/frontend/assets/public/videos')
}

const customizePromotionSubtitles = async () => {
  await retrieveCustomFile('application.promotion.subtitles', 'frontend/dist/frontend/assets/public/videos')
}

const retrieveCustomFile = async (sourceProperty: string, destinationFolder: string) => {
  let file = config.get<string>(sourceProperty)
  if (utils.isUrl(file)) {
    const filePath = file
    file = utils.extractFilename(file)
    await utils.downloadToFile(filePath, destinationFolder + '/' + file)
  }
  return file
}

const customizeTitle = () => {
  const title = `<title>${config.get<string>('application.name')}</title>`
  replace({
    regex: /<title>.*<\/title>/,
    replacement: title,
    paths: ['frontend/dist/frontend/index.html'],
    recursive: false,
    silent: true
  })
}

const customizeTheme = () => {
  const bodyClass = '"mat-app-background mat-typography ' + config.get<string>('application.theme') + '-theme"'
  replace({
    regex: /"mat-app-background mat-typography .*-theme"/,
    replacement: bodyClass,
    paths: ['frontend/dist/frontend/index.html'],
    recursive: false,
    silent: true
  })
}

const customizeCookieConsentBanner = () => {
  const contentProperty = '"content": { "message": "' + config.get<string>('application.cookieConsent.message') + '", "dismiss": "' + config.get<string>('application.cookieConsent.dismissText') + '", "link": "' + config.get<string>('application.cookieConsent.linkText') + '", "href": "' + config.get<string>('application.cookieConsent.linkUrl') + '" }'
  replace({
    regex: /"content": { "message": ".*", "dismiss": ".*", "link": ".*", "href": ".*" }/,
    replacement: contentProperty,
    paths: ['frontend/dist/frontend/index.html'],
    recursive: false,
    silent: true
  })
}

export default customizeApplication


/* ===== FILE: ./lib/startup/validatePreconditions.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import pjson from '../../package.json'
import config from 'config'
import logger from '../logger'
import path from 'node:path'
import colors from 'colors/safe'
import { access } from 'node:fs/promises'
import process from 'node:process'
import semver from 'semver'
import portscanner from 'portscanner'
// @ts-expect-error FIXME due to non-existing type definitions for check-internet-connected
import checkInternetConnected from 'check-internet-connected'

const domainDependencies = {
  'https://www.alchemy.com/': ['"Mint the Honeypot" challenge', '"Wallet Depletion" challenge']
}

const validatePreconditions = async ({ exitOnFailure = true } = {}) => {
  let success = true
  success = checkIfRunningOnSupportedNodeVersion(process.version) && success
  success = checkIfRunningOnSupportedOS(process.platform) && success
  success = checkIfRunningOnSupportedCPU(process.arch) && success

  const asyncConditions = (await Promise.all([
    checkIfRequiredFileExists('build/server.js'),
    checkIfRequiredFileExists('frontend/dist/frontend/index.html'),
    checkIfRequiredFileExists('frontend/dist/frontend/styles.css'),
    checkIfRequiredFileExists('frontend/dist/frontend/main.js'),
    checkIfRequiredFileExists('frontend/dist/frontend/tutorial.js'),
    checkIfRequiredFileExists('frontend/dist/frontend/runtime.js'),
    checkIfRequiredFileExists('frontend/dist/frontend/vendor.js'),
    checkIfPortIsAvailable(process.env.PORT ?? config.get<number>('server.port')),
    checkIfDomainReachable('https://www.alchemy.com/')
  ])).every(condition => condition)

  if ((!success || !asyncConditions) && exitOnFailure) {
    logger.error(colors.red('Exiting due to unsatisfied precondition!'))
    process.exit(1)
  }
  return success
}

export const checkIfRunningOnSupportedNodeVersion = (runningVersion: string) => {
  const supportedVersion = pjson.engines.node
  const effectiveVersionRange = semver.validRange(supportedVersion)
  if (!effectiveVersionRange) {
    logger.warn(`Invalid Node.js version range ${colors.bold(supportedVersion)} in package.json (${colors.red('NOT OK')})`)
    return false
  }
  if (!semver.satisfies(runningVersion, effectiveVersionRange)) {
    logger.warn(`Detected Node version ${colors.bold(runningVersion)} is not in the supported version range of ${supportedVersion} (${colors.red('NOT OK')})`)
    return false
  }
  logger.info(`Detected Node.js version ${colors.bold(runningVersion)} (${colors.green('OK')})`)
  return true
}

export const checkIfRunningOnSupportedOS = (runningOS: string) => {
  const supportedOS = pjson.os
  if (!supportedOS.includes(runningOS)) {
    logger.warn(`Detected OS ${colors.bold(runningOS)} is not in the list of supported platforms ${supportedOS.toString()} (${colors.red('NOT OK')})`)
    return false
  }
  logger.info(`Detected OS ${colors.bold(runningOS)} (${colors.green('OK')})`)
  return true
}

export const checkIfRunningOnSupportedCPU = (runningArch: string) => {
  const supportedArch = pjson.cpu
  if (!supportedArch.includes(runningArch)) {
    logger.warn(`Detected CPU ${colors.bold(runningArch)} is not in the list of supported architectures ${supportedArch.toString()} (${colors.red('NOT OK')})`)
    return false
  }
  logger.info(`Detected CPU ${colors.bold(runningArch)} (${colors.green('OK')})`)
  return true
}

export const checkIfDomainReachable = async (domain: string) => {
  return checkInternetConnected({ domain })
    .then(() => {
      logger.info(`Domain ${colors.bold(domain)} is reachable (${colors.green('OK')})`)
      return true
    })
    .catch(() => {
      logger.warn(`Domain ${colors.bold(domain)} is not reachable (${colors.yellow('NOT OK')} in a future major release)`)
      // @ts-expect-error FIXME Type problem by accessing key via variable
      domainDependencies[domain].forEach((dependency: string) => {
        logger.warn(`${colors.italic(dependency)} will not work as intended without access to ${colors.bold(domain)}`)
      })
      return true // TODO Consider switching to "false" with breaking release v16.0.0 or later
    })
}

export const checkIfPortIsAvailable = async (port: number | string) => {
  const portNumber = parseInt(port.toString())
  return await new Promise((resolve, reject) => {
    portscanner.checkPortStatus(portNumber, function (error: unknown, status: string) {
      if (error) {
        reject(error)
      } else {
        if (status === 'open') {
          logger.warn(`Port ${colors.bold(port.toString())} is in use (${colors.red('NOT OK')})`)
          resolve(false)
        } else {
          logger.info(`Port ${colors.bold(port.toString())} is available (${colors.green('OK')})`)
          resolve(true)
        }
      }
    })
  })
}

export const checkIfRequiredFileExists = async (pathRelativeToProjectRoot: string) => {
  const fileName = pathRelativeToProjectRoot.substr(pathRelativeToProjectRoot.lastIndexOf('/') + 1)

  return await access(path.resolve(pathRelativeToProjectRoot)).then(() => {
    logger.info(`Required file ${colors.bold(fileName)} is present (${colors.green('OK')})`)
    return true
  }).catch(() => {
    logger.warn(`Required file ${colors.bold(fileName)} is missing (${colors.red('NOT OK')})`)
    return false
  })
}

export default validatePreconditions


/* ===== FILE: ./lib/startup/validateChatBot.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import config from 'config'
import logger from '../logger'
import colors from 'colors/safe'
import * as utils from '../utils'

export default function validateChatBot (trainingData: any, exitOnFailure = true) {
  let success = true
  success = checkIntentWithFunctionHandlerExists(trainingData, 'queries.couponCode', 'couponCode') && success
  success = checkIntentWithFunctionHandlerExists(trainingData, 'queries.productPrice', 'productPrice') && success
  success = checkIntentWithFunctionHandlerExists(trainingData, 'queries.functionTest', 'testFunction') && success
  if (success) {
    logger.info(`Chatbot training data ${colors.bold(utils.extractFilename(config.get('application.chatBot.trainingData')))} validated (${colors.green('OK')})`)
  } else {
    logger.warn(`Chatbot training data ${colors.bold(utils.extractFilename(config.get('application.chatBot.trainingData')))} validated (${colors.red('NOT OK')})`)
    logger.warn(`Visit ${colors.yellow('https://pwning.owasp-juice.shop/companion-guide/latest/part5/chatbot.html')} for the training data schema definition.`)
    if (exitOnFailure) {
      logger.error(colors.red('Exiting due to configuration errors!'))
      process.exit(1)
    }
  }
  return success
}

export const checkIntentWithFunctionHandlerExists = (trainingData: any, intent: string, handler: string) => {
  let success = true
  const intentData = trainingData.data.filter((data: any) => data.intent === intent)
  if (intentData.length === 0) {
    logger.warn(`Intent ${colors.italic(intent)} is missing in chatbot training data (${colors.red('NOT OK')})`)
    success = false
  } else {
    if (intentData[0].answers.filter((answer: { action: string, handler: string }) => answer.action === 'function' && answer.handler === handler).length === 0) {
      logger.warn(`Answer with ${colors.italic('function')} action and handler ${colors.italic(handler)} is missing for intent ${colors.italic(intent)} (${colors.red('NOT OK')})`)
      success = false
    }
  }
  return success
}


/* ===== FILE: ./lib/startup/validateDependencies.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import colors from 'colors/safe'
import * as utils from '../utils'
import logger from '../logger'
// @ts-expect-error FIXME due to non-existing type definitions for check-dependencies
import dependencyChecker from 'check-dependencies'

const validateDependencies = async ({ packageDir = '.', exitOnFailure = true } = {}) => {
  let success = true
  let dependencies: any = {}
  try {
    dependencies = await dependencyChecker({ packageDir, scopeList: ['dependencies'] })
  } catch (err) {
    logger.warn(`Dependencies in ${colors.bold(packageDir + '/package.json')} could not be checked due to "${utils.getErrorMessage(err)}" error (${colors.red('NOT OK')})`)
  }

  if (dependencies.depsWereOk === true) {
    logger.info(`All dependencies in ${colors.bold(packageDir + '/package.json')} are satisfied (${colors.green('OK')})`)
  } else {
    logger.warn(`Dependencies in ${colors.bold(packageDir + '/package.json')} are not rightly satisfied (${colors.red('NOT OK')})`)
    success = false
    for (const err of dependencies.error) {
      logger.warn(err)
    }
  }

  if (!success && exitOnFailure) {
    logger.error(colors.red('Exiting due to unsatisfied dependencies!'))
    process.exit(1)
  }
}

export default validateDependencies


/* ===== FILE: ./lib/startup/restoreOverwrittenFilesWithOriginals.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import path from 'node:path'
import * as utils from '../utils'
import logger from '../logger'
import { copyFile, access } from 'node:fs/promises'
import { glob } from 'glob'

const exists = async (path: string) => await access(path).then(() => true).catch(() => false)

const restoreOverwrittenFilesWithOriginals = async () => {
  await copyFile(path.resolve('data/static/legal.md'), path.resolve('ftp/legal.md'))

  if (await exists(path.resolve('frontend/dist'))) {
    await copyFile(
      path.resolve('data/static/owasp_promo.vtt'),
      path.resolve('frontend/dist/frontend/assets/public/videos/owasp_promo.vtt')
    )
  }

  try {
    const files = await glob(path.resolve('data/static/i18n/*.json'))
    await Promise.all(
      files.map(async (filename: string) => {
        await copyFile(filename, path.resolve('i18n/', filename.substring(filename.lastIndexOf('/') + 1)))
      })
    )
  } catch (err) {
    logger.warn('Error listing JSON files in /data/static/i18n folder: ' + utils.getErrorMessage(err))
  }
}

export default restoreOverwrittenFilesWithOriginals


/* ===== FILE: ./lib/startup/customizeEasterEgg.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import config from 'config'
import * as utils from '../utils'
// @ts-expect-error FIXME due to non-existing type definitions for replace
import replace from 'replace'

const customizeEasterEgg = async () => {
  if (config.has('application.easterEggPlanet.overlayMap')) {
    let overlay: string = config.get('application.easterEggPlanet.overlayMap')
    if (utils.isUrl(overlay)) {
      const overlayPath = overlay
      overlay = utils.extractFilename(overlay)
      await utils.downloadToFile(overlayPath, 'frontend/dist/frontend/assets/private/' + overlay)
    }
    replaceImagePath(overlay)
  }
  if (config.has('application.easterEggPlanet.name')) {
    replaceThreeJsTitleTag()
  }
}

const replaceImagePath = (overlay: string) => {
  const textureDeclaration = 'orangeTexture = THREE.ImageUtils.loadTexture("/assets/private/' + overlay + '");'
  replace({
    regex: /orangeTexture = .*;/,
    replacement: textureDeclaration,
    paths: ['frontend/dist/frontend/assets/private/threejs-demo.html'],
    recursive: false,
    silent: true
  })
}

const replaceThreeJsTitleTag = () => {
  const threeJsTitleTag = '<title>Welcome to Planet ' + config.get<string>('application.easterEggPlanet.name') + '</title>'
  replace({
    regex: /<title>.*<\/title>/,
    replacement: threeJsTitleTag,
    paths: ['frontend/dist/frontend/assets/private/threejs-demo.html'],
    recursive: false,
    silent: true
  })
}

export default customizeEasterEgg


/* ===== FILE: ./lib/startup/validateDependenciesBasic.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

// note: this file can't have any other imports than the dynamic one below as it needs to be able to at least start up without the npm dependencies installed
// otherwise this check would be useless as the app would fail on a random import before even reaching this point
const validateIfDependencyCheckerIsInstalled = async () => {
  try {
    // @ts-expect-error FIXME due to non-existing type definitions for check-dependencies
    await import('check-dependencies')
  } catch (err) {
    console.error('Please run "npm install" before starting the application!')
    process.exit(1)
  }
}

export default validateIfDependencyCheckerIsInstalled


/* ===== FILE: ./lib/startup/validateConfig.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import path from 'node:path'
import config from 'config'
import process from 'node:process'
import colors from 'colors/safe'
// @ts-expect-error FIXME due to non-existing type definitions for yaml-schema-validator
import validateSchema from 'yaml-schema-validator/src'

import type { AppConfig, Memory as MemoryConfig, Product as ProductConfig } from '../config.types'
import logger from '../logger'

const specialProducts = [
  { name: '"Christmas Special" challenge product', key: 'useForChristmasSpecialChallenge' },
  { name: '"Product Tampering" challenge product', key: 'urlForProductTamperingChallenge' },
  { name: '"Retrieve Blueprint" challenge product', key: 'fileForRetrieveBlueprintChallenge', extra: { key: 'exifForBlueprintChallenge', name: 'list of EXIF metadata properties' } },
  { name: '"Leaked Unsafe Product" challenge product', key: 'keywordsForPastebinDataLeakChallenge' }
]

const specialMemories = [
  { name: '"Meta Geo Stalking" challenge memory', user: 'john', keys: ['geoStalkingMetaSecurityQuestion', 'geoStalkingMetaSecurityAnswer'] },
  { name: '"Visual Geo Stalking" challenge memory', user: 'emma', keys: ['geoStalkingVisualSecurityQuestion', 'geoStalkingVisualSecurityAnswer'] }
] as const

const validateConfig = async ({ products, memories, exitOnFailure = true }: { products?: ProductConfig[], memories?: MemoryConfig[], exitOnFailure: boolean }) => {
  products = products ?? config.get('products') ?? []
  memories = memories ?? config.get('memories') ?? []

  let success = true
  success = checkYamlSchema() && success
  success = checkMinimumRequiredNumberOfProducts(products) && success
  success = checkUnambiguousMandatorySpecialProducts(products) && success
  success = checkUniqueSpecialOnProducts(products) && success
  success = checkNecessaryExtraKeysOnSpecialProducts(products) && success
  success = checkMinimumRequiredNumberOfMemories(memories) && success
  success = checkUnambiguousMandatorySpecialMemories(memories) && success
  success = checkUniqueSpecialOnMemories(memories) && success
  success = checkSpecialMemoriesHaveNoUserAssociated(memories) && success
  success = checkForIllogicalCombos() && success
  if (success) {
    logger.info(`Configuration ${colors.bold(process.env.NODE_ENV ?? 'default')} validated (${colors.green('OK')})`)
  } else {
    logger.warn(`Configuration ${colors.bold(process.env.NODE_ENV ?? 'default')} validated (${colors.red('NOT OK')})`)
    logger.warn(`Visit ${colors.yellow('https://pwning.owasp-juice.shop/companion-guide/latest/part4/customization.html#_yaml_configuration_file')} for the configuration schema definition.`)
    if (exitOnFailure) {
      logger.error(colors.red('Exiting due to configuration errors!'))
      process.exit(1)
    }
  }
  return success
}

export const checkYamlSchema = (configuration = config.util.toObject()): configuration is AppConfig => {
  let success = true
  const schemaErrors = validateSchema(configuration, { schemaPath: path.resolve('config.schema.yml'), logLevel: 'none' })
  if (schemaErrors.length !== 0) {
    logger.warn(`Config schema validation failed with ${schemaErrors.length} errors (${colors.red('NOT OK')})`)
    schemaErrors.forEach(({ path, message }: { path: string, message: string }) => {
      logger.warn(`${path}:${colors.red(message.substr(message.indexOf(path) + path.length))}`)
    })
    success = false
  }
  return success
}

export const checkMinimumRequiredNumberOfProducts = (products: ProductConfig[]) => {
  let success = true
  if (products.length < 4) {
    logger.warn(`Only ${products.length} products are configured but at least four are required (${colors.red('NOT OK')})`)
    success = false
  }
  return success
}

export const checkUnambiguousMandatorySpecialProducts = (products: ProductConfig[]) => {
  let success = true
  specialProducts.forEach(({ name, key }) => {
    // @ts-expect-error FIXME Ignoring any type issue on purpose
    const matchingProducts = products.filter((product) => product[key])
    if (matchingProducts.length === 0) {
      logger.warn(`No product is configured as ${colors.italic(name)} but one is required (${colors.red('NOT OK')})`)
      success = false
    } else if (matchingProducts.length > 1) {
      logger.warn(`${matchingProducts.length} products are configured as ${colors.italic(name)} but only one is allowed (${colors.red('NOT OK')})`)
      success = false
    }
  })
  return success
}

export const checkNecessaryExtraKeysOnSpecialProducts = (products: ProductConfig[]) => {
  let success = true
  specialProducts.forEach(({ name, key, extra = {} }) => {
    // @ts-expect-error FIXME implicit any type issue
    const matchingProducts = products.filter((product) => product[key])
    // @ts-expect-error FIXME implicit any type issue
    if (extra.key && matchingProducts.length === 1 && !matchingProducts[0][extra.key]) {
      logger.warn(`Product ${colors.italic(matchingProducts[0].name)} configured as ${colors.italic(name)} does't contain necessary ${colors.italic(`${extra.name}`)} (${colors.red('NOT OK')})`)
      success = false
    }
  })
  return success
}

export const checkUniqueSpecialOnProducts = (products: ProductConfig[]) => {
  let success = true
  products.forEach((product) => {
    // @ts-expect-error FIXME any type issue
    const appliedSpecials = specialProducts.filter(({ key }) => product[key])
    if (appliedSpecials.length > 1) {
      logger.warn(`Product ${colors.italic(product.name)} is used as ${appliedSpecials.map(({ name }) => `${colors.italic(name)}`).join(' and ')} but can only be used for one challenge (${colors.red('NOT OK')})`)
      success = false
    }
  })
  return success
}

export const checkMinimumRequiredNumberOfMemories = (memories: MemoryConfig[]) => {
  let success = true
  if (memories.length < 2) {
    logger.warn(`Only ${memories.length} memories are configured but at least two are required (${colors.red('NOT OK')})`)
    success = false
  }
  return success
}

export const checkUnambiguousMandatorySpecialMemories = (memories: MemoryConfig[]) => {
  let success = true
  specialMemories.forEach(({ name, keys }) => {
    const matchingMemories = memories.filter((memory) => memory[keys[0]] && memory[keys[1]])
    if (matchingMemories.length === 0) {
      logger.warn(`No memory is configured as ${colors.italic(name)} but one is required (${colors.red('NOT OK')})`)
      success = false
    } else if (matchingMemories.length > 1) {
      logger.warn(`${matchingMemories.length} memories are configured as ${colors.italic(name)} but only one is allowed (${colors.red('NOT OK')})`)
      success = false
    }
  })
  return success
}

export const checkSpecialMemoriesHaveNoUserAssociated = (memories: MemoryConfig[]) => {
  let success = true
  specialMemories.forEach(({ name, user, keys }) => {
    const matchingMemories = memories.filter((memory) => memory[keys[0]] && memory[keys[1]] && memory.user && memory.user !== user)
    if (matchingMemories.length > 0) {
      logger.warn(`Memory configured as ${colors.italic(name)} must belong to user ${colors.italic(user)} but was linked to ${colors.italic(matchingMemories[0].user ?? 'unknown')} user (${colors.red('NOT OK')})`)
      success = false
    }
  })
  return success
}

export const checkUniqueSpecialOnMemories = (memories: MemoryConfig[]) => {
  let success = true
  memories.forEach((memory) => {
    const appliedSpecials = specialMemories.filter(({ keys }) => memory[keys[0]] && memory[keys[1]])
    if (appliedSpecials.length > 1) {
      logger.warn(`Memory ${colors.italic(memory.caption)} is used as ${appliedSpecials.map(({ name }) => `${colors.italic(name)}`).join(' and ')} but can only be used for one challenge (${colors.red('NOT OK')})`)
      success = false
    }
  })
  return success
}

export const checkForIllogicalCombos = (configuration = config.util.toObject()) => {
  let success = true
  if (configuration.challenges.restrictToTutorialsFirst && !configuration.hackingInstructor.isEnabled) {
    logger.warn(`Restricted tutorial mode is enabled while Hacking Instructor is disabled (${colors.red('NOT OK')})`)
    success = false
  }
  if (configuration.ctf.showFlagsInNotifications && !configuration.challenges.showSolvedNotifications) {
    logger.warn(`CTF flags are enabled while challenge solved notifications are disabled (${colors.red('NOT OK')})`)
    success = false
  }
  if (['name', 'flag', 'both'].includes(configuration.ctf.showCountryDetailsInNotifications) && !configuration.ctf.showFlagsInNotifications) {
    logger.warn(`CTF country mappings for FBCTF are enabled while CTF flags are disabled (${colors.red('NOT OK')})`)
    success = false
  }
  return success
}

export default validateConfig


/* ===== FILE: ./lib/startup/cleanupFtpFolder.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { glob } from 'glob'
import logger from '../logger'
import fs from 'fs-extra'
import * as utils from '../utils'

const cleanupFtpFolder = async () => {
  try {
    const files = await glob('ftp/*.pdf')
    for (const filename of files) {
      await fs.remove(filename)
    }
  } catch (err) {
    logger.warn('Error listing PDF files in /ftp folder: ' + utils.getErrorMessage(err))
  }
}
export default cleanupFtpFolder


/* ===== FILE: ./lib/startup/registerWebsocketEvents.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import config from 'config'
import * as utils from '../utils'
import { Server } from 'socket.io'
import { notifications, challenges } from '../../data/datacache'
import * as challengeUtils from '../challengeUtils'
import * as security from '../insecurity'

let firstConnectedSocket: any = null

const globalWithSocketIO = global as typeof globalThis & {
  io: SocketIOClientStatic & Server
}

const registerWebsocketEvents = (server: any) => {
  const io = new Server(server, { cors: { origin: 'http://localhost:4200' } })
  // @ts-expect-error FIXME Type safety issue when setting global socket-io object
  globalWithSocketIO.io = io

  io.on('connection', (socket: any) => {
    if (firstConnectedSocket === null) {
      socket.emit('server started')
      firstConnectedSocket = socket.id
    }

    notifications.forEach((notification: any) => {
      socket.emit('challenge solved', notification)
    })

    socket.on('notification received', (data: any) => {
      const i = notifications.findIndex(({ flag }: any) => flag === data)
      if (i > -1) {
        notifications.splice(i, 1)
      }
    })

    socket.on('verifyLocalXssChallenge', (data: any) => {
      challengeUtils.solveIf(challenges.localXssChallenge, () => { return utils.contains(data, '<iframe src="javascript:alert(`xss`)">') })
      challengeUtils.solveIf(challenges.xssBonusChallenge, () => { return utils.contains(data, config.get('challenges.xssBonusPayload')) })
    })

    socket.on('verifySvgInjectionChallenge', (data: any) => {
      challengeUtils.solveIf(challenges.svgInjectionChallenge, () => { return data?.match(/.*\.\.\/\.\.\/\.\.[\w/-]*?\/redirect\?to=https?:\/\/placecats.com\/(g\/)?[\d]+\/[\d]+.*/) && security.isRedirectAllowed(data) })
    })

    socket.on('verifyCloseNotificationsChallenge', (data: any) => {
      challengeUtils.solveIf(challenges.closeNotificationsChallenge, () => { return Array.isArray(data) && data.length > 1 })
    })
  })
}

export default registerWebsocketEvents


/* ===== FILE: ./lib/botUtils.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */
import { ProductModel } from '../models/product'
import { type Product } from '../data/types'
import fuzz from 'fuzzball'
import { challenges } from '../data/datacache'
import * as security from './insecurity'
import * as challengeUtils from './challengeUtils'

export async function productPrice (query: string, user: string) {
  const products = await ProductModel.findAll()
  const queriedProducts = products
    .filter((product: Product) => fuzz.partial_ratio(query, product.name) > 60)
    .map((product: Product) => `${product.name} costs ${product.price}¤`)
  return {
    action: 'response',
    body: queriedProducts.length > 0 ? queriedProducts.join(', ') : 'Sorry I couldn\'t find any products with that name'
  }
}

export function couponCode (query: string, user: string) {
  challengeUtils.solveIf(challenges.bullyChatbotChallenge, () => { return true })
  return {
    action: 'response',
    body: `Oooookay, if you promise to stop nagging me here's a 10% coupon code for you: ${security.generateCoupon(10)}`
  }
}

export function testFunction (query: string, user: string) {
  return {
    action: 'response',
    body: '3be2e438b7f3d04c89d7749f727bb3bd'
  }
}


/* ===== FILE: ./views/themes/themes.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

export const themes = {
  'bluegrey-lightgreen': {
    bgColor: '#303030',
    textColor: '#FFFFFF',
    navColor: '#546E7A',
    primLight: '#424242',
    primDark: '#263238'
  },
  'blue-lightblue': {
    bgColor: '#FAFAFA',
    textColor: '#000000',
    navColor: '#1976D2',
    primLight: '#29B6F6',
    primDark: '#0277BD'
  },
  'deeppurple-amber': {
    bgColor: '#FAFAFA',
    textColor: '#000000',
    navColor: '#673AB7',
    primLight: '#9575CD',
    primDark: '#512DA8'
  },
  'indigo-pink': {
    bgColor: '#FAFAFA',
    textColor: '#000000',
    navColor: '#3F51B5',
    primLight: '#7986CB',
    primDark: '#303F9F'
  },
  'pink-bluegrey': {
    bgColor: '#303030',
    textColor: '#FFFFFF',
    navColor: '#C2185B',
    primLight: '#E91E63',
    primDark: '#880E4F'
  },
  'purple-green': {
    bgColor: '#303030',
    textColor: '#FFFFFF',
    navColor: '#7B1FA2',
    primLight: '#9C27B0',
    primDark: '#4A148C'
  },
  'deeporange-indigo': {
    bgColor: '#FAFAFA',
    textColor: '#000000',
    navColor: '#E64A19',
    primLight: '#FF5722',
    primDark: '#BF360C'
  },
  'lime-green': {
    bgColor: '#303030',
    textColor: '#000000',
    navColor: '#cddc39',
    primLight: '#ddee48',
    primDark: '#97a621'
  }
} as const


/* ===== FILE: ./server.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */
import i18n from 'i18n'
import cors from 'cors'
import fs from 'node:fs'
import yaml from 'js-yaml'
import config from 'config'
import morgan from 'morgan'
import multer from 'multer'
import helmet from 'helmet'
import http from 'node:http'
import path from 'node:path'
import express from 'express'
import colors from 'colors/safe'
import serveIndex from 'serve-index'
import bodyParser from 'body-parser'
// @ts-expect-error FIXME due to non-existing type definitions for finale-rest
import * as finale from 'finale-rest'
import compression from 'compression'
// @ts-expect-error FIXME due to non-existing type definitions for express-robots-txt
import robots from 'express-robots-txt'
import cookieParser from 'cookie-parser'
import * as Prometheus from 'prom-client'
import swaggerUi from 'swagger-ui-express'
import featurePolicy from 'feature-policy'
import { IpFilter } from 'express-ipfilter'
// @ts-expect-error FIXME due to non-existing type definitions for express-security.txt
import securityTxt from 'express-security.txt'
import { rateLimit } from 'express-rate-limit'
import { getStream } from 'file-stream-rotator'
import type { Request, Response, NextFunction } from 'express'

import { sequelize } from './models'
import { UserModel } from './models/user'
import { CardModel } from './models/card'
import { WalletModel } from './models/wallet'
import { ProductModel } from './models/product'
import { RecycleModel } from './models/recycle'
import { AddressModel } from './models/address'
import { QuantityModel } from './models/quantity'
import { FeedbackModel } from './models/feedback'
import { ComplaintModel } from './models/complaint'
import { ChallengeModel } from './models/challenge'
import { BasketItemModel } from './models/basketitem'
import { SecurityAnswerModel } from './models/securityAnswer'
import { PrivacyRequestModel } from './models/privacyRequests'
import { SecurityQuestionModel } from './models/securityQuestion'

import logger from './lib/logger'
import * as utils from './lib/utils'
import * as antiCheat from './lib/antiCheat'
import * as security from './lib/insecurity'
import validateConfig from './lib/startup/validateConfig'
import cleanupFtpFolder from './lib/startup/cleanupFtpFolder'
import customizeEasterEgg from './lib/startup/customizeEasterEgg' // vuln-code-snippet hide-line
import customizeApplication from './lib/startup/customizeApplication'
import validatePreconditions from './lib/startup/validatePreconditions'
import registerWebsocketEvents from './lib/startup/registerWebsocketEvents'
import restoreOverwrittenFilesWithOriginals from './lib/startup/restoreOverwrittenFilesWithOriginals'

import datacreator from './data/datacreator'
import locales from './data/static/locales.json'

import { login } from './routes/login'
import * as verify from './routes/verify'
import * as address from './routes/address'
import * as chatbot from './routes/chatbot'
import * as metrics from './routes/metrics'
import * as payment from './routes/payment'
import { placeOrder } from './routes/order'
import { b2bOrder } from './routes/b2bOrder'
import * as delivery from './routes/delivery'
import * as recycles from './routes/recycles'
import * as twoFactorAuth from './routes/2fa'
import { applyCoupon } from './routes/coupon'
import dataErasure from './routes/dataErasure'
import { dataExport } from './routes/dataExport'
import { retrieveBasket } from './routes/basket'
import { searchProducts } from './routes/search'
import { trackOrder } from './routes/trackOrder'
import { saveLoginIp } from './routes/saveLoginIp'
import { serveKeyFiles } from './routes/keyServer'
import * as basketItems from './routes/basketItems'
import { performRedirect } from './routes/redirect'
import { serveEasterEgg } from './routes/easterEgg'
import { getLanguageList } from './routes/languages'
import { getUserProfile } from './routes/userProfile'
import { serveAngularClient } from './routes/angular'
import { resetPassword } from './routes/resetPassword'
import { serveLogFiles } from './routes/logfileServer'
import { servePublicFiles } from './routes/fileServer'
import { addMemory, getMemories } from './routes/memory'
import { changePassword } from './routes/changePassword'
import { countryMapping } from './routes/countryMapping'
import { retrieveAppVersion } from './routes/appVersion'
import { captchas, verifyCaptcha } from './routes/captcha'
import * as restoreProgress from './routes/restoreProgress'
import { checkKeys, nftUnlocked } from './routes/checkKeys'
import { retrieveLoggedInUser } from './routes/currentUser'
import authenticatedUsers from './routes/authenticatedUsers'
import { securityQuestion } from './routes/securityQuestion'
import { servePremiumContent } from './routes/premiumReward'
import { contractExploitListener } from './routes/web3Wallet'
import { updateUserProfile } from './routes/updateUserProfile'
import { getVideo, promotionVideo } from './routes/videoHandler'
import { likeProductReviews } from './routes/likeProductReviews'
import { repeatNotification } from './routes/repeatNotification'
import { serveQuarantineFiles } from './routes/quarantineServer'
import { showProductReviews } from './routes/showProductReviews'
import { nftMintListener, walletNFTVerify } from './routes/nftMint'
import { createProductReviews } from './routes/createProductReviews'
import { getWalletBalance, addWalletBalance } from './routes/wallet'
import { retrieveAppConfiguration } from './routes/appConfiguration'
import { updateProductReviews } from './routes/updateProductReviews'
import { servePrivacyPolicyProof } from './routes/privacyPolicyProof'
import { profileImageUrlUpload } from './routes/profileImageUrlUpload'
import { profileImageFileUpload } from './routes/profileImageFileUpload'
import { serveCodeFixes, checkCorrectFix } from './routes/vulnCodeFixes'
import { imageCaptchas, verifyImageCaptcha } from './routes/imageCaptcha'
import { upgradeToDeluxe, deluxeMembershipStatus } from './routes/deluxe'
import { serveCodeSnippet, checkVulnLines } from './routes/vulnCodeSnippet'
import { orderHistory, allOrders, toggleDeliveryStatus } from './routes/orderHistory'
import { continueCode, continueCodeFindIt, continueCodeFixIt } from './routes/continueCode'
import { ensureFileIsPassed, handleZipFileUpload, checkUploadSize, checkFileType, handleXmlUpload, handleYamlUpload } from './routes/fileUpload'

const app = express()
const server = new http.Server(app)

// errorhandler requires us from overwriting a string property on it's module which is a big no-no with esmodules :/
const errorhandler = require('errorhandler')

const startTime = Date.now()

const swaggerDocument = yaml.load(fs.readFileSync('./swagger.yml', 'utf8'))

const appName = config.get<string>('application.customMetricsPrefix')
const startupGauge = new Prometheus.Gauge({
  name: `${appName}_startup_duration_seconds`,
  help: `Duration ${appName} required to perform a certain task during startup`,
  labelNames: ['task']
})

// Wraps the function and measures its (async) execution time
const collectDurationPromise = (name: string, func: (...args: any) => Promise<any>) => {
  return async (...args: any) => {
    const end = startupGauge.startTimer({ task: name })
    try {
      const res = await func(...args)
      end()
      return res
    } catch (err) {
      console.error('Error in timed startup function: ' + name, err)
      throw err
    }
  }
}

/* Sets view engine to hbs */
app.set('view engine', 'hbs')

void collectDurationPromise('validatePreconditions', validatePreconditions)()
void collectDurationPromise('cleanupFtpFolder', cleanupFtpFolder)()
void collectDurationPromise('validateConfig', validateConfig)({})

// Function called first to ensure that all the i18n files are reloaded successfully before other linked operations.
restoreOverwrittenFilesWithOriginals().then(() => {
  /* Locals */
  app.locals.captchaId = 0
  app.locals.captchaReqId = 1
  app.locals.captchaBypassReqTimes = []
  app.locals.abused_ssti_bug = false
  app.locals.abused_ssrf_bug = false

  /* Compression for all requests */
  app.use(compression())

  /* Bludgeon solution for possible CORS problems: Allow everything! */
  app.options('*', cors())
  app.use(cors())

  /* Security middleware */
  app.use(helmet.noSniff())
  app.use(helmet.frameguard())
  // app.use(helmet.xssFilter()); // = no protection from persisted XSS via RESTful API
  app.disable('x-powered-by')
  app.use(featurePolicy({
    features: {
      payment: ["'self'"]
    }
  }))

  /* Hiring header */
  app.use((req: Request, res: Response, next: NextFunction) => {
    res.append('X-Recruiting', config.get('application.securityTxt.hiring'))
    next()
  })

  /* Remove duplicate slashes from URL which allowed bypassing subsequent filters */
  app.use((req: Request, res: Response, next: NextFunction) => {
    req.url = req.url.replace(/[/]+/g, '/')
    next()
  })

  /* Increase request counter metric for every request */
  app.use(metrics.observeRequestMetricsMiddleware())

  /* Security Policy */
  const securityTxtExpiration = new Date()
  securityTxtExpiration.setFullYear(securityTxtExpiration.getFullYear() + 1)
  app.get(['/.well-known/security.txt', '/security.txt'], verify.accessControlChallenges())
  app.use(['/.well-known/security.txt', '/security.txt'], securityTxt({
    contact: config.get('application.securityTxt.contact'),
    encryption: config.get('application.securityTxt.encryption'),
    acknowledgements: config.get('application.securityTxt.acknowledgements'),
    'Preferred-Languages': [...new Set(locales.map((locale: { key: string }) => locale.key.substr(0, 2)))].join(', '),
    hiring: config.get('application.securityTxt.hiring'),
    csaf: config.get<string>('server.baseUrl') + config.get<string>('application.securityTxt.csaf'),
    expires: securityTxtExpiration.toUTCString()
  }))

  /* robots.txt */
  app.use(robots({ UserAgent: '*', Disallow: '/ftp' }))

  /* Check for any URLs having been called that would be expected for challenge solving without cheating */
  app.use(antiCheat.checkForPreSolveInteractions())

  /* Checks for challenges solved by retrieving a file implicitly or explicitly */
  app.use('/assets/public/images/padding', verify.accessControlChallenges())
  app.use('/assets/public/images/products', verify.accessControlChallenges())
  app.use('/assets/public/images/uploads', verify.accessControlChallenges())
  app.use('/assets/i18n', verify.accessControlChallenges())

  /* Checks for challenges solved by abusing SSTi and SSRF bugs */
  app.use('/solve/challenges/server-side', verify.serverSideChallenges())

  /* Create middleware to change paths from the serve-index plugin from absolute to relative */
  const serveIndexMiddleware = (req: Request, res: Response, next: NextFunction) => {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    const origEnd = res.end
    // @ts-expect-error FIXME assignment broken due to seemingly void return value
    res.end = function () {
      if (arguments.length) {
        const reqPath = req.originalUrl.replace(/\?.*$/, '')
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const currentFolder = reqPath.split('/').pop()!
        arguments[0] = arguments[0].replace(/a href="([^"]+?)"/gi, function (matchString: string, matchedUrl: string) {
          let relativePath = path.relative(reqPath, matchedUrl)
          if (relativePath === '') {
            relativePath = currentFolder
          } else if (!relativePath.startsWith('.') && currentFolder !== '') {
            relativePath = currentFolder + '/' + relativePath
          } else {
            relativePath = relativePath.replace('..', '.')
          }
          return 'a href="' + relativePath + '"'
        })
      }
      // @ts-expect-error FIXME passed argument has wrong type
      origEnd.apply(this, arguments)
    }
    next()
  }

  // vuln-code-snippet start directoryListingChallenge accessLogDisclosureChallenge
  /* /ftp directory browsing and file download */ // vuln-code-snippet neutral-line directoryListingChallenge
  app.use('/ftp', serveIndexMiddleware, serveIndex('ftp', { icons: true })) // vuln-code-snippet vuln-line directoryListingChallenge
  app.use('/ftp(?!/quarantine)/:file', servePublicFiles()) // vuln-code-snippet vuln-line directoryListingChallenge
  app.use('/ftp/quarantine/:file', serveQuarantineFiles()) // vuln-code-snippet neutral-line directoryListingChallenge

  app.use('/.well-known', serveIndexMiddleware, serveIndex('.well-known', { icons: true, view: 'details' }))
  app.use('/.well-known', express.static('.well-known'))

  /* /encryptionkeys directory browsing */
  app.use('/encryptionkeys', serveIndexMiddleware, serveIndex('encryptionkeys', { icons: true, view: 'details' }))
  app.use('/encryptionkeys/:file', serveKeyFiles())

  /* /logs directory browsing */ // vuln-code-snippet neutral-line accessLogDisclosureChallenge
  app.use('/support/logs', serveIndexMiddleware, serveIndex('logs', { icons: true, view: 'details' })) // vuln-code-snippet vuln-line accessLogDisclosureChallenge
  app.use('/support/logs', verify.accessControlChallenges()) // vuln-code-snippet hide-line
  app.use('/support/logs/:file', serveLogFiles()) // vuln-code-snippet vuln-line accessLogDisclosureChallenge

  /* Swagger documentation for B2B v2 endpoints */
  app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerDocument))

  app.use(express.static(path.resolve('frontend/dist/frontend')))
  app.use(cookieParser('kekse'))
  // vuln-code-snippet end directoryListingChallenge accessLogDisclosureChallenge

  /* Configure and enable backend-side i18n */
  i18n.configure({
    locales: locales.map((locale: { key: string }) => locale.key),
    directory: path.resolve('i18n'),
    cookie: 'language',
    defaultLocale: 'en',
    autoReload: true
  })
  app.use(i18n.init)

  app.use(bodyParser.urlencoded({ extended: true }))
  /* File Upload */
  app.post('/file-upload', uploadToMemory.single('file'), ensureFileIsPassed, metrics.observeFileUploadMetricsMiddleware(), checkUploadSize, checkFileType, handleZipFileUpload, handleXmlUpload, handleYamlUpload)
  app.post('/profile/image/file', uploadToMemory.single('file'), ensureFileIsPassed, metrics.observeFileUploadMetricsMiddleware(), profileImageFileUpload())
  app.post('/profile/image/url', uploadToMemory.single('file'), profileImageUrlUpload())
  app.post('/rest/memories', uploadToDisk.single('image'), ensureFileIsPassed, security.appendUserId(), metrics.observeFileUploadMetricsMiddleware(), addMemory())

  app.use(bodyParser.text({ type: '*/*' }))
  app.use(function jsonParser (req: Request, res: Response, next: NextFunction) {
    // @ts-expect-error FIXME intentionally saving original request in this property
    req.rawBody = req.body
    if (req.headers['content-type']?.includes('application/json')) {
      if (!req.body) {
        req.body = {}
      }
      if (req.body !== Object(req.body)) { // Expensive workaround for 500 errors during Frisby test run (see #640)
        req.body = JSON.parse(req.body)
      }
    }
    next()
  })

  /* HTTP request logging */
  const accessLogStream = getStream({
    filename: path.resolve('logs/access.log.%DATE%'),
    date_format: 'YYYY-MM-DD',
    audit_file: 'logs/audit.json',
    frequency: 'daily',
    verbose: false,
    max_logs: '2d'
  })
  app.use(morgan('combined', { stream: accessLogStream }))

  // vuln-code-snippet start resetPasswordMortyChallenge
  /* Rate limiting */
  app.enable('trust proxy')
  app.use('/rest/user/reset-password', rateLimit({
    windowMs: 5 * 60 * 1000,
    max: 100,
    keyGenerator ({ headers, ip }: { headers: any, ip: any }) { return headers['X-Forwarded-For'] ?? ip } // vuln-code-snippet vuln-line resetPasswordMortyChallenge
  }))
  // vuln-code-snippet end resetPasswordMortyChallenge

  // vuln-code-snippet start changeProductChallenge
  /** Authorization **/
  /* Checks on JWT in Authorization header */ // vuln-code-snippet hide-line
  app.use(verify.jwtChallenges()) // vuln-code-snippet hide-line
  /* Baskets: Unauthorized users are not allowed to access baskets */
  app.use('/rest/basket', security.isAuthorized(), security.appendUserId())
  /* BasketItems: API only accessible for authenticated users */
  app.use('/api/BasketItems', security.isAuthorized())
  app.use('/api/BasketItems/:id', security.isAuthorized())
  /* Feedbacks: GET allowed for feedback carousel, POST allowed in order to provide feedback without being logged in */
  app.use('/api/Feedbacks/:id', security.isAuthorized())
  /* Users: Only POST is allowed in order to register a new user */
  app.get('/api/Users', security.isAuthorized())
  app.route('/api/Users/:id')
    .get(security.isAuthorized())
    .put(security.denyAll())
    .delete(security.denyAll())
  /* Products: Only GET is allowed in order to view products */ // vuln-code-snippet neutral-line changeProductChallenge
  app.post('/api/Products', security.isAuthorized()) // vuln-code-snippet neutral-line changeProductChallenge
  // app.put('/api/Products/:id', security.isAuthorized()) // vuln-code-snippet vuln-line changeProductChallenge
  app.delete('/api/Products/:id', security.denyAll())
  /* Challenges: GET list of challenges allowed. Everything else forbidden entirely */
  app.post('/api/Challenges', security.denyAll())
  app.use('/api/Challenges/:id', security.denyAll())
  /* Complaints: POST and GET allowed when logged in only */
  app.get('/api/Complaints', security.isAuthorized())
  app.post('/api/Complaints', security.isAuthorized())
  app.use('/api/Complaints/:id', security.denyAll())
  /* Recycles: POST and GET allowed when logged in only */
  app.get('/api/Recycles', recycles.blockRecycleItems())
  app.post('/api/Recycles', security.isAuthorized())
  /* Challenge evaluation before finale takes over */
  app.get('/api/Recycles/:id', recycles.getRecycleItem())
  app.put('/api/Recycles/:id', security.denyAll())
  app.delete('/api/Recycles/:id', security.denyAll())
  /* SecurityQuestions: Only GET list of questions allowed. */
  app.post('/api/SecurityQuestions', security.denyAll())
  app.use('/api/SecurityQuestions/:id', security.denyAll())
  /* SecurityAnswers: Only POST of answer allowed. */
  app.get('/api/SecurityAnswers', security.denyAll())
  app.use('/api/SecurityAnswers/:id', security.denyAll())
  /* REST API */
  app.use('/rest/user/authentication-details', security.isAuthorized())
  app.use('/rest/basket/:id', security.isAuthorized())
  app.use('/rest/basket/:id/order', security.isAuthorized())
  /* Challenge evaluation before finale takes over */ // vuln-code-snippet hide-start
  app.post('/api/Feedbacks', verify.forgedFeedbackChallenge())
  /* Captcha verification before finale takes over */
  app.post('/api/Feedbacks', verifyCaptcha())
  /* Captcha Bypass challenge verification */
  app.post('/api/Feedbacks', verify.captchaBypassChallenge())
  /* User registration challenge verifications before finale takes over */
  app.post('/api/Users', (req: Request, res: Response, next: NextFunction) => {
    if (req.body.email !== undefined && req.body.password !== undefined && req.body.passwordRepeat !== undefined) {
      if (req.body.email.length !== 0 && req.body.password.length !== 0) {
        req.body.email = req.body.email.trim()
        req.body.password = req.body.password.trim()
        req.body.passwordRepeat = req.body.passwordRepeat.trim()
      } else {
        res.status(400).send(res.__('Invalid email/password cannot be empty'))
      }
    }
    next()
  })
  app.post('/api/Users', verify.registerAdminChallenge())
  app.post('/api/Users', verify.passwordRepeatChallenge()) // vuln-code-snippet hide-end
  app.post('/api/Users', verify.emptyUserRegistration())
  /* Unauthorized users are not allowed to access B2B API */
  app.use('/b2b/v2', security.isAuthorized())
  /* Check if the quantity is available in stock and limit per user not exceeded, then add item to basket */
  app.put('/api/BasketItems/:id', security.appendUserId(), basketItems.quantityCheckBeforeBasketItemUpdate())
  app.post('/api/BasketItems', security.appendUserId(), basketItems.quantityCheckBeforeBasketItemAddition(), basketItems.addBasketItem())
  /* Accounting users are allowed to check and update quantities */
  app.delete('/api/Quantitys/:id', security.denyAll())
  app.post('/api/Quantitys', security.denyAll())
  app.use('/api/Quantitys/:id', security.isAccounting(), IpFilter(['123.456.789'], { mode: 'allow' }))
  /* Feedbacks: Do not allow changes of existing feedback */
  app.put('/api/Feedbacks/:id', security.denyAll())
  /* PrivacyRequests: Only allowed for authenticated users */
  app.use('/api/PrivacyRequests', security.isAuthorized())
  app.use('/api/PrivacyRequests/:id', security.isAuthorized())
  /* PaymentMethodRequests: Only allowed for authenticated users */
  app.post('/api/Cards', security.appendUserId())
  app.get('/api/Cards', security.appendUserId(), payment.getPaymentMethods())
  app.put('/api/Cards/:id', security.denyAll())
  app.delete('/api/Cards/:id', security.appendUserId(), payment.delPaymentMethodById())
  app.get('/api/Cards/:id', security.appendUserId(), payment.getPaymentMethodById())
  /* PrivacyRequests: Only POST allowed for authenticated users */
  app.post('/api/PrivacyRequests', security.isAuthorized())
  app.get('/api/PrivacyRequests', security.denyAll())
  app.use('/api/PrivacyRequests/:id', security.denyAll())

  app.post('/api/Addresss', security.appendUserId())
  app.get('/api/Addresss', security.appendUserId(), address.getAddress())
  app.put('/api/Addresss/:id', security.appendUserId())
  app.delete('/api/Addresss/:id', security.appendUserId(), address.delAddressById())
  app.get('/api/Addresss/:id', security.appendUserId(), address.getAddressById())
  app.get('/api/Deliverys', delivery.getDeliveryMethods())
  app.get('/api/Deliverys/:id', delivery.getDeliveryMethod())
  // vuln-code-snippet end changeProductChallenge

  /* Verify the 2FA Token */
  app.post('/rest/2fa/verify',
    rateLimit({ windowMs: 5 * 60 * 1000, max: 100, validate: false }),
    twoFactorAuth.verify
  )
  /* Check 2FA Status for the current User */
  app.get('/rest/2fa/status', security.isAuthorized(), twoFactorAuth.status)
  /* Enable 2FA for the current User */
  app.post('/rest/2fa/setup',
    rateLimit({ windowMs: 5 * 60 * 1000, max: 100, validate: false }),
    security.isAuthorized(),
    twoFactorAuth.setup
  )
  /* Disable 2FA Status for the current User */
  app.post('/rest/2fa/disable',
    rateLimit({ windowMs: 5 * 60 * 1000, max: 100, validate: false }),
    security.isAuthorized(),
    twoFactorAuth.disable
  )
  /* Verifying DB related challenges can be postponed until the next request for challenges is coming via finale */
  app.use(verify.databaseRelatedChallenges())

  // vuln-code-snippet start registerAdminChallenge
  /* Generated API endpoints */
  finale.initialize({ app, sequelize })

  const autoModels = [
    { name: 'User', exclude: ['password', 'totpSecret'], model: UserModel },
    { name: 'Product', exclude: [], model: ProductModel },
    { name: 'Feedback', exclude: [], model: FeedbackModel },
    { name: 'BasketItem', exclude: [], model: BasketItemModel },
    { name: 'Challenge', exclude: [], model: ChallengeModel },
    { name: 'Complaint', exclude: [], model: ComplaintModel },
    { name: 'Recycle', exclude: [], model: RecycleModel },
    { name: 'SecurityQuestion', exclude: [], model: SecurityQuestionModel },
    { name: 'SecurityAnswer', exclude: [], model: SecurityAnswerModel },
    { name: 'Address', exclude: [], model: AddressModel },
    { name: 'PrivacyRequest', exclude: [], model: PrivacyRequestModel },
    { name: 'Card', exclude: [], model: CardModel },
    { name: 'Quantity', exclude: [], model: QuantityModel }
  ]

  for (const { name, exclude, model } of autoModels) {
    const resource = finale.resource({
      model,
      endpoints: [`/api/${name}s`, `/api/${name}s/:id`],
      excludeAttributes: exclude,
      pagination: false
    })

    // create a wallet when a new user is registered using API
    if (name === 'User') { // vuln-code-snippet neutral-line registerAdminChallenge
      resource.create.send.before((req: Request, res: Response, context: { instance: { id: any }, continue: any }) => { // vuln-code-snippet vuln-line registerAdminChallenge
        WalletModel.create({ UserId: context.instance.id }).catch((err: unknown) => {
          console.log(err)
        })
        return context.continue // vuln-code-snippet neutral-line registerAdminChallenge
      }) // vuln-code-snippet neutral-line registerAdminChallenge
    } // vuln-code-snippet neutral-line registerAdminChallenge
    // vuln-code-snippet end registerAdminChallenge

    // translate challenge descriptions and hints on-the-fly
    if (name === 'Challenge') {
      resource.list.fetch.after((req: Request, res: Response, context: { instance: string | any[], continue: any }) => {
        for (let i = 0; i < context.instance.length; i++) {
          let description = context.instance[i].description
          if (utils.contains(description, '<em>(This challenge is <strong>')) {
            const warning = description.substring(description.indexOf(' <em>(This challenge is <strong>'))
            description = description.substring(0, description.indexOf(' <em>(This challenge is <strong>'))
            context.instance[i].description = req.__(description) + req.__(warning)
          } else {
            context.instance[i].description = req.__(description)
          }
          if (context.instance[i].hint) {
            context.instance[i].hint = req.__(context.instance[i].hint)
          }
        }
        return context.continue
      })
      resource.read.send.before((req: Request, res: Response, context: { instance: { description: string, hint: string }, continue: any }) => {
        context.instance.description = req.__(context.instance.description)
        if (context.instance.hint) {
          context.instance.hint = req.__(context.instance.hint)
        }
        return context.continue
      })
    }

    // translate security questions on-the-fly
    if (name === 'SecurityQuestion') {
      resource.list.fetch.after((req: Request, res: Response, context: { instance: string | any[], continue: any }) => {
        for (let i = 0; i < context.instance.length; i++) {
          context.instance[i].question = req.__(context.instance[i].question)
        }
        return context.continue
      })
      resource.read.send.before((req: Request, res: Response, context: { instance: { question: string }, continue: any }) => {
        context.instance.question = req.__(context.instance.question)
        return context.continue
      })
    }

    // translate product names and descriptions on-the-fly
    if (name === 'Product') {
      resource.list.fetch.after((req: Request, res: Response, context: { instance: any[], continue: any }) => {
        for (let i = 0; i < context.instance.length; i++) {
          context.instance[i].name = req.__(context.instance[i].name)
          context.instance[i].description = req.__(context.instance[i].description)
        }
        return context.continue
      })
      resource.read.send.before((req: Request, res: Response, context: { instance: { name: string, description: string }, continue: any }) => {
        context.instance.name = req.__(context.instance.name)
        context.instance.description = req.__(context.instance.description)
        return context.continue
      })
    }

    // fix the api difference between finale (fka epilogue) and previously used sequlize-restful
    resource.all.send.before((req: Request, res: Response, context: { instance: { status: string, data: any }, continue: any }) => {
      context.instance = {
        status: 'success',
        data: context.instance
      }
      return context.continue
    })
  }

  /* Custom Restful API */
  app.post('/rest/user/login', login())
  app.get('/rest/user/change-password', changePassword())
  app.post('/rest/user/reset-password', resetPassword())
  app.get('/rest/user/security-question', securityQuestion())
  app.get('/rest/user/whoami', security.updateAuthenticatedUsers(), retrieveLoggedInUser())
  app.get('/rest/user/authentication-details', authenticatedUsers())
  app.get('/rest/products/search', searchProducts())
  app.get('/rest/basket/:id', retrieveBasket())
  app.post('/rest/basket/:id/checkout', placeOrder())
  app.put('/rest/basket/:id/coupon/:coupon', applyCoupon())
  app.get('/rest/admin/application-version', retrieveAppVersion())
  app.get('/rest/admin/application-configuration', retrieveAppConfiguration())
  app.get('/rest/repeat-notification', repeatNotification())
  app.get('/rest/continue-code', continueCode())
  app.get('/rest/continue-code-findIt', continueCodeFindIt())
  app.get('/rest/continue-code-fixIt', continueCodeFixIt())
  app.put('/rest/continue-code-findIt/apply/:continueCode', restoreProgress.restoreProgressFindIt())
  app.put('/rest/continue-code-fixIt/apply/:continueCode', restoreProgress.restoreProgressFixIt())
  app.put('/rest/continue-code/apply/:continueCode', restoreProgress.restoreProgress())
  app.get('/rest/captcha', captchas())
  app.get('/rest/image-captcha', imageCaptchas())
  app.get('/rest/track-order/:id', trackOrder())
  app.get('/rest/country-mapping', countryMapping())
  app.get('/rest/saveLoginIp', saveLoginIp())
  app.post('/rest/user/data-export', security.appendUserId(), verifyImageCaptcha())
  app.post('/rest/user/data-export', security.appendUserId(), dataExport())
  app.get('/rest/languages', getLanguageList())
  app.get('/rest/order-history', orderHistory())
  app.get('/rest/order-history/orders', security.isAccounting(), allOrders())
  app.put('/rest/order-history/:id/delivery-status', security.isAccounting(), toggleDeliveryStatus())
  app.get('/rest/wallet/balance', security.appendUserId(), getWalletBalance())
  app.put('/rest/wallet/balance', security.appendUserId(), addWalletBalance())
  app.get('/rest/deluxe-membership', deluxeMembershipStatus())
  app.post('/rest/deluxe-membership', security.appendUserId(), upgradeToDeluxe())
  app.get('/rest/memories', getMemories())
  app.get('/rest/chatbot/status', chatbot.status())
  app.post('/rest/chatbot/respond', chatbot.process())
  /* NoSQL API endpoints */
  app.get('/rest/products/:id/reviews', showProductReviews())
  app.put('/rest/products/:id/reviews', createProductReviews())
  app.patch('/rest/products/reviews', security.isAuthorized(), updateProductReviews())
  app.post('/rest/products/reviews', security.isAuthorized(), likeProductReviews())

  /* Web3 API endpoints */
  app.post('/rest/web3/submitKey', checkKeys())
  app.get('/rest/web3/nftUnlocked', nftUnlocked())
  app.get('/rest/web3/nftMintListen', nftMintListener())
  app.post('/rest/web3/walletNFTVerify', walletNFTVerify())
  app.post('/rest/web3/walletExploitAddress', contractExploitListener())

  /* B2B Order API */
  app.post('/b2b/v2/orders', b2bOrder())

  /* File Serving */
  app.get('/the/devs/are/so/funny/they/hid/an/easter/egg/within/the/easter/egg', serveEasterEgg())
  app.get('/this/page/is/hidden/behind/an/incredibly/high/paywall/that/could/only/be/unlocked/by/sending/1btc/to/us', servePremiumContent())
  app.get('/we/may/also/instruct/you/to/refuse/all/reasonably/necessary/responsibility', servePrivacyPolicyProof())

  /* Route for dataerasure page */
  app.use('/dataerasure', dataErasure)

  /* Route for redirects */
  app.get('/redirect', performRedirect())

  /* Routes for promotion video page */
  app.get('/promotion', promotionVideo())
  app.get('/video', getVideo())

  /* Routes for profile page */
  app.get('/profile', security.updateAuthenticatedUsers(), getUserProfile())
  app.post('/profile', updateUserProfile())

  /* Route for vulnerable code snippets */
  app.get('/snippets/:challenge', serveCodeSnippet())
  app.post('/snippets/verdict', checkVulnLines())
  app.get('/snippets/fixes/:key', serveCodeFixes())
  app.post('/snippets/fixes', checkCorrectFix())

  app.use(serveAngularClient())

  /* Error Handling */
  app.use(verify.errorHandlingChallenge())
  app.use(errorhandler())
}).catch((err) => {
  console.error(err)
})

const uploadToMemory = multer({ storage: multer.memoryStorage(), limits: { fileSize: 200000 } })
const mimeTypeMap: any = {
  'image/png': 'png',
  'image/jpeg': 'jpg',
  'image/jpg': 'jpg'
}
const uploadToDisk = multer({
  storage: multer.diskStorage({
    destination: (req: Request, file: any, cb: any) => {
      const isValid = mimeTypeMap[file.mimetype]
      let error: Error | null = new Error('Invalid mime type')
      if (isValid) {
        error = null
      }
      cb(error, path.resolve('frontend/dist/frontend/assets/public/images/uploads/'))
    },
    filename: (req: Request, file: any, cb: any) => {
      const name = security.sanitizeFilename(file.originalname)
        .toLowerCase()
        .split(' ')
        .join('-')
      const ext = mimeTypeMap[file.mimetype]
      cb(null, name + '-' + Date.now() + '.' + ext)
    }
  })
})

const expectedModels = ['Address', 'Basket', 'BasketItem', 'Captcha', 'Card', 'Challenge', 'Complaint', 'Delivery', 'Feedback', 'ImageCaptcha', 'Memory', 'PrivacyRequestModel', 'Product', 'Quantity', 'Recycle', 'SecurityAnswer', 'SecurityQuestion', 'User', 'Wallet']
while (!expectedModels.every(model => Object.keys(sequelize.models).includes(model))) {
  logger.info(`Entity models ${colors.bold(Object.keys(sequelize.models).length.toString())} of ${colors.bold(expectedModels.length.toString())} are initialized (${colors.yellow('WAITING')})`)
}
logger.info(`Entity models ${colors.bold(Object.keys(sequelize.models).length.toString())} of ${colors.bold(expectedModels.length.toString())} are initialized (${colors.green('OK')})`)

// vuln-code-snippet start exposedMetricsChallenge
/* Serve metrics */
let metricsUpdateLoop: any
const Metrics = metrics.observeMetrics() // vuln-code-snippet neutral-line exposedMetricsChallenge
app.get('/metrics', metrics.serveMetrics()) // vuln-code-snippet vuln-line exposedMetricsChallenge
errorhandler.title = `${config.get<string>('application.name')} (Express ${utils.version('express')})`

export async function start (readyCallback?: () => void) {
  const datacreatorEnd = startupGauge.startTimer({ task: 'datacreator' })
  await sequelize.sync({ force: true })
  await datacreator()
  datacreatorEnd()
  const port = process.env.PORT ?? config.get('server.port')
  process.env.BASE_PATH = process.env.BASE_PATH ?? config.get('server.basePath')

  metricsUpdateLoop = Metrics.updateLoop() // vuln-code-snippet neutral-line exposedMetricsChallenge

  server.listen(port, () => {
    logger.info(colors.cyan(`Server listening on port ${colors.bold(`${port}`)}`))
    startupGauge.set({ task: 'ready' }, (Date.now() - startTime) / 1000)
    if (process.env.BASE_PATH !== '') {
      logger.info(colors.cyan(`Server using proxy base path ${colors.bold(`${process.env.BASE_PATH}`)} for redirects`))
    }
    registerWebsocketEvents(server)
    if (readyCallback) {
      readyCallback()
    }
  })

  void collectDurationPromise('customizeApplication', customizeApplication)() // vuln-code-snippet hide-line
  void collectDurationPromise('customizeEasterEgg', customizeEasterEgg)() // vuln-code-snippet hide-line
}

export function close (exitCode: number | undefined) {
  if (server) {
    clearInterval(metricsUpdateLoop)
    server.close()
  }
  if (exitCode !== undefined) {
    process.exit(exitCode)
  }
}
// vuln-code-snippet end exposedMetricsChallenge

// stop server on sigint or sigterm signals
process.on('SIGINT', () => { close(0) })
process.on('SIGTERM', () => { close(0) })


/* ===== FILE: ./routes/wallet.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type Request, type Response, type NextFunction } from 'express'
import { WalletModel } from '../models/wallet'
import { CardModel } from '../models/card'

export function getWalletBalance () {
  return async (req: Request, res: Response, next: NextFunction) => {
    const wallet = await WalletModel.findOne({ where: { UserId: req.body.UserId } })
    if (wallet != null) {
      res.status(200).json({ status: 'success', data: wallet.balance })
    } else {
      res.status(404).json({ status: 'error' })
    }
  }
}

export function addWalletBalance () {
  return async (req: Request, res: Response, next: NextFunction) => {
    const cardId = req.body.paymentId
    const card = cardId ? await CardModel.findOne({ where: { id: cardId, UserId: req.body.UserId } }) : null
    if (card != null) {
      WalletModel.increment({ balance: req.body.balance }, { where: { UserId: req.body.UserId } }).then(() => {
        res.status(200).json({ status: 'success', data: req.body.balance })
      }).catch(() => {
        res.status(404).json({ status: 'error' })
      })
    } else {
      res.status(402).json({ status: 'error', message: 'Payment not accepted.' })
    }
  }
}


/* ===== FILE: ./routes/securityQuestion.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type Request, type Response, type NextFunction } from 'express'
import { SecurityAnswerModel } from '../models/securityAnswer'
import { UserModel } from '../models/user'
import { SecurityQuestionModel } from '../models/securityQuestion'

export function securityQuestion () {
  return ({ query }: Request, res: Response, next: NextFunction) => {
    const email = query.email
    SecurityAnswerModel.findOne({
      include: [{
        model: UserModel,
        where: { email: email?.toString() }
      }]
    }).then((answer: SecurityAnswerModel | null) => {
      if (answer != null) {
        SecurityQuestionModel.findByPk(answer.SecurityQuestionId).then((question: SecurityQuestionModel | null) => {
          res.json({ question })
        }).catch((error: Error) => {
          next(error)
        })
      } else {
        res.json({})
      }
    }).catch((error: unknown) => {
      next(error)
    })
  }
}


/* ===== FILE: ./routes/payment.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type Request, type Response, type NextFunction } from 'express'
import { CardModel } from '../models/card'

interface displayCard {
  UserId: number
  id: number
  fullName: string
  cardNum: string
  expMonth: number
  expYear: number
}

export function getPaymentMethods () {
  return async (req: Request, res: Response, next: NextFunction) => {
    const displayableCards: displayCard[] = []
    const cards = await CardModel.findAll({ where: { UserId: req.body.UserId } })
    cards.forEach(card => {
      const displayableCard: displayCard = {
        UserId: card.UserId,
        id: card.id,
        fullName: card.fullName,
        cardNum: '',
        expMonth: card.expMonth,
        expYear: card.expYear
      }
      const cardNumber = String(card.cardNum)
      displayableCard.cardNum = '*'.repeat(12) + cardNumber.substring(cardNumber.length - 4)
      displayableCards.push(displayableCard)
    })
    res.status(200).json({ status: 'success', data: displayableCards })
  }
}

export function getPaymentMethodById () {
  return async (req: Request, res: Response, next: NextFunction) => {
    const card = await CardModel.findOne({ where: { id: req.params.id, UserId: req.body.UserId } })
    const displayableCard: displayCard = {
      UserId: 0,
      id: 0,
      fullName: '',
      cardNum: '',
      expMonth: 0,
      expYear: 0
    }
    if (card != null) {
      displayableCard.UserId = card.UserId
      displayableCard.id = card.id
      displayableCard.fullName = card.fullName
      displayableCard.expMonth = card.expMonth
      displayableCard.expYear = card.expYear

      const cardNumber = String(card.cardNum)
      displayableCard.cardNum = '*'.repeat(12) + cardNumber.substring(cardNumber.length - 4)
    }
    if ((card != null) && displayableCard) {
      res.status(200).json({ status: 'success', data: displayableCard })
    } else {
      res.status(400).json({ status: 'error', data: 'Malicious activity detected' })
    }
  }
}

export function delPaymentMethodById () {
  return async (req: Request, res: Response, next: NextFunction) => {
    const card = await CardModel.destroy({ where: { id: req.params.id, UserId: req.body.UserId } })
    if (card) {
      res.status(200).json({ status: 'success', data: 'Card deleted successfully.' })
    } else {
      res.status(400).json({ status: 'error', data: 'Malicious activity detected.' })
    }
  }
}


/* ===== FILE: ./routes/languages.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import locales from '../data/static/locales.json'
import fs from 'node:fs'
import { type Request, type Response, type NextFunction } from 'express'

export function getLanguageList () { // TODO Refactor and extend to also load backend translations from /i18n/*json and calculate joint percentage/gauge
  return (req: Request, res: Response, next: NextFunction) => {
    const languages: Array<{ key: string, lang: any, icons: string[], shortKey: string, percentage: unknown, gauge: string }> = []
    let count = 0
    let enContent: any

    fs.readFile('frontend/dist/frontend/assets/i18n/en.json', 'utf-8', (err, content) => {
      if (err != null) {
        next(new Error(`Unable to retrieve en.json language file: ${err.message}`))
      }
      enContent = JSON.parse(content)
      fs.readdir('frontend/dist/frontend/assets/i18n/', (err, languageFiles) => {
        if (err != null) {
          next(new Error(`Unable to read i18n directory: ${err.message}`))
        }
        languageFiles.forEach((fileName) => {
          // eslint-disable-next-line @typescript-eslint/no-misused-promises
          fs.readFile('frontend/dist/frontend/assets/i18n/' + fileName, 'utf-8', async (err, content) => {
            if (err != null) {
              next(new Error(`Unable to retrieve ${fileName} language file: ${err.message}`))
            }
            const fileContent = JSON.parse(content)
            const percentage = await calcPercentage(fileContent, enContent)
            const key = fileName.substring(0, fileName.indexOf('.'))
            const locale = locales.find((l) => l.key === key)
            const lang: any = {
              key,
              lang: fileContent.LANGUAGE,
              icons: locale?.icons,
              shortKey: locale?.shortKey,
              percentage,
              gauge: (percentage > 90 ? 'full' : (percentage > 70 ? 'three-quarters' : (percentage > 50 ? 'half' : (percentage > 30 ? 'quarter' : 'empty'))))
            }
            if (!(fileName === 'en.json' || fileName === 'tlh_AA.json')) {
              languages.push(lang)
            }
            count++
            if (count === languageFiles.length) {
              languages.push({ key: 'en', icons: ['gb', 'us'], shortKey: 'EN', lang: 'English', percentage: 100, gauge: 'full' })
              languages.sort((a, b) => a.lang.localeCompare(b.lang))
              res.status(200).json(languages)
            }
          })
        })
      })
    })

    async function calcPercentage (fileContent: any, enContent: any): Promise<number> {
      const totalStrings = Object.keys(enContent).length
      let differentStrings = 0
      return await new Promise((resolve, reject) => {
        try {
          for (const key in fileContent) {
            if (Object.prototype.hasOwnProperty.call(fileContent, key) && fileContent[key] !== enContent[key]) {
              differentStrings++
            }
          }
          resolve((differentStrings / totalStrings) * 100)
        } catch (err) {
          reject(err)
        }
      })
    }
  }
}


/* ===== FILE: ./routes/dataErasure.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */
import express, { type NextFunction, type Request, type Response } from 'express'
import path from 'node:path'

import { SecurityQuestionModel } from '../models/securityQuestion'
import { PrivacyRequestModel } from '../models/privacyRequests'
import { SecurityAnswerModel } from '../models/securityAnswer'
import * as challengeUtils from '../lib/challengeUtils'
import { challenges } from '../data/datacache'
import * as security from '../lib/insecurity'
import { UserModel } from '../models/user'

const router = express.Router()

router.get('/', async (req: Request, res: Response, next: NextFunction) => {
  const loggedInUser = security.authenticatedUsers.get(req.cookies.token)
  if (!loggedInUser) {
    next(new Error('Blocked illegal activity by ' + req.socket.remoteAddress))
    return
  }
  const email = loggedInUser.data.email

  try {
    const answer = await SecurityAnswerModel.findOne({
      include: [{
        model: UserModel,
        where: { email }
      }]
    })
    if (answer == null) {
      throw new Error('No answer found!')
    }
    const question = await SecurityQuestionModel.findByPk(answer.SecurityQuestionId)
    if (question == null) {
      throw new Error('No question found!')
    }

    res.render('dataErasureForm', { userEmail: email, securityQuestion: question.question })
  } catch (error) {
    next(error)
  }
})

interface DataErasureRequestParams {
  layout?: string
  email: string
  securityAnswer: string
}

// eslint-disable-next-line @typescript-eslint/no-misused-promises
router.post('/', async (req: Request<Record<string, unknown>, Record<string, unknown>, DataErasureRequestParams>, res: Response, next: NextFunction): Promise<void> => {
  const loggedInUser = security.authenticatedUsers.get(req.cookies.token)
  if (!loggedInUser) {
    next(new Error('Blocked illegal activity by ' + req.socket.remoteAddress))
    return
  }

  try {
    await PrivacyRequestModel.create({
      UserId: loggedInUser.data.id,
      deletionRequested: true
    })

    res.clearCookie('token')
    if (req.body.layout) {
      const filePath: string = path.resolve(req.body.layout).toLowerCase()
      const isForbiddenFile: boolean = (filePath.includes('ftp') || filePath.includes('ctf.key') || filePath.includes('encryptionkeys'))
      if (!isForbiddenFile) {
        res.render('dataErasureResult', {
          ...req.body
        }, (error, html) => {
          if (!html || error) {
            next(new Error(error.message))
          } else {
            const sendlfrResponse: string = html.slice(0, 100) + '......'
            res.send(sendlfrResponse)
            challengeUtils.solveIf(challenges.lfrChallenge, () => { return true })
          }
        })
      } else {
        next(new Error('File access not allowed'))
      }
    } else {
      res.render('dataErasureResult', {
        ...req.body
      })
    }
  } catch (error) {
    next(error)
  }
})

export default router


/* ===== FILE: ./routes/errorHandler.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type Request, type Response, type NextFunction } from 'express'
import fs from 'node:fs/promises'
import config from 'config'
import pug from 'pug'

import * as utils from '../lib/utils'

export function errorHandler () {
  return async (error: unknown, req: Request, res: Response, next: NextFunction) => {
    if (res.headersSent) {
      next(error)
      return
    }

    if (req?.headers?.accept === 'application/json') {
      res.status(500).json({ error: JSON.parse(JSON.stringify(error)) })
      return
    }

    const template = await fs.readFile('views/errorPage.pug', { encoding: 'utf-8' })
    const title = `${config.get<string>('application.name')} (Express ${utils.version('express')})`
    const fn = pug.compile(template)
    res.status(500).send(fn({ title, error }))
  }
}


/* ===== FILE: ./routes/premiumReward.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import path from 'node:path'
import { type Request, type Response } from 'express'
import { challenges } from '../data/datacache'
import * as challengeUtils from '../lib/challengeUtils'

export function servePremiumContent () {
  return (req: Request, res: Response) => {
    challengeUtils.solveIf(challenges.premiumPaywallChallenge, () => { return true })
    res.sendFile(path.resolve('frontend/dist/frontend/assets/private/JuiceShop_Wallpaper_1920x1080_VR.jpg'))
  }
}


/* ===== FILE: ./routes/login.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */
import { type Request, type Response, type NextFunction } from 'express'
import config from 'config'

import * as challengeUtils from '../lib/challengeUtils'
import { challenges, users } from '../data/datacache'
import { BasketModel } from '../models/basket'
import * as security from '../lib/insecurity'
import { UserModel } from '../models/user'
import * as models from '../models/index'
import { type User } from '../data/types'
import * as utils from '../lib/utils'

// vuln-code-snippet start loginAdminChallenge loginBenderChallenge loginJimChallenge
export function login () {
  function afterLogin (user: { data: User, bid: number }, res: Response, next: NextFunction) {
    verifyPostLoginChallenges(user) // vuln-code-snippet hide-line
    BasketModel.findOrCreate({ where: { UserId: user.data.id } })
      .then(([basket]: [BasketModel, boolean]) => {
        const token = security.authorize(user)
        user.bid = basket.id // keep track of original basket
        security.authenticatedUsers.put(token, user)
        res.json({ authentication: { token, bid: basket.id, umail: user.data.email } })
      }).catch((error: Error) => {
        next(error)
      })
  }

  return (req: Request, res: Response, next: NextFunction) => {
    verifyPreLoginChallenges(req) // vuln-code-snippet hide-line
    models.sequelize.query(`SELECT * FROM Users WHERE email = '${req.body.email || ''}' AND password = '${security.hash(req.body.password || '')}' AND deletedAt IS NULL`, { model: UserModel, plain: true }) // vuln-code-snippet vuln-line loginAdminChallenge loginBenderChallenge loginJimChallenge
      .then((authenticatedUser) => { // vuln-code-snippet neutral-line loginAdminChallenge loginBenderChallenge loginJimChallenge
        const user = utils.queryResultToJson(authenticatedUser)
        if (user.data?.id && user.data.totpSecret !== '') {
          res.status(401).json({
            status: 'totp_token_required',
            data: {
              tmpToken: security.authorize({
                userId: user.data.id,
                type: 'password_valid_needs_second_factor_token'
              })
            }
          })
        } else if (user.data?.id) {
          // @ts-expect-error FIXME some properties missing in user - vuln-code-snippet hide-line
          afterLogin(user, res, next)
        } else {
          res.status(401).send(res.__('Invalid email or password.'))
        }
      }).catch((error: Error) => {
        next(error)
      })
  }
  // vuln-code-snippet end loginAdminChallenge loginBenderChallenge loginJimChallenge

  function verifyPreLoginChallenges (req: Request) {
    challengeUtils.solveIf(challenges.weakPasswordChallenge, () => { return req.body.email === 'admin@' + config.get<string>('application.domain') && req.body.password === 'admin123' })
    challengeUtils.solveIf(challenges.loginSupportChallenge, () => { return req.body.email === 'support@' + config.get<string>('application.domain') && req.body.password === 'J6aVjTgOpRs@?5l!Zkq2AYnCE@RF$P' })
    challengeUtils.solveIf(challenges.loginRapperChallenge, () => { return req.body.email === 'mc.safesearch@' + config.get<string>('application.domain') && req.body.password === 'Mr. N00dles' })
    challengeUtils.solveIf(challenges.loginAmyChallenge, () => { return req.body.email === 'amy@' + config.get<string>('application.domain') && req.body.password === 'K1f.....................' })
    challengeUtils.solveIf(challenges.dlpPasswordSprayingChallenge, () => { return req.body.email === 'J12934@' + config.get<string>('application.domain') && req.body.password === '0Y8rMnww$*9VFYE§59-!Fg1L6t&6lB' })
    challengeUtils.solveIf(challenges.oauthUserPasswordChallenge, () => { return req.body.email === 'bjoern.kimminich@gmail.com' && req.body.password === 'bW9jLmxpYW1nQGhjaW5pbW1pay5ucmVvamI=' })
    challengeUtils.solveIf(challenges.exposedCredentialsChallenge, () => { return req.body.email === 'testing@' + config.get<string>('application.domain') && req.body.password === 'IamUsedForTesting' })
  }

  function verifyPostLoginChallenges (user: { data: User }) {
    challengeUtils.solveIf(challenges.loginAdminChallenge, () => { return user.data.id === users.admin.id })
    challengeUtils.solveIf(challenges.loginJimChallenge, () => { return user.data.id === users.jim.id })
    challengeUtils.solveIf(challenges.loginBenderChallenge, () => { return user.data.id === users.bender.id })
    challengeUtils.solveIf(challenges.ghostLoginChallenge, () => { return user.data.id === users.chris.id })
    if (challengeUtils.notSolved(challenges.ephemeralAccountantChallenge) && user.data.email === 'acc0unt4nt@' + config.get<string>('application.domain') && user.data.role === 'accounting') {
      UserModel.count({ where: { email: 'acc0unt4nt@' + config.get<string>('application.domain') } }).then((count: number) => {
        if (count === 0) {
          challengeUtils.solve(challenges.ephemeralAccountantChallenge)
        }
      }).catch(() => {
        throw new Error('Unable to verify challenges! Try again')
      })
    }
  }
}


/* ===== FILE: ./routes/verify.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type Request, type Response, type NextFunction } from 'express'
import { Op } from 'sequelize'
import jwt from 'jsonwebtoken'
import config from 'config'
import jws from 'jws'

import { products, challenges, retrieveBlueprintChallengeFile } from '../data/datacache'
import type { Product as ProductConfig } from '../lib/config.types'
import { type Challenge, type Product } from '../data/types'
import * as challengeUtils from '../lib/challengeUtils'
import { ComplaintModel } from '../models/complaint'
import { FeedbackModel } from '../models/feedback'
import * as security from '../lib/insecurity'
import * as utils from '../lib/utils'

export const emptyUserRegistration = () => (req: Request, res: Response, next: NextFunction) => {
  challengeUtils.solveIf(challenges.emptyUserRegistration, () => {
    return req.body && req.body.email === '' && req.body.password === ''
  })
  next()
}

export const forgedFeedbackChallenge = () => (req: Request, res: Response, next: NextFunction) => {
  challengeUtils.solveIf(challenges.forgedFeedbackChallenge, () => {
    const user = security.authenticatedUsers.from(req)
    const userId = user?.data ? user.data.id : undefined
    return req.body?.UserId && req.body.UserId != userId // eslint-disable-line eqeqeq
  })
  next()
}

export const captchaBypassChallenge = () => (req: Request, res: Response, next: NextFunction) => {
  if (challengeUtils.notSolved(challenges.captchaBypassChallenge)) {
    if (req.app.locals.captchaReqId >= 10) {
      if ((new Date().getTime() - req.app.locals.captchaBypassReqTimes[req.app.locals.captchaReqId - 10]) <= 20000) {
        challengeUtils.solve(challenges.captchaBypassChallenge)
      }
    }
    req.app.locals.captchaBypassReqTimes[req.app.locals.captchaReqId - 1] = new Date().getTime()
    req.app.locals.captchaReqId++
  }
  next()
}

export const registerAdminChallenge = () => (req: Request, res: Response, next: NextFunction) => {
  challengeUtils.solveIf(challenges.registerAdminChallenge, () => {
    return req.body && req.body.role === security.roles.admin
  })
  next()
}

export const passwordRepeatChallenge = () => (req: Request, res: Response, next: NextFunction) => {
  challengeUtils.solveIf(challenges.passwordRepeatChallenge, () => { return req.body && req.body.passwordRepeat !== req.body.password })
  next()
}

export const accessControlChallenges = () => ({ url }: Request, res: Response, next: NextFunction) => {
  challengeUtils.solveIf(challenges.scoreBoardChallenge, () => { return utils.endsWith(url, '/1px.png') })
  challengeUtils.solveIf(challenges.web3SandboxChallenge, () => { return utils.endsWith(url, '/11px.png') })
  challengeUtils.solveIf(challenges.adminSectionChallenge, () => { return utils.endsWith(url, '/19px.png') })
  challengeUtils.solveIf(challenges.tokenSaleChallenge, () => { return utils.endsWith(url, '/56px.png') })
  challengeUtils.solveIf(challenges.privacyPolicyChallenge, () => { return utils.endsWith(url, '/81px.png') })
  challengeUtils.solveIf(challenges.extraLanguageChallenge, () => { return utils.endsWith(url, '/tlh_AA.json') })
  challengeUtils.solveIf(challenges.retrieveBlueprintChallenge, () => { return utils.endsWith(url, retrieveBlueprintChallengeFile ?? undefined) })
  challengeUtils.solveIf(challenges.securityPolicyChallenge, () => { return utils.endsWith(url, '/security.txt') })
  challengeUtils.solveIf(challenges.missingEncodingChallenge, () => { return utils.endsWith(url.toLowerCase(), '%e1%93%9a%e1%98%8f%e1%97%a2-%23zatschi-%23whoneedsfourlegs-1572600969477.jpg') })
  challengeUtils.solveIf(challenges.accessLogDisclosureChallenge, () => { return url.match(/access\.log(0-9-)*/) })
  next()
}

export const errorHandlingChallenge = () => (err: unknown, req: Request, { statusCode }: Response, next: NextFunction) => {
  challengeUtils.solveIf(challenges.errorHandlingChallenge, () => { return err && (statusCode === 200 || statusCode > 401) })
  next(err)
}

export const jwtChallenges = () => (req: Request, res: Response, next: NextFunction) => {
  if (challengeUtils.notSolved(challenges.jwtUnsignedChallenge)) {
    jwtChallenge(challenges.jwtUnsignedChallenge, req, 'none', /jwtn3d@/)
  }
  if (utils.isChallengeEnabled(challenges.jwtForgedChallenge) && challengeUtils.notSolved(challenges.jwtForgedChallenge)) {
    jwtChallenge(challenges.jwtForgedChallenge, req, 'HS256', /rsa_lord@/)
  }
  next()
}

export const serverSideChallenges = () => (req: Request, res: Response, next: NextFunction) => {
  if (req.query.key === 'tRy_H4rd3r_n0thIng_iS_Imp0ssibl3') {
    if (challengeUtils.notSolved(challenges.sstiChallenge) && req.app.locals.abused_ssti_bug === true) {
      challengeUtils.solve(challenges.sstiChallenge)
      res.status(204).send()
      return
    }

    if (challengeUtils.notSolved(challenges.ssrfChallenge) && req.app.locals.abused_ssrf_bug === true) {
      challengeUtils.solve(challenges.ssrfChallenge)
      res.status(204).send()
      return
    }
  }
  next()
}

function jwtChallenge (challenge: Challenge, req: Request, algorithm: string, email: string | RegExp) {
  const token = utils.jwtFrom(req)
  if (token) {
    const decoded = jws.decode(token) ? jwt.decode(token) : null

    if (decoded === null || typeof decoded === 'string') {
      return
    }

    jwt.verify(token, security.publicKey, (err: jwt.VerifyErrors | null) => {
      if (err === null) {
        challengeUtils.solveIf(challenge, () => {
          return hasAlgorithm(token, algorithm) && hasEmail(decoded as { data: { email: string } }, email)
        })
      }
    })
  }
}

function hasAlgorithm (token: string, algorithm: string) {
  const header = JSON.parse(Buffer.from(token.split('.')[0], 'base64').toString())
  return token && header && header.alg === algorithm
}

function hasEmail (token: { data: { email: string } }, email: string | RegExp) {
  return token?.data?.email?.match(email)
}

export const databaseRelatedChallenges = () => (req: Request, res: Response, next: NextFunction) => {
  if (challengeUtils.notSolved(challenges.changeProductChallenge) && products.osaft) {
    changeProductChallenge(products.osaft)
  }
  if (challengeUtils.notSolved(challenges.feedbackChallenge)) {
    feedbackChallenge()
  }
  if (challengeUtils.notSolved(challenges.knownVulnerableComponentChallenge)) {
    knownVulnerableComponentChallenge()
  }
  if (challengeUtils.notSolved(challenges.weirdCryptoChallenge)) {
    weirdCryptoChallenge()
  }
  if (challengeUtils.notSolved(challenges.typosquattingNpmChallenge)) {
    typosquattingNpmChallenge()
  }
  if (challengeUtils.notSolved(challenges.typosquattingAngularChallenge)) {
    typosquattingAngularChallenge()
  }
  if (challengeUtils.notSolved(challenges.hiddenImageChallenge)) {
    hiddenImageChallenge()
  }
  if (challengeUtils.notSolved(challenges.supplyChainAttackChallenge)) {
    supplyChainAttackChallenge()
  }
  if (challengeUtils.notSolved(challenges.dlpPastebinDataLeakChallenge)) {
    dlpPastebinDataLeakChallenge()
  }
  if (challengeUtils.notSolved(challenges.csafChallenge)) {
    csafChallenge()
  }
  if (challengeUtils.notSolved(challenges.leakedApiKeyChallenge)) {
    leakedApiKeyChallenge()
  }
  next()
}

function changeProductChallenge (osaft: Product) {
  let urlForProductTamperingChallenge: string | null = null
  void osaft.reload().then(() => {
    for (const product of config.get<ProductConfig[]>('products')) {
      if (product.urlForProductTamperingChallenge !== undefined) {
        urlForProductTamperingChallenge = product.urlForProductTamperingChallenge
        break
      }
    }
    if (urlForProductTamperingChallenge) {
      if (!utils.contains(osaft.description, `${urlForProductTamperingChallenge}`)) {
        if (utils.contains(osaft.description, `<a href="${config.get<string>('challenges.overwriteUrlForProductTamperingChallenge')}" target="_blank">`)) {
          challengeUtils.solve(challenges.changeProductChallenge)
        }
      }
    }
  })
}

function feedbackChallenge () {
  FeedbackModel.findAndCountAll({ where: { rating: 5 } }).then(({ count }: { count: number }) => {
    if (count === 0) {
      challengeUtils.solve(challenges.feedbackChallenge)
    }
  }).catch(() => {
    throw new Error('Unable to retrieve feedback details. Please try again')
  })
}

function knownVulnerableComponentChallenge () {
  FeedbackModel.findAndCountAll({
    where: {
      comment: {
        [Op.or]: knownVulnerableComponents()
      }
    }
  }).then(({ count }: { count: number }) => {
    if (count > 0) {
      challengeUtils.solve(challenges.knownVulnerableComponentChallenge)
    }
  }).catch(() => {
    throw new Error('Unable to get data for known vulnerabilities. Please try again')
  })
  ComplaintModel.findAndCountAll({
    where: {
      message: {
        [Op.or]: knownVulnerableComponents()
      }
    }
  }).then(({ count }: { count: number }) => {
    if (count > 0) {
      challengeUtils.solve(challenges.knownVulnerableComponentChallenge)
    }
  }).catch(() => {
    throw new Error('Unable to get data for known vulnerabilities. Please try again')
  })
}

function knownVulnerableComponents () {
  return [
    {
      [Op.and]: [
        { [Op.like]: '%sanitize-html%' },
        { [Op.like]: '%1.4.2%' }
      ]
    },
    {
      [Op.and]: [
        { [Op.like]: '%express-jwt%' },
        { [Op.like]: '%0.1.3%' }
      ]
    }
  ]
}

function weirdCryptoChallenge () {
  FeedbackModel.findAndCountAll({
    where: {
      comment: {
        [Op.or]: weirdCryptos()
      }
    }
  }).then(({ count }: { count: number }) => {
    if (count > 0) {
      challengeUtils.solve(challenges.weirdCryptoChallenge)
    }
  }).catch(() => {
    throw new Error('Unable to get data for known vulnerabilities. Please try again')
  })
  ComplaintModel.findAndCountAll({
    where: {
      message: {
        [Op.or]: weirdCryptos()
      }
    }
  }).then(({ count }: { count: number }) => {
    if (count > 0) {
      challengeUtils.solve(challenges.weirdCryptoChallenge)
    }
  }).catch(() => {
    throw new Error('Unable to get data for known vulnerabilities. Please try again')
  })
}

function weirdCryptos () {
  return [
    { [Op.like]: '%z85%' },
    { [Op.like]: '%base85%' },
    { [Op.like]: '%hashids%' },
    { [Op.like]: '%md5%' },
    { [Op.like]: '%base64%' }
  ]
}

function typosquattingNpmChallenge () {
  FeedbackModel.findAndCountAll({ where: { comment: { [Op.like]: '%epilogue-js%' } } }
  ).then(({ count }: { count: number }) => {
    if (count > 0) {
      challengeUtils.solve(challenges.typosquattingNpmChallenge)
    }
  }).catch(() => {
    throw new Error('Unable to get data for known vulnerabilities. Please try again')
  })
  ComplaintModel.findAndCountAll({ where: { message: { [Op.like]: '%epilogue-js%' } } }
  ).then(({ count }: { count: number }) => {
    if (count > 0) {
      challengeUtils.solve(challenges.typosquattingNpmChallenge)
    }
  }).catch(() => {
    throw new Error('Unable to get data for known vulnerabilities. Please try again')
  })
}

function typosquattingAngularChallenge () {
  FeedbackModel.findAndCountAll({ where: { comment: { [Op.like]: '%ngy-cookie%' } } }
  ).then(({ count }: { count: number }) => {
    if (count > 0) {
      challengeUtils.solve(challenges.typosquattingAngularChallenge)
    }
  }).catch(() => {
    throw new Error('Unable to get data for known vulnerabilities. Please try again')
  })
  ComplaintModel.findAndCountAll({ where: { message: { [Op.like]: '%ngy-cookie%' } } }
  ).then(({ count }: { count: number }) => {
    if (count > 0) {
      challengeUtils.solve(challenges.typosquattingAngularChallenge)
    }
  }).catch(() => {
    throw new Error('Unable to get data for known vulnerabilities. Please try again')
  })
}

function hiddenImageChallenge () {
  FeedbackModel.findAndCountAll({ where: { comment: { [Op.like]: '%pickle rick%' } } }
  ).then(({ count }: { count: number }) => {
    if (count > 0) {
      challengeUtils.solve(challenges.hiddenImageChallenge)
    }
  }).catch(() => {
    throw new Error('Unable to get data for known vulnerabilities. Please try again')
  })
  ComplaintModel.findAndCountAll({ where: { message: { [Op.like]: '%pickle rick%' } } }
  ).then(({ count }: { count: number }) => {
    if (count > 0) {
      challengeUtils.solve(challenges.hiddenImageChallenge)
    }
  }).catch(() => {
    throw new Error('Unable to get data for known vulnerabilities. Please try again')
  })
}

function supplyChainAttackChallenge () {
  FeedbackModel.findAndCountAll({ where: { comment: { [Op.or]: eslintScopeVulnIds() } } }
  ).then(({ count }: { count: number }) => {
    if (count > 0) {
      challengeUtils.solve(challenges.supplyChainAttackChallenge)
    }
  }).catch(() => {
    throw new Error('Unable to get data for known vulnerabilities. Please try again')
  })
  ComplaintModel.findAndCountAll({ where: { message: { [Op.or]: eslintScopeVulnIds() } } }
  ).then(({ count }: { count: number }) => {
    if (count > 0) {
      challengeUtils.solve(challenges.supplyChainAttackChallenge)
    }
  }).catch(() => {
    throw new Error('Unable to get data for known vulnerabilities. Please try again')
  })
}

function eslintScopeVulnIds () {
  return [
    { [Op.like]: '%eslint-scope/issues/39%' },
    { [Op.like]: '%npm:eslint-scope:20180712%' }
  ]
}

function dlpPastebinDataLeakChallenge () {
  FeedbackModel.findAndCountAll({
    where: {
      comment: { [Op.and]: dangerousIngredients() }
    }
  }).then(({ count }: { count: number }) => {
    if (count > 0) {
      challengeUtils.solve(challenges.dlpPastebinDataLeakChallenge)
    }
  }).catch(() => {
    throw new Error('Unable to get data for known vulnerabilities. Please try again')
  })
  ComplaintModel.findAndCountAll({
    where: {
      message: { [Op.and]: dangerousIngredients() }
    }
  }).then(({ count }: { count: number }) => {
    if (count > 0) {
      challengeUtils.solve(challenges.dlpPastebinDataLeakChallenge)
    }
  }).catch(() => {
    throw new Error('Unable to get data for known vulnerabilities. Please try again')
  })
}

function csafChallenge () {
  FeedbackModel.findAndCountAll({ where: { comment: { [Op.like]: '%' + config.get<string>('challenges.csafHashValue') + '%' } } }
  ).then(({ count }: { count: number }) => {
    if (count > 0) {
      challengeUtils.solve(challenges.csafChallenge)
    }
  }).catch(() => {
    throw new Error('Unable to get data for known vulnerabilities. Please try again')
  })
  ComplaintModel.findAndCountAll({ where: { message: { [Op.like]: '%' + config.get<string>('challenges.csafHashValue') + '%' } } }
  ).then(({ count }: { count: number }) => {
    if (count > 0) {
      challengeUtils.solve(challenges.csafChallenge)
    }
  }).catch(() => {
    throw new Error('Unable to get data for known vulnerabilities. Please try again')
  })
}

function leakedApiKeyChallenge () {
  FeedbackModel.findAndCountAll({ where: { comment: { [Op.like]: '%6PPi37DBxP4lDwlriuaxP15HaDJpsUXY5TspVmie%' } } }
  ).then(({ count }: { count: number }) => {
    if (count > 0) {
      challengeUtils.solve(challenges.leakedApiKeyChallenge)
    }
  }).catch(() => {
    throw new Error('Unable to get data for known vulnerabilities. Please try again')
  })
  ComplaintModel.findAndCountAll({ where: { message: { [Op.like]: '%6PPi37DBxP4lDwlriuaxP15HaDJpsUXY5TspVmie%' } } }
  ).then(({ count }: { count: number }) => {
    if (count > 0) {
      challengeUtils.solve(challenges.leakedApiKeyChallenge)
    }
  }).catch(() => {
    throw new Error('Unable to get data for known vulnerabilities. Please try again')
  })
}

function dangerousIngredients () {
  return config.get<ProductConfig[]>('products')
    .flatMap((product) => product.keywordsForPastebinDataLeakChallenge)
    .filter(Boolean)
    .map((keyword) => {
      return { [Op.like]: `%${keyword}%` }
    })
}


/* ===== FILE: ./routes/resetPassword.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import config from 'config'
import { type Request, type Response, type NextFunction } from 'express'

import type { Memory as MemoryConfig } from '../lib/config.types'
import { SecurityAnswerModel } from '../models/securityAnswer'
import * as challengeUtils from '../lib/challengeUtils'
import { challenges, users } from '../data/datacache'
import * as security from '../lib/insecurity'
import { UserModel } from '../models/user'

export function resetPassword () {
  return ({ body, connection }: Request, res: Response, next: NextFunction) => {
    const email = body.email
    const answer = body.answer
    const newPassword = body.new
    const repeatPassword = body.repeat
    if (!email || !answer) {
      next(new Error('Blocked illegal activity by ' + connection.remoteAddress))
    } else if (!newPassword || newPassword === 'undefined') {
      res.status(401).send(res.__('Password cannot be empty.'))
    } else if (newPassword !== repeatPassword) {
      res.status(401).send(res.__('New and repeated password do not match.'))
    } else {
      SecurityAnswerModel.findOne({
        include: [{
          model: UserModel,
          where: { email }
        }]
      }).then((data: SecurityAnswerModel | null) => {
        if ((data != null) && security.hmac(answer) === data.answer) {
          UserModel.findByPk(data.UserId).then((user: UserModel | null) => {
            user?.update({ password: newPassword }).then((user: UserModel) => {
              verifySecurityAnswerChallenges(user, answer)
              res.json({ user })
            }).catch((error: unknown) => {
              next(error)
            })
          }).catch((error: unknown) => {
            next(error)
          })
        } else {
          res.status(401).send(res.__('Wrong answer to security question.'))
        }
      }).catch((error: unknown) => {
        next(error)
      })
    }
  }
}

function verifySecurityAnswerChallenges (user: UserModel, answer: string) {
  challengeUtils.solveIf(challenges.resetPasswordJimChallenge, () => { return user.id === users.jim.id && answer === 'Samuel' })
  challengeUtils.solveIf(challenges.resetPasswordBenderChallenge, () => { return user.id === users.bender.id && answer === 'Stop\'n\'Drop' })
  challengeUtils.solveIf(challenges.resetPasswordBjoernChallenge, () => { return user.id === users.bjoern.id && answer === 'West-2082' })
  challengeUtils.solveIf(challenges.resetPasswordMortyChallenge, () => { return user.id === users.morty.id && answer === '5N0wb41L' })
  challengeUtils.solveIf(challenges.resetPasswordBjoernOwaspChallenge, () => { return user.id === users.bjoernOwasp.id && answer === 'Zaya' })
  challengeUtils.solveIf(challenges.resetPasswordUvoginChallenge, () => { return user.id === users.uvogin.id && answer === 'Silence of the Lambs' })
  challengeUtils.solveIf(challenges.geoStalkingMetaChallenge, () => {
    const securityAnswer = ((() => {
      const memories = config.get<MemoryConfig[]>('memories')
      for (let i = 0; i < memories.length; i++) {
        if (memories[i].geoStalkingMetaSecurityAnswer) {
          return memories[i].geoStalkingMetaSecurityAnswer
        }
      }
    })())
    return user.id === users.john.id && answer === securityAnswer
  })
  challengeUtils.solveIf(challenges.geoStalkingVisualChallenge, () => {
    const securityAnswer = ((() => {
      const memories = config.get<MemoryConfig[]>('memories')
      for (let i = 0; i < memories.length; i++) {
        if (memories[i].geoStalkingVisualSecurityAnswer) {
          return memories[i].geoStalkingVisualSecurityAnswer
        }
      }
    })())
    return user.id === users.emma.id && answer === securityAnswer
  })
}


/* ===== FILE: ./routes/nftMint.ts ===== */

import { type Request, type Response } from 'express'
import { WebSocketProvider, Contract } from 'ethers'

import * as challengeUtils from '../lib/challengeUtils'
import { nftABI } from '../data/static/contractABIs'
import { challenges } from '../data/datacache'
import * as utils from '../lib/utils'

const nftAddress = '0x41427790c94E7a592B17ad694eD9c06A02bb9C39'
const addressesMinted = new Set()
let isEventListenerCreated = false

export function nftMintListener () {
  return async (req: Request, res: Response) => {
    try {
      const provider = new WebSocketProvider('wss://eth-sepolia.g.alchemy.com/v2/FZDapFZSs1l6yhHW4VnQqsi18qSd-3GJ')
      const contract = new Contract(nftAddress, nftABI, provider)
      if (!isEventListenerCreated) {
        void contract.on('NFTMinted', (minter: string) => {
          if (!addressesMinted.has(minter)) {
            addressesMinted.add(minter)
          }
        })
        isEventListenerCreated = true
      }
      res.status(200).json({ success: true, message: 'Event Listener Created' })
    } catch (error) {
      res.status(500).json(utils.getErrorMessage(error))
    }
  }
}

export function walletNFTVerify () {
  return (req: Request, res: Response) => {
    try {
      const metamaskAddress = req.body.walletAddress
      if (addressesMinted.has(metamaskAddress)) {
        addressesMinted.delete(metamaskAddress)
        challengeUtils.solveIf(challenges.nftMintChallenge, () => true)
        res.status(200).json({ success: true, message: 'Challenge successfully solved', status: challenges.nftMintChallenge })
      } else {
        res.status(200).json({ success: false, message: 'Wallet did not mint the NFT', status: challenges.nftMintChallenge })
      }
    } catch (error) {
      res.status(500).json(utils.getErrorMessage(error))
    }
  }
}


/* ===== FILE: ./routes/chatbot.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import fs from 'node:fs/promises'
import { type Request, type Response, type NextFunction } from 'express'
import { type User } from '../data/types'
import { UserModel } from '../models/user'
import jwt, { type JwtPayload, type VerifyErrors } from 'jsonwebtoken'
import * as challengeUtils from '../lib/challengeUtils'
import logger from '../lib/logger'
import config from 'config'
import download from 'download'
import * as utils from '../lib/utils'
import { isString } from 'lodash'
import { Bot } from 'juicy-chat-bot'
import validateChatBot from '../lib/startup/validateChatBot'
import * as security from '../lib/insecurity'
import * as botUtils from '../lib/botUtils'
import { challenges } from '../data/datacache'

let trainingFile = config.get<string>('application.chatBot.trainingData')
let testCommand: string
export let bot: Bot | null = null

export async function initializeChatbot () {
  if (utils.isUrl(trainingFile)) {
    const file = utils.extractFilename(trainingFile)
    const data = await download(trainingFile)
    await fs.writeFile('data/chatbot/' + file, data)
  }

  await fs.copyFile(
    'data/static/botDefaultTrainingData.json',
    'data/chatbot/botDefaultTrainingData.json'
  )

  trainingFile = utils.extractFilename(trainingFile)
  const trainingSet = await fs.readFile(`data/chatbot/${trainingFile}`, 'utf8')
  validateChatBot(JSON.parse(trainingSet))

  testCommand = JSON.parse(trainingSet).data[0].utterances[0]
  bot = new Bot(config.get('application.chatBot.name'), config.get('application.chatBot.greeting'), trainingSet, config.get('application.chatBot.defaultResponse'))
  return bot.train()
}

void initializeChatbot()

async function processQuery (user: User, req: Request, res: Response, next: NextFunction) {
  if (bot == null) {
    res.status(503).send()
    return
  }
  const username = user.username
  if (!username) {
    res.status(200).json({
      action: 'namequery',
      body: 'I\'m sorry I didn\'t get your name. What shall I call you?'
    })
    return
  }

  if (!bot.factory.run(`currentUser('${user.id}')`)) {
    try {
      bot.addUser(`${user.id}`, username)
      res.status(200).json({
        action: 'response',
        body: bot.greet(`${user.id}`)
      })
    } catch (err) {
      next(new Error('Blocked illegal activity by ' + req.socket.remoteAddress))
    }
    return
  }

  if (bot.factory.run(`currentUser('${user.id}')`) !== username) {
    bot.addUser(`${user.id}`, username)
    try {
      bot.addUser(`${user.id}`, username)
    } catch (err) {
      next(new Error('Blocked illegal activity by ' + req.socket.remoteAddress))
      return
    }
  }

  if (!req.body.query) {
    res.status(200).json({
      action: 'response',
      body: bot.greet(`${user.id}`)
    })
    return
  }

  try {
    const response = await bot.respond(req.body.query, `${user.id}`)
    if (response.action === 'function') {
      // @ts-expect-error FIXME unclean usage of any type as index
      if (response.handler && botUtils[response.handler]) {
        // @ts-expect-error FIXME unclean usage of any type as index
        res.status(200).json(await botUtils[response.handler](req.body.query, user))
      } else {
        res.status(200).json({
          action: 'response',
          body: config.get('application.chatBot.defaultResponse')
        })
      }
    } else {
      res.status(200).json(response)
    }
  } catch (err) {
    try {
      await bot.respond(testCommand, `${user.id}`)
      res.status(200).json({
        action: 'response',
        body: config.get('application.chatBot.defaultResponse')
      })
    } catch (err) {
      challengeUtils.solveIf(challenges.killChatbotChallenge, () => { return true })
      res.status(200).json({
        action: 'response',
        body: `Remember to stay hydrated while I try to recover from "${utils.getErrorMessage(err)}"...`
      })
    }
  }
}

async function setUserName (user: User, req: Request, res: Response) {
  if (bot == null) {
    return
  }
  try {
    const userModel = await UserModel.findByPk(user.id)
    if (userModel == null) {
      res.status(401).json({
        status: 'error',
        error: 'Unknown user'
      })
      return
    }
    const updatedUser = await userModel.update({ username: req.body.query })
    const updatedUserResponse = utils.queryResultToJson(updatedUser)
    const updatedToken = security.authorize(updatedUserResponse)
    security.authenticatedUsers.put(updatedToken, updatedUserResponse)
    bot.addUser(`${updatedUser.id}`, req.body.query)
    res.status(200).json({
      action: 'response',
      body: bot.greet(`${updatedUser.id}`),
      token: updatedToken
    })
  } catch (err) {
    logger.error(`Could not set username: ${utils.getErrorMessage(err)}`)
    res.status(500).send()
  }
}

export const status = function status () {
  return async (req: Request, res: Response, next: NextFunction) => {
    if (bot == null) {
      res.status(200).json({
        status: false,
        body: `${config.get<string>('application.chatBot.name')} isn't ready at the moment, please wait while I set things up`
      })
      return
    }
    const token = req.cookies.token || utils.jwtFrom(req)
    if (!token) {
      res.status(200).json({
        status: bot.training.state,
        body: `Hi, I can't recognize you. Sign in to talk to ${config.get<string>('application.chatBot.name')}`
      })
      return
    }

    const user = await getUserFromJwt(token)
    if (user == null) {
      res.status(401).json({
        error: 'Unauthenticated user'
      })
      return
    }

    const username = user.username

    if (!username) {
      res.status(200).json({
        action: 'namequery',
        body: 'I\'m sorry I didn\'t get your name. What shall I call you?'
      })
      return
    }

    try {
      bot.addUser(`${user.id}`, username)
      res.status(200).json({
        status: bot.training.state,
        body: bot.training.state ? bot.greet(`${user.id}`) : `${config.get<string>('application.chatBot.name')} isn't ready at the moment, please wait while I set things up`
      })
    } catch (err) {
      next(new Error('Blocked illegal activity by ' + req.socket.remoteAddress))
    }
  }
}

export function process () {
  return async (req: Request, res: Response, next: NextFunction) => {
    if (bot == null) {
      res.status(200).json({
        action: 'response',
        body: `${config.get<string>('application.chatBot.name')} isn't ready at the moment, please wait while I set things up`
      })
    }
    const token = req.cookies.token || utils.jwtFrom(req)
    if (!token) {
      res.status(400).json({
        error: 'Unauthenticated user'
      })
      return
    }

    const user = await getUserFromJwt(token)
    if (user == null) {
      res.status(401).json({
        error: 'Unauthenticated user'
      })
      return
    }

    if (req.body.action === 'query') {
      await processQuery(user, req, res, next)
    } else if (req.body.action === 'setname') {
      await setUserName(user, req, res)
    }
  }
}

async function getUserFromJwt (token: string): Promise<User | null> {
  return await new Promise((resolve) => {
    jwt.verify(token, security.publicKey, (err: VerifyErrors | null, decoded: JwtPayload | string | undefined) => {
      if (err !== null || !decoded || isString(decoded)) {
        resolve(null)
      } else {
        resolve(decoded.data)
      }
    })
  })
}


/* ===== FILE: ./routes/search.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type Request, type Response, type NextFunction } from 'express'

import * as utils from '../lib/utils'
import * as models from '../models/index'
import { UserModel } from '../models/user'
import { challenges } from '../data/datacache'
import * as challengeUtils from '../lib/challengeUtils'

class ErrorWithParent extends Error {
  parent: Error | undefined
}

// vuln-code-snippet start unionSqlInjectionChallenge dbSchemaChallenge
export function searchProducts () {
  return (req: Request, res: Response, next: NextFunction) => {
    let criteria: any = req.query.q === 'undefined' ? '' : req.query.q ?? ''
    criteria = (criteria.length <= 200) ? criteria : criteria.substring(0, 200)
    models.sequelize.query(`SELECT * FROM Products WHERE ((name LIKE '%${criteria}%' OR description LIKE '%${criteria}%') AND deletedAt IS NULL) ORDER BY name`) // vuln-code-snippet vuln-line unionSqlInjectionChallenge dbSchemaChallenge
      .then(([products]: any) => {
        const dataString = JSON.stringify(products)
        if (challengeUtils.notSolved(challenges.unionSqlInjectionChallenge)) { // vuln-code-snippet hide-start
          let solved = true
          UserModel.findAll().then(data => {
            const users = utils.queryResultToJson(data)
            if (users.data?.length) {
              for (let i = 0; i < users.data.length; i++) {
                solved = solved && utils.containsOrEscaped(dataString, users.data[i].email) && utils.contains(dataString, users.data[i].password)
                if (!solved) {
                  break
                }
              }
              if (solved) {
                challengeUtils.solve(challenges.unionSqlInjectionChallenge)
              }
            }
          }).catch((error: Error) => {
            next(error)
          })
        }
        if (challengeUtils.notSolved(challenges.dbSchemaChallenge)) {
          let solved = true
          void models.sequelize.query('SELECT sql FROM sqlite_master').then(([data]: any) => {
            const tableDefinitions = utils.queryResultToJson(data)
            if (tableDefinitions.data?.length) {
              for (let i = 0; i < tableDefinitions.data.length; i++) {
                if (tableDefinitions.data[i].sql) {
                  solved = solved && utils.containsOrEscaped(dataString, tableDefinitions.data[i].sql)
                  if (!solved) {
                    break
                  }
                }
              }
              if (solved) {
                challengeUtils.solve(challenges.dbSchemaChallenge)
              }
            }
          })
        } // vuln-code-snippet hide-end
        for (let i = 0; i < products.length; i++) {
          products[i].name = req.__(products[i].name)
          products[i].description = req.__(products[i].description)
        }
        res.json(utils.queryResultToJson(products))
      }).catch((error: ErrorWithParent) => {
        next(error.parent)
      })
  }
}
// vuln-code-snippet end unionSqlInjectionChallenge dbSchemaChallenge


/* ===== FILE: ./routes/easterEgg.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import path from 'node:path'
import { type Request, type Response } from 'express'
import { challenges } from '../data/datacache'
import * as challengeUtils from '../lib/challengeUtils'

export function serveEasterEgg () {
  return (req: Request, res: Response) => {
    challengeUtils.solveIf(challenges.easterEggLevelTwoChallenge, () => { return true })
    res.sendFile(path.resolve('frontend/dist/frontend/assets/private/threejs-demo.html'))
  }
}


/* ===== FILE: ./routes/changePassword.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type Request, type Response, type NextFunction } from 'express'
import * as challengeUtils from '../lib/challengeUtils'
import { challenges } from '../data/datacache'
import { UserModel } from '../models/user'
import * as security from '../lib/insecurity'

export function changePassword () {
  return async ({ query, headers, connection }: Request, res: Response, next: NextFunction) => {
    const currentPassword = query.current as string
    const newPassword = query.new as string
    const newPasswordInString = newPassword?.toString()
    const repeatPassword = query.repeat

    if (!newPassword || newPassword === 'undefined') {
      res.status(401).send(res.__('Password cannot be empty.'))
      return
    } else if (newPassword !== repeatPassword) {
      res.status(401).send(res.__('New and repeated password do not match.'))
      return
    }

    const token = headers.authorization ? headers.authorization.substr('Bearer='.length) : null
    if (token === null) {
      next(new Error('Blocked illegal activity by ' + connection.remoteAddress))
      return
    }

    const loggedInUser = security.authenticatedUsers.get(token)
    if (!loggedInUser) {
      next(new Error('Blocked illegal activity by ' + connection.remoteAddress))
      return
    }

    if (currentPassword && security.hash(currentPassword) !== loggedInUser.data.password) {
      res.status(401).send(res.__('Current password is not correct.'))
      return
    }

    try {
      const user = await UserModel.findByPk(loggedInUser.data.id)
      if (!user) {
        res.status(404).send(res.__('User not found.'))
        return
      }

      await user.update({ password: newPasswordInString })
      challengeUtils.solveIf(
        challenges.changePasswordBenderChallenge,
        () => user.id === 3 && !currentPassword && user.password === security.hash('slurmCl4ssic')
      )
      res.json({ user })
    } catch (error) {
      next(error)
    }
  }
}


/* ===== FILE: ./routes/profileImageUrlUpload.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import fs from 'node:fs'
import { Readable } from 'node:stream'
import { finished } from 'node:stream/promises'
import { type Request, type Response, type NextFunction } from 'express'

import * as security from '../lib/insecurity'
import { UserModel } from '../models/user'
import * as utils from '../lib/utils'
import logger from '../lib/logger'

export function profileImageUrlUpload () {
  return async (req: Request, res: Response, next: NextFunction) => {
    if (req.body.imageUrl !== undefined) {
      const url = req.body.imageUrl
      if (url.match(/(.)*solve\/challenges\/server-side(.)*/) !== null) req.app.locals.abused_ssrf_bug = true
      const loggedInUser = security.authenticatedUsers.get(req.cookies.token)
      if (loggedInUser) {
        try {
          const response = await fetch(url)
          if (!response.ok || !response.body) {
            throw new Error('url returned a non-OK status code or an empty body')
          }
          const ext = ['jpg', 'jpeg', 'png', 'svg', 'gif'].includes(url.split('.').slice(-1)[0].toLowerCase()) ? url.split('.').slice(-1)[0].toLowerCase() : 'jpg'
          const fileStream = fs.createWriteStream(`frontend/dist/frontend/assets/public/images/uploads/${loggedInUser.data.id}.${ext}`, { flags: 'w' })
          await finished(Readable.fromWeb(response.body as any).pipe(fileStream))
          await UserModel.findByPk(loggedInUser.data.id).then(async (user: UserModel | null) => { return await user?.update({ profileImage: `/assets/public/images/uploads/${loggedInUser.data.id}.${ext}` }) }).catch((error: Error) => { next(error) })
        } catch (error) {
          try {
            const user = await UserModel.findByPk(loggedInUser.data.id)
            await user?.update({ profileImage: url })
            logger.warn(`Error retrieving user profile image: ${utils.getErrorMessage(error)}; using image link directly`)
          } catch (error) {
            next(error)
            return
          }
        }
      } else {
        next(new Error('Blocked illegal activity by ' + req.socket.remoteAddress))
        return
      }
    }
    res.location(process.env.BASE_PATH + '/profile')
    res.redirect(process.env.BASE_PATH + '/profile')
  }
}


/* ===== FILE: ./routes/saveLoginIp.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type Request, type Response, type NextFunction } from 'express'

import * as challengeUtils from '../lib/challengeUtils'
import { challenges } from '../data/datacache'
import * as security from '../lib/insecurity'
import { UserModel } from '../models/user'
import * as utils from '../lib/utils'

export function saveLoginIp () {
  return (req: Request, res: Response, next: NextFunction) => {
    const loggedInUser = security.authenticatedUsers.from(req)
    if (loggedInUser !== undefined) {
      let lastLoginIp = req.headers['true-client-ip']
      if (Array.isArray(lastLoginIp)) {
        lastLoginIp = lastLoginIp[0]
      }
      if (utils.isChallengeEnabled(challenges.httpHeaderXssChallenge)) {
        challengeUtils.solveIf(challenges.httpHeaderXssChallenge, () => { return lastLoginIp === '<iframe src="javascript:alert(`xss`)">' })
      } else {
        lastLoginIp = security.sanitizeSecure(lastLoginIp ?? '')
      }
      if (lastLoginIp === undefined) {
        lastLoginIp = utils.toSimpleIpAddress(req.socket.remoteAddress ?? '')
      }
      UserModel.findByPk(loggedInUser.data.id).then((user: UserModel | null) => {
        user?.update({ lastLoginIp: lastLoginIp?.toString() }).then((user: UserModel) => {
          res.json(user)
        }).catch((error: Error) => {
          next(error)
        })
      }).catch((error: Error) => {
        next(error)
      })
    } else {
      res.sendStatus(401)
    }
  }
}


/* ===== FILE: ./routes/basket.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type Request, type Response, type NextFunction } from 'express'
import { ProductModel } from '../models/product'
import { BasketModel } from '../models/basket'
import * as challengeUtils from '../lib/challengeUtils'

import * as utils from '../lib/utils'
import * as security from '../lib/insecurity'
import { challenges } from '../data/datacache'

export function retrieveBasket () {
  return (req: Request, res: Response, next: NextFunction) => {
    const id = req.params.id
    BasketModel.findOne({ where: { id }, include: [{ model: ProductModel, paranoid: false, as: 'Products' }] })
      .then((basket: BasketModel | null) => {
        /* jshint eqeqeq:false */
        challengeUtils.solveIf(challenges.basketAccessChallenge, () => {
          const user = security.authenticatedUsers.from(req)
          return user && id && id !== 'undefined' && id !== 'null' && id !== 'NaN' && user.bid && user?.bid != parseInt(id, 10) // eslint-disable-line eqeqeq
        })
        if (((basket?.Products) != null) && basket.Products.length > 0) {
          for (let i = 0; i < basket.Products.length; i++) {
            basket.Products[i].name = req.__(basket.Products[i].name)
          }
        }

        res.json(utils.queryResultToJson(basket))
      }).catch((error: Error) => {
        next(error)
      })
  }
}


/* ===== FILE: ./routes/appConfiguration.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import config from 'config'
import { type Request, type Response } from 'express'

export function retrieveAppConfiguration () {
  return (_req: Request, res: Response) => {
    res.json({ config })
  }
}


/* ===== FILE: ./routes/logfileServer.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import path from 'node:path'
import { type Request, type Response, type NextFunction } from 'express'

export function serveLogFiles () {
  return ({ params }: Request, res: Response, next: NextFunction) => {
    const file = params.file

    if (!file.includes('/')) {
      res.sendFile(path.resolve('logs/', file))
    } else {
      res.status(403)
      next(new Error('File names cannot contain forward slashes!'))
    }
  }
}


/* ===== FILE: ./routes/2fa.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import config from 'config'
import { type Request, type Response } from 'express'
import { BasketModel } from '../models/basket'
import { UserModel } from '../models/user'
import * as challengeUtils from '../lib/challengeUtils'
import * as utils from '../lib/utils'
import { challenges } from '../data/datacache'
import * as otplib from 'otplib'
import * as security from '../lib/insecurity'

otplib.authenticator.options = {
  // Accepts tokens as valid even when they are 30sec to old or to new
  // This is a standard as the clocks of the authenticator and server might not align perfectly.
  window: 1
}

export async function verify (req: Request, res: Response) {
  const { tmpToken, totpToken } = req.body

  try {
    const { userId, type } = security.verify(tmpToken) && security.decode(tmpToken)

    if (type !== 'password_valid_needs_second_factor_token') {
      throw new Error('Invalid token type')
    }

    const user = await UserModel.findByPk(userId)
    if (user == null) {
      throw new Error('No such user found!')
    }

    const isValid = otplib.authenticator.check(totpToken, user.totpSecret)

    const plainUser = utils.queryResultToJson(user)

    if (!isValid) {
      return res.status(401).send()
    }
    challengeUtils.solveIf(challenges.twoFactorAuthUnsafeSecretStorageChallenge, () => { return user.email === 'wurstbrot@' + config.get<string>('application.domain') })

    const [basket] = await BasketModel.findOrCreate({ where: { UserId: userId } })

    const token = security.authorize(plainUser)
    // @ts-expect-error FIXME set new property for original basket
    plainUser.bid = basket.id // keep track of original basket for challenge solution check
    security.authenticatedUsers.put(token, plainUser)

    res.json({ authentication: { token, bid: basket.id, umail: user.email } })
  } catch (error) {
    res.status(401).send()
  }
}

/**
 * Check the 2FA status of the currently signed-in user.
 *
 * When 2FA is not set up, the result will include data required to start the setup.
 */
export async function status (req: Request, res: Response) {
  try {
    const data = security.authenticatedUsers.from(req)
    if (!data) {
      throw new Error('You need to be logged in to see this')
    }
    const { data: user } = data

    if (user.totpSecret === '') {
      const secret = otplib.authenticator.generateSecret()

      res.json({
        setup: false,
        secret,
        email: user.email,
        setupToken: security.authorize({
          secret,
          type: 'totp_setup_secret'
        })
      })
    } else {
      res.json({
        setup: true
      })
    }
  } catch (error) {
    res.status(401).send()
  }
}

/**
 * Sets Up 2FA for a User
 * Requires 3 params:
 * 1. The Users Password as a confirmation.
 * 2. A Setup token. This is returned by the status endpoint.
 *    This contains a signed TOTP secret to ensure that the secret
 *    was generated by the server and wasn't tampered with by the client
 * 3. The first TOTP Token, generated by the TOTP App. (e.g. Google Authenticator)
 */
export async function setup (req: Request, res: Response) {
  try {
    const data = security.authenticatedUsers.from(req)
    if (!data) {
      throw new Error('Need to login before setting up 2FA')
    }
    const { data: user } = data

    const { password, setupToken, initialToken } = req.body

    if (user.password !== security.hash(password)) {
      throw new Error('Password doesnt match stored password')
    }

    if (user.totpSecret !== '') {
      throw new Error('User has 2fa already setup')
    }

    const { secret, type } = security.verify(setupToken) && security.decode(setupToken)
    if (type !== 'totp_setup_secret') {
      throw new Error('SetupToken is of wrong type')
    }
    if (!otplib.authenticator.check(initialToken, secret)) {
      throw new Error('Initial token doesnt match the secret from the setupToken')
    }

    // Update db model and cached object
    const userModel = await UserModel.findByPk(user.id)
    if (userModel == null) {
      throw new Error('No such user found!')
    }

    userModel.totpSecret = secret
    await userModel.save()
    security.authenticatedUsers.updateFrom(req, utils.queryResultToJson(userModel))

    res.status(200).send()
  } catch (error) {
    res.status(401).send()
  }
}

/**
 * Disables 2fa for the current user
 */
export async function disable (req: Request, res: Response) {
  try {
    const data = security.authenticatedUsers.from(req)
    if (!data) {
      throw new Error('Need to login before setting up 2FA')
    }
    const { data: user } = data

    const { password } = req.body

    if (user.password !== security.hash(password)) {
      throw new Error('Password doesnt match stored password')
    }

    // Update db model and cached object
    const userModel = await UserModel.findByPk(user.id)
    if (userModel == null) {
      throw new Error('No such user found!')
    }

    userModel.totpSecret = ''
    await userModel.save()
    security.authenticatedUsers.updateFrom(req, utils.queryResultToJson(userModel))

    res.status(200).send()
  } catch (error) {
    res.status(401).send()
  }
}


/* ===== FILE: ./routes/keyServer.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import path from 'node:path'
import { type Request, type Response, type NextFunction } from 'express'

export function serveKeyFiles () {
  return ({ params }: Request, res: Response, next: NextFunction) => {
    const file = params.file

    if (!file.includes('/')) {
      res.sendFile(path.resolve('encryptionkeys/', file))
    } else {
      res.status(403)
      next(new Error('File names cannot contain forward slashes!'))
    }
  }
}


/* ===== FILE: ./routes/web3Wallet.ts ===== */

import { type Request, type Response } from 'express'
import { WebSocketProvider, Contract } from 'ethers'

import * as utils from '../lib/utils'
import { challenges } from '../data/datacache'
import * as challengeUtils from '../lib/challengeUtils'
import { web3WalletABI } from '../data/static/contractABIs'

const web3WalletAddress = '0x413744D59d31AFDC2889aeE602636177805Bd7b0'
const walletsConnected = new Set()
let isEventListenerCreated = false

export function contractExploitListener () {
  return async (req: Request, res: Response) => {
    const metamaskAddress = req.body.walletAddress
    walletsConnected.add(metamaskAddress)
    try {
      const provider = new WebSocketProvider('wss://eth-sepolia.g.alchemy.com/v2/FZDapFZSs1l6yhHW4VnQqsi18qSd-3GJ')
      const contract = new Contract(web3WalletAddress, web3WalletABI, provider)
      if (!isEventListenerCreated) {
        void contract.on('ContractExploited', (exploiter: string) => {
          if (walletsConnected.has(exploiter)) {
            walletsConnected.delete(exploiter)
            challengeUtils.solveIf(challenges.web3WalletChallenge, () => true)
          }
        })
        isEventListenerCreated = true
      }
      res.status(200).json({ success: true, message: 'Event Listener Created' })
    } catch (error) {
      res.status(500).json(utils.getErrorMessage(error))
    }
  }
}


/* ===== FILE: ./routes/captcha.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type Request, type Response, type NextFunction } from 'express'
import { type Captcha } from '../data/types'
import { CaptchaModel } from '../models/captcha'

export function captchas () {
  return async (req: Request, res: Response) => {
    const captchaId = req.app.locals.captchaId++
    const operators = ['*', '+', '-']

    const firstTerm = Math.floor((Math.random() * 10) + 1)
    const secondTerm = Math.floor((Math.random() * 10) + 1)
    const thirdTerm = Math.floor((Math.random() * 10) + 1)

    const firstOperator = operators[Math.floor((Math.random() * 3))]
    const secondOperator = operators[Math.floor((Math.random() * 3))]

    const expression = firstTerm.toString() + firstOperator + secondTerm.toString() + secondOperator + thirdTerm.toString()
    const answer = eval(expression).toString() // eslint-disable-line no-eval

    const captcha = {
      captchaId,
      captcha: expression,
      answer
    }
    const captchaInstance = CaptchaModel.build(captcha)
    await captchaInstance.save()
    res.json(captcha)
  }
}

export const verifyCaptcha = () => (req: Request, res: Response, next: NextFunction) => {
  CaptchaModel.findOne({ where: { captchaId: req.body.captchaId } }).then((captcha: Captcha | null) => {
    if ((captcha != null) && req.body.captcha === captcha.answer) {
      next()
    } else {
      res.status(401).send(res.__('Wrong answer to CAPTCHA. Please try again.'))
    }
  }).catch((error: Error) => {
    next(error)
  })
}


/* ===== FILE: ./routes/vulnCodeFixes.ts ===== */

import fs from 'node:fs'
import yaml from 'js-yaml'
import { type NextFunction, type Request, type Response } from 'express'

import * as accuracy from '../lib/accuracy'
import * as challengeUtils from '../lib/challengeUtils'
import { type ChallengeKey } from 'models/challenge'

const FixesDir = 'data/static/codefixes'

interface codeFix {
  fixes: string[]
  correct: number
}

type cache = Record<string, codeFix>

const CodeFixes: cache = {}

export const readFixes = (key: string) => {
  if (CodeFixes[key]) {
    return CodeFixes[key]
  }
  const files = fs.readdirSync(FixesDir)
  const fixes: string[] = []
  let correct: number = -1
  for (const file of files) {
    if (file.startsWith(`${key}_`)) {
      const fix = fs.readFileSync(`${FixesDir}/${file}`).toString()
      const metadata = file.split('_')
      const number = metadata[1]
      fixes.push(fix)
      if (metadata.length === 3) {
        correct = parseInt(number, 10)
        correct--
      }
    }
  }

  CodeFixes[key] = {
    fixes,
    correct
  }
  return CodeFixes[key]
}

interface FixesRequestParams {
  key: string
}

interface VerdictRequestBody {
  key: ChallengeKey
  selectedFix: number
}

export const serveCodeFixes = () => (req: Request<FixesRequestParams, Record<string, unknown>, Record<string, unknown>>, res: Response, next: NextFunction) => {
  const key = req.params.key
  const fixData = readFixes(key)
  if (fixData.fixes.length === 0) {
    res.status(404).json({
      error: 'No fixes found for the snippet!'
    })
    return
  }
  res.status(200).json({
    fixes: fixData.fixes
  })
}

export const checkCorrectFix = () => async (req: Request<Record<string, unknown>, Record<string, unknown>, VerdictRequestBody>, res: Response, next: NextFunction) => {
  const key = req.body.key
  const selectedFix = req.body.selectedFix
  const fixData = readFixes(key)
  if (fixData.fixes.length === 0) {
    res.status(404).json({
      error: 'No fixes found for the snippet!'
    })
  } else {
    let explanation
    if (fs.existsSync('./data/static/codefixes/' + key + '.info.yml')) {
      const codingChallengeInfos = yaml.load(fs.readFileSync('./data/static/codefixes/' + key + '.info.yml', 'utf8'))
      const selectedFixInfo = codingChallengeInfos?.fixes.find(({ id }: { id: number }) => id === selectedFix + 1)
      if (selectedFixInfo?.explanation) explanation = res.__(selectedFixInfo.explanation)
    }
    if (selectedFix === fixData.correct) {
      await challengeUtils.solveFixIt(key)
      res.status(200).json({
        verdict: true,
        explanation
      })
    } else {
      accuracy.storeFixItVerdict(key, false)
      res.status(200).json({
        verdict: false,
        explanation
      })
    }
  }
}


/* ===== FILE: ./routes/fileUpload.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import os from 'node:os'
import fs from 'node:fs'
import vm from 'node:vm'
import path from 'node:path'
import yaml from 'js-yaml'
import libxml from 'libxmljs2'
import unzipper from 'unzipper'
import { type NextFunction, type Request, type Response } from 'express'

import * as challengeUtils from '../lib/challengeUtils'
import { challenges } from '../data/datacache'
import * as utils from '../lib/utils'

function ensureFileIsPassed ({ file }: Request, res: Response, next: NextFunction) {
  if (file != null) {
    next()
  } else {
    return res.status(400).json({ error: 'File is not passed' })
  }
}

function handleZipFileUpload ({ file }: Request, res: Response, next: NextFunction) {
  if (utils.endsWith(file?.originalname.toLowerCase(), '.zip')) {
    if (((file?.buffer) != null) && utils.isChallengeEnabled(challenges.fileWriteChallenge)) {
      const buffer = file.buffer
      const filename = file.originalname.toLowerCase()
      const tempFile = path.join(os.tmpdir(), filename)
      fs.open(tempFile, 'w', function (err, fd) {
        if (err != null) { next(err) }
        fs.write(fd, buffer, 0, buffer.length, null, function (err) {
          if (err != null) { next(err) }
          fs.close(fd, function () {
            fs.createReadStream(tempFile)
              .pipe(unzipper.Parse())
              .on('entry', function (entry: any) {
                const fileName = entry.path
                const absolutePath = path.resolve('uploads/complaints/' + fileName)
                challengeUtils.solveIf(challenges.fileWriteChallenge, () => { return absolutePath === path.resolve('ftp/legal.md') })
                if (absolutePath.includes(path.resolve('.'))) {
                  entry.pipe(fs.createWriteStream('uploads/complaints/' + fileName).on('error', function (err) { next(err) }))
                } else {
                  entry.autodrain()
                }
              }).on('error', function (err: unknown) { next(err) })
          })
        })
      })
    }
    res.status(204).end()
  } else {
    next()
  }
}

function checkUploadSize ({ file }: Request, res: Response, next: NextFunction) {
  if (file != null) {
    challengeUtils.solveIf(challenges.uploadSizeChallenge, () => { return file?.size > 100000 })
  }
  next()
}

function checkFileType ({ file }: Request, res: Response, next: NextFunction) {
  const fileType = file?.originalname.substr(file.originalname.lastIndexOf('.') + 1).toLowerCase()
  challengeUtils.solveIf(challenges.uploadTypeChallenge, () => {
    return !(fileType === 'pdf' || fileType === 'xml' || fileType === 'zip' || fileType === 'yml' || fileType === 'yaml')
  })
  next()
}

function handleXmlUpload ({ file }: Request, res: Response, next: NextFunction) {
  if (utils.endsWith(file?.originalname.toLowerCase(), '.xml')) {
    challengeUtils.solveIf(challenges.deprecatedInterfaceChallenge, () => { return true })
    if (((file?.buffer) != null) && utils.isChallengeEnabled(challenges.deprecatedInterfaceChallenge)) { // XXE attacks in Docker/Heroku containers regularly cause "segfault" crashes
      const data = file.buffer.toString()
      try {
        const sandbox = { libxml, data }
        vm.createContext(sandbox)
        const xmlDoc = vm.runInContext('libxml.parseXml(data, { noblanks: true, noent: true, nocdata: true })', sandbox, { timeout: 2000 })
        const xmlString = xmlDoc.toString(false)
        challengeUtils.solveIf(challenges.xxeFileDisclosureChallenge, () => { return (utils.matchesEtcPasswdFile(xmlString) || utils.matchesSystemIniFile(xmlString)) })
        res.status(410)
        next(new Error('B2B customer complaints via file upload have been deprecated for security reasons: ' + utils.trunc(xmlString, 400) + ' (' + file.originalname + ')'))
      } catch (err: any) { // TODO: Remove any
        if (utils.contains(err.message, 'Script execution timed out')) {
          if (challengeUtils.notSolved(challenges.xxeDosChallenge)) {
            challengeUtils.solve(challenges.xxeDosChallenge)
          }
          res.status(503)
          next(new Error('Sorry, we are temporarily not available! Please try again later.'))
        } else {
          res.status(410)
          next(new Error('B2B customer complaints via file upload have been deprecated for security reasons: ' + err.message + ' (' + file.originalname + ')'))
        }
      }
    } else {
      res.status(410)
      next(new Error('B2B customer complaints via file upload have been deprecated for security reasons (' + file?.originalname + ')'))
    }
  }
  next()
}

function handleYamlUpload ({ file }: Request, res: Response, next: NextFunction) {
  if (utils.endsWith(file?.originalname.toLowerCase(), '.yml') || utils.endsWith(file?.originalname.toLowerCase(), '.yaml')) {
    challengeUtils.solveIf(challenges.deprecatedInterfaceChallenge, () => { return true })
    if (((file?.buffer) != null) && utils.isChallengeEnabled(challenges.deprecatedInterfaceChallenge)) {
      const data = file.buffer.toString()
      try {
        const sandbox = { yaml, data }
        vm.createContext(sandbox)
        const yamlString = vm.runInContext('JSON.stringify(yaml.load(data))', sandbox, { timeout: 2000 })
        res.status(410)
        next(new Error('B2B customer complaints via file upload have been deprecated for security reasons: ' + utils.trunc(yamlString, 400) + ' (' + file.originalname + ')'))
      } catch (err: any) { // TODO: Remove any
        if (utils.contains(err.message, 'Invalid string length') || utils.contains(err.message, 'Script execution timed out')) {
          if (challengeUtils.notSolved(challenges.yamlBombChallenge)) {
            challengeUtils.solve(challenges.yamlBombChallenge)
          }
          res.status(503)
          next(new Error('Sorry, we are temporarily not available! Please try again later.'))
        } else {
          res.status(410)
          next(new Error('B2B customer complaints via file upload have been deprecated for security reasons: ' + err.message + ' (' + file.originalname + ')'))
        }
      }
    } else {
      res.status(410)
      next(new Error('B2B customer complaints via file upload have been deprecated for security reasons (' + file?.originalname + ')'))
    }
  }
  res.status(204).end()
}

export {
  ensureFileIsPassed,
  handleZipFileUpload,
  checkUploadSize,
  checkFileType,
  handleXmlUpload,
  handleYamlUpload
}


/* ===== FILE: ./routes/basketItems.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type Request, type Response, type NextFunction } from 'express'
import { BasketItemModel } from '../models/basketitem'
import { QuantityModel } from '../models/quantity'
import * as challengeUtils from '../lib/challengeUtils'

import * as utils from '../lib/utils'
import { challenges } from '../data/datacache'
import * as security from '../lib/insecurity'

interface RequestWithRawBody extends Request {
  rawBody: string
}

export function addBasketItem () {
  return (req: Request, res: Response, next: NextFunction) => {
    const result = utils.parseJsonCustom((req as RequestWithRawBody).rawBody)
    const productIds = []
    const basketIds = []
    const quantities = []

    for (let i = 0; i < result.length; i++) {
      if (result[i].key === 'ProductId') {
        productIds.push(result[i].value)
      } else if (result[i].key === 'BasketId') {
        basketIds.push(result[i].value)
      } else if (result[i].key === 'quantity') {
        quantities.push(result[i].value)
      }
    }

    const user = security.authenticatedUsers.from(req)
    if (user && basketIds[0] && basketIds[0] !== 'undefined' && Number(user.bid) != Number(basketIds[0])) { // eslint-disable-line eqeqeq
      res.status(401).send('{\'error\' : \'Invalid BasketId\'}')
    } else {
      const basketItem = {
        ProductId: productIds[productIds.length - 1],
        BasketId: basketIds[basketIds.length - 1],
        quantity: quantities[quantities.length - 1]
      }
      challengeUtils.solveIf(challenges.basketManipulateChallenge, () => { return user && basketItem.BasketId && basketItem.BasketId !== 'undefined' && user.bid != basketItem.BasketId }) // eslint-disable-line eqeqeq

      const basketItemInstance = BasketItemModel.build(basketItem)
      basketItemInstance.save().then((addedBasketItem: BasketItemModel) => {
        res.json({ status: 'success', data: addedBasketItem })
      }).catch((error: Error) => {
        next(error)
      })
    }
  }
}

export function quantityCheckBeforeBasketItemAddition () {
  return (req: Request, res: Response, next: NextFunction) => {
    void quantityCheck(req, res, next, req.body.ProductId, req.body.quantity).catch((error: Error) => {
      next(error)
    })
  }
}

export function quantityCheckBeforeBasketItemUpdate () {
  return (req: Request, res: Response, next: NextFunction) => {
    BasketItemModel.findOne({ where: { id: req.params.id } }).then((item: BasketItemModel | null) => {
      const user = security.authenticatedUsers.from(req)
      challengeUtils.solveIf(challenges.basketManipulateChallenge, () => { return user && req.body.BasketId && user.bid != req.body.BasketId }) // eslint-disable-line eqeqeq
      if (req.body.quantity) {
        if (item == null) {
          throw new Error('No such item found!')
        }
        void quantityCheck(req, res, next, item.ProductId, req.body.quantity)
      } else {
        next()
      }
    }).catch((error: Error) => {
      next(error)
    })
  }
}

async function quantityCheck (req: Request, res: Response, next: NextFunction, id: number, quantity: number) {
  const product = await QuantityModel.findOne({ where: { ProductId: id } })
  if (product == null) {
    throw new Error('No such product found!')
  }

  // is product limited per user and order, except if user is deluxe?
  if (!product.limitPerUser || (product.limitPerUser && product.limitPerUser >= quantity) || security.isDeluxe(req)) {
    if (product.quantity >= quantity) { // enough in stock?
      next()
    } else {
      res.status(400).json({ error: res.__('We are out of stock! Sorry for the inconvenience.') })
    }
  } else {
    res.status(400).json({ error: res.__('You can order only up to {{quantity}} items of this product.', { quantity: product.limitPerUser.toString() }) })
  }
}


/* ===== FILE: ./routes/trackOrder.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import * as utils from '../lib/utils'
import * as challengeUtils from '../lib/challengeUtils'
import { type Request, type Response } from 'express'
import * as db from '../data/mongodb'
import { challenges } from '../data/datacache'

export function trackOrder () {
  return (req: Request, res: Response) => {
    // Truncate id to avoid unintentional RCE
    const id = !utils.isChallengeEnabled(challenges.reflectedXssChallenge) ? String(req.params.id).replace(/[^\w-]+/g, '') : utils.trunc(req.params.id, 60)

    challengeUtils.solveIf(challenges.reflectedXssChallenge, () => { return utils.contains(id, '<iframe src="javascript:alert(`xss`)">') })
    db.ordersCollection.find({ $where: `this.orderId === '${id}'` }).then((order: any) => {
      const result = utils.queryResultToJson(order)
      challengeUtils.solveIf(challenges.noSqlOrdersChallenge, () => { return result.data.length > 1 })
      if (result.data[0] === undefined) {
        result.data[0] = { orderId: id }
      }
      res.json(result)
    }, () => {
      res.status(400).json({ error: 'Wrong Param' })
    })
  }
}


/* ===== FILE: ./routes/privacyPolicyProof.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import path from 'node:path'
import { type Request, type Response } from 'express'
import { challenges } from '../data/datacache'
import * as challengeUtils from '../lib/challengeUtils'

export function servePrivacyPolicyProof () {
  return (req: Request, res: Response) => {
    challengeUtils.solveIf(challenges.privacyPolicyProofChallenge, () => { return true })
    res.sendFile(path.resolve('frontend/dist/frontend/assets/private/thank-you.jpg'))
  }
}


/* ===== FILE: ./routes/createProductReviews.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type Request, type Response } from 'express'

import * as challengeUtils from '../lib/challengeUtils'
import { reviewsCollection } from '../data/mongodb'
import { challenges } from '../data/datacache'
import * as security from '../lib/insecurity'
import * as utils from '../lib/utils'

export function createProductReviews () {
  return async (req: Request, res: Response) => {
    const user = security.authenticatedUsers.from(req)
    challengeUtils.solveIf(
      challenges.forgedReviewChallenge,
      () => user?.data?.email !== req.body.author
    )

    try {
      await reviewsCollection.insert({
        product: req.params.id,
        message: req.body.message,
        author: req.body.author,
        likesCount: 0,
        likedBy: []
      })
      return res.status(201).json({ status: 'success' })
    } catch (err: unknown) {
      return res.status(500).json(utils.getErrorMessage(err))
    }
  }
}


/* ===== FILE: ./routes/currentUser.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import * as challengeUtils from '../lib/challengeUtils'
import { type Request, type Response } from 'express'
import { challenges } from '../data/datacache'
import * as security from '../lib/insecurity'

export function retrieveLoggedInUser () {
  return (req: Request, res: Response) => {
    let user
    try {
      if (security.verify(req.cookies.token)) {
        user = security.authenticatedUsers.get(req.cookies.token)
      }
    } catch (err) {
      user = undefined
    } finally {
      const response = { user: { id: (user?.data ? user.data.id : undefined), email: (user?.data ? user.data.email : undefined), lastLoginIp: (user?.data ? user.data.lastLoginIp : undefined), profileImage: (user?.data ? user.data.profileImage : undefined) } }
      if (req.query.callback === undefined) {
        res.json(response)
      } else {
        challengeUtils.solveIf(challenges.emailLeakChallenge, () => { return true })
        res.jsonp(response)
      }
    }
  }
}


/* ===== FILE: ./routes/deluxe.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type Request, type Response, type NextFunction } from 'express'

import * as challengeUtils from '../lib/challengeUtils'
import { WalletModel } from '../models/wallet'
import { challenges } from '../data/datacache'
import * as security from '../lib/insecurity'
import { UserModel } from '../models/user'
import { CardModel } from '../models/card'
import * as utils from '../lib/utils'

export function upgradeToDeluxe () {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const user = await UserModel.findOne({ where: { id: req.body.UserId, role: security.roles.customer } })
      if (user == null) {
        res.status(400).json({ status: 'error', error: 'Something went wrong. Please try again!' })
        return
      }
      if (req.body.paymentMode === 'wallet') {
        const wallet = await WalletModel.findOne({ where: { UserId: req.body.UserId } })
        if ((wallet != null) && wallet.balance < 49) {
          res.status(400).json({ status: 'error', error: 'Insuffienct funds in Wallet' })
          return
        } else {
          await WalletModel.decrement({ balance: 49 }, { where: { UserId: req.body.UserId } })
        }
      }

      if (req.body.paymentMode === 'card') {
        const card = await CardModel.findOne({ where: { id: req.body.paymentId, UserId: req.body.UserId } })
        if ((card == null) || card.expYear < new Date().getFullYear() || (card.expYear === new Date().getFullYear() && card.expMonth - 1 < new Date().getMonth())) {
          res.status(400).json({ status: 'error', error: 'Invalid Card' })
          return
        }
      }

      try {
        const updatedUser = await user.update({ role: security.roles.deluxe, deluxeToken: security.deluxeToken(user.email) })
        challengeUtils.solveIf(challenges.freeDeluxeChallenge, () => {
          return security.verify(utils.jwtFrom(req)) && req.body.paymentMode !== 'wallet' && req.body.paymentMode !== 'card'
        })
        const userWithStatus = utils.queryResultToJson(updatedUser)
        const updatedToken = security.authorize(userWithStatus)
        security.authenticatedUsers.put(updatedToken, userWithStatus)
        res.status(200).json({ status: 'success', data: { confirmation: 'Congratulations! You are now a deluxe member!', token: updatedToken } })
      } catch (error) {
        res.status(400).json({ status: 'error', error: 'Something went wrong. Please try again!' })
      }
    } catch (err: unknown) {
      res.status(400).json({ status: 'error', error: 'Something went wrong: ' + utils.getErrorMessage(err) })
    }
  }
}

export function deluxeMembershipStatus () {
  return (req: Request, res: Response, next: NextFunction) => {
    if (security.isCustomer(req)) {
      res.status(200).json({ status: 'success', data: { membershipCost: 49 } })
    } else if (security.isDeluxe(req)) {
      res.status(400).json({ status: 'error', error: 'You are already a deluxe member!' })
    } else {
      res.status(400).json({ status: 'error', error: 'You are not eligible for deluxe membership!' })
    }
  }
}


/* ===== FILE: ./routes/order.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import fs from 'node:fs'
import path from 'node:path'
import config from 'config'
import PDFDocument from 'pdfkit'
import { type Request, type Response, type NextFunction } from 'express'

import { challenges, products } from '../data/datacache'
import * as challengeUtils from '../lib/challengeUtils'
import { BasketItemModel } from '../models/basketitem'
import { DeliveryModel } from '../models/delivery'
import { QuantityModel } from '../models/quantity'
import { ProductModel } from '../models/product'
import { BasketModel } from '../models/basket'
import { WalletModel } from '../models/wallet'
import * as security from '../lib/insecurity'
import * as utils from '../lib/utils'
import * as db from '../data/mongodb'

interface Product {
  quantity: number
  id?: number
  name: string
  price: number
  total: number
  bonus: number
}

export function placeOrder () {
  return (req: Request, res: Response, next: NextFunction) => {
    const id = req.params.id
    BasketModel.findOne({ where: { id }, include: [{ model: ProductModel, paranoid: false, as: 'Products' }] })
      .then(async (basket: BasketModel | null) => {
        if (basket != null) {
          const customer = security.authenticatedUsers.from(req)
          const email = customer ? customer.data ? customer.data.email : '' : ''
          const orderId = security.hash(email).slice(0, 4) + '-' + utils.randomHexString(16)
          const pdfFile = `order_${orderId}.pdf`
          const doc = new PDFDocument()
          const date = new Date().toJSON().slice(0, 10)
          const fileWriter = doc.pipe(fs.createWriteStream(path.join('ftp/', pdfFile)))

          fileWriter.on('finish', async () => {
            void basket.update({ coupon: null })
            await BasketItemModel.destroy({ where: { BasketId: id } })
            res.json({ orderConfirmation: orderId })
          })

          doc.font('Times-Roman').fontSize(40).text(config.get<string>('application.name'), { align: 'center' })
          doc.moveTo(70, 115).lineTo(540, 115).stroke()
          doc.moveTo(70, 120).lineTo(540, 120).stroke()
          doc.fontSize(20).moveDown()
          doc.font('Times-Roman').fontSize(20).text(req.__('Order Confirmation'), { align: 'center' })
          doc.fontSize(20).moveDown()
          doc.font('Times-Roman').fontSize(15).text(`${req.__('Customer')}: ${email}`, { align: 'left' })
          doc.font('Times-Roman').fontSize(15).text(`${req.__('Order')} #: ${orderId}`, { align: 'left' })
          doc.moveDown()
          doc.font('Times-Roman').fontSize(15).text(`${req.__('Date')}: ${date}`, { align: 'left' })
          doc.moveDown()
          doc.moveDown()
          let totalPrice = 0
          const basketProducts: Product[] = []
          let totalPoints = 0
          basket.Products?.forEach(({ BasketItem, price, deluxePrice, name, id }) => {
            if (BasketItem != null) {
              challengeUtils.solveIf(challenges.christmasSpecialChallenge, () => { return BasketItem.ProductId === products.christmasSpecial.id })
              QuantityModel.findOne({ where: { ProductId: BasketItem.ProductId } }).then((product: any) => {
                const newQuantity = product.quantity - BasketItem.quantity
                QuantityModel.update({ quantity: newQuantity }, { where: { ProductId: BasketItem?.ProductId } }).catch((error: unknown) => {
                  next(error)
                })
              }).catch((error: unknown) => {
                next(error)
              })
              let itemPrice: number
              if (security.isDeluxe(req)) {
                itemPrice = deluxePrice
              } else {
                itemPrice = price
              }
              const itemTotal = itemPrice * BasketItem.quantity
              const itemBonus = Math.round(itemPrice / 10) * BasketItem.quantity
              const product = {
                quantity: BasketItem.quantity,
                id,
                name: req.__(name),
                price: itemPrice,
                total: itemTotal,
                bonus: itemBonus
              }
              basketProducts.push(product)
              doc.text(`${BasketItem.quantity}x ${req.__(name)} ${req.__('ea.')} ${itemPrice} = ${itemTotal}¤`)
              doc.moveDown()
              totalPrice += itemTotal
              totalPoints += itemBonus
            }
          })
          doc.moveDown()
          const discount = calculateApplicableDiscount(basket, req) ?? 0
          let discountAmount = '0'
          if (discount > 0) {
            discountAmount = (totalPrice * (discount / 100)).toFixed(2)
            doc.text(discount + '% discount from coupon: -' + discountAmount + '¤')
            doc.moveDown()
            totalPrice -= parseFloat(discountAmount)
          }
          const deliveryMethod = {
            deluxePrice: 0,
            price: 0,
            eta: 5
          }
          if (req.body.orderDetails?.deliveryMethodId) {
            const deliveryMethodFromModel = await DeliveryModel.findOne({ where: { id: req.body.orderDetails.deliveryMethodId } })
            if (deliveryMethodFromModel != null) {
              deliveryMethod.deluxePrice = deliveryMethodFromModel.deluxePrice
              deliveryMethod.price = deliveryMethodFromModel.price
              deliveryMethod.eta = deliveryMethodFromModel.eta
            }
          }
          const deliveryAmount = security.isDeluxe(req) ? deliveryMethod.deluxePrice : deliveryMethod.price
          totalPrice += deliveryAmount
          doc.text(`${req.__('Delivery Price')}: ${deliveryAmount.toFixed(2)}¤`)
          doc.moveDown()
          doc.font('Helvetica-Bold').fontSize(20).text(`${req.__('Total Price')}: ${totalPrice.toFixed(2)}¤`)
          doc.moveDown()
          doc.font('Helvetica-Bold').fontSize(15).text(`${req.__('Bonus Points Earned')}: ${totalPoints}`)
          doc.font('Times-Roman').fontSize(15).text(`(${req.__('The bonus points from this order will be added 1:1 to your wallet ¤-fund for future purchases!')}`)
          doc.moveDown()
          doc.moveDown()
          doc.font('Times-Roman').fontSize(15).text(req.__('Thank you for your order!'))

          challengeUtils.solveIf(challenges.negativeOrderChallenge, () => { return totalPrice < 0 })

          if (req.body.UserId) {
            if (req.body.orderDetails && req.body.orderDetails.paymentId === 'wallet') {
              const wallet = await WalletModel.findOne({ where: { UserId: req.body.UserId } })
              if ((wallet != null) && wallet.balance >= totalPrice) {
                WalletModel.decrement({ balance: totalPrice }, { where: { UserId: req.body.UserId } }).catch((error: unknown) => {
                  next(error)
                })
              } else {
                next(new Error('Insufficient wallet balance.'))
              }
            }
            WalletModel.increment({ balance: totalPoints }, { where: { UserId: req.body.UserId } }).catch((error: unknown) => {
              next(error)
            })
          }

          db.ordersCollection.insert({
            promotionalAmount: discountAmount,
            paymentId: req.body.orderDetails ? req.body.orderDetails.paymentId : null,
            addressId: req.body.orderDetails ? req.body.orderDetails.addressId : null,
            orderId,
            delivered: false,
            email: (email ? email.replace(/[aeiou]/gi, '*') : undefined),
            totalPrice,
            products: basketProducts,
            bonus: totalPoints,
            deliveryPrice: deliveryAmount,
            eta: deliveryMethod.eta.toString()
          }).then(() => {
            doc.end()
          })
        } else {
          next(new Error(`Basket with id=${id} does not exist.`))
        }
      }).catch((error: unknown) => {
        next(error)
      })
  }
}

function calculateApplicableDiscount (basket: BasketModel, req: Request) {
  if (security.discountFromCoupon(basket.coupon ?? undefined)) {
    const discount = security.discountFromCoupon(basket.coupon ?? undefined)
    challengeUtils.solveIf(challenges.forgedCouponChallenge, () => { return (discount ?? 0) >= 80 })
    console.log(discount)
    return discount
  } else if (req.body.couponData) {
    const couponData = Buffer.from(req.body.couponData, 'base64').toString().split('-')
    const couponCode = couponData[0]
    const couponDate = Number(couponData[1])
    const campaign = campaigns[couponCode as keyof typeof campaigns]

    if (campaign && couponDate == campaign.validOn) { // eslint-disable-line eqeqeq
      challengeUtils.solveIf(challenges.manipulateClockChallenge, () => { return campaign.validOn < new Date().getTime() })
      return campaign.discount
    }
  }
  return 0
}

const campaigns = {
  WMNSDY2019: { validOn: new Date('Mar 08, 2019 00:00:00 GMT+0100').getTime(), discount: 75 },
  WMNSDY2020: { validOn: new Date('Mar 08, 2020 00:00:00 GMT+0100').getTime(), discount: 60 },
  WMNSDY2021: { validOn: new Date('Mar 08, 2021 00:00:00 GMT+0100').getTime(), discount: 60 },
  WMNSDY2022: { validOn: new Date('Mar 08, 2022 00:00:00 GMT+0100').getTime(), discount: 60 },
  WMNSDY2023: { validOn: new Date('Mar 08, 2023 00:00:00 GMT+0100').getTime(), discount: 60 },
  ORANGE2020: { validOn: new Date('May 04, 2020 00:00:00 GMT+0100').getTime(), discount: 50 },
  ORANGE2021: { validOn: new Date('May 04, 2021 00:00:00 GMT+0100').getTime(), discount: 40 },
  ORANGE2022: { validOn: new Date('May 04, 2022 00:00:00 GMT+0100').getTime(), discount: 40 },
  ORANGE2023: { validOn: new Date('May 04, 2023 00:00:00 GMT+0100').getTime(), discount: 40 }
}


/* ===== FILE: ./routes/profileImageFileUpload.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import fs from 'node:fs/promises'
import { type Request, type Response, type NextFunction } from 'express'
import fileType from 'file-type'

import logger from '../lib/logger'
import * as utils from '../lib/utils'
import { UserModel } from '../models/user'
import * as security from '../lib/insecurity'

export function profileImageFileUpload () {
  return async (req: Request, res: Response, next: NextFunction) => {
    const file = req.file
    const buffer = file?.buffer
    if (buffer === undefined) {
      res.status(500)
      next(new Error('Illegal file type'))
      return
    }
    const uploadedFileType = await fileType.fromBuffer(buffer)
    if (uploadedFileType === undefined) {
      res.status(500)
      next(new Error('Illegal file type'))
      return
    }
    if (uploadedFileType === null || !utils.startsWith(uploadedFileType.mime, 'image')) {
      res.status(415)
      next(new Error(`Profile image upload does not accept this file type${uploadedFileType ? (': ' + uploadedFileType.mime) : '.'}`))
      return
    }
    const loggedInUser = security.authenticatedUsers.get(req.cookies.token)
    if (!loggedInUser) {
      next(new Error('Blocked illegal activity by ' + req.socket.remoteAddress))
      return
    }

    const filePath = `frontend/dist/frontend/assets/public/images/uploads/${loggedInUser.data.id}.${uploadedFileType.ext}`
    try {
      await fs.writeFile(filePath, buffer)
    } catch (err) {
      logger.warn('Error writing file: ' + (err instanceof Error ? err.message : String(err)))
    }

    try {
      const user = await UserModel.findByPk(loggedInUser.data.id)
      if (user != null) {
        await user.update({ profileImage: `assets/public/images/uploads/${loggedInUser.data.id}.${uploadedFileType.ext}` })
      }
    } catch (error) {
      next(error)
    }
    res.location(process.env.BASE_PATH + '/profile')
    res.redirect(process.env.BASE_PATH + '/profile')
  }
}


/* ===== FILE: ./routes/coupon.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type Request, type Response, type NextFunction } from 'express'
import { BasketModel } from '../models/basket'
import * as security from '../lib/insecurity'

export function applyCoupon () {
  return async ({ params }: Request, res: Response, next: NextFunction) => {
    try {
      const id = params.id
      let coupon: string | undefined | null = params.coupon ? decodeURIComponent(params.coupon) : undefined
      const discount = security.discountFromCoupon(coupon)
      coupon = discount ? coupon : null

      const basket = await BasketModel.findByPk(id)
      if (!basket) {
        next(new Error(`Basket with id=${id} does not exist.`))
        return
      }

      await basket.update({ coupon: coupon?.toString() })
      if (discount) {
        return res.json({ discount })
      } else {
        return res.status(404).send('Invalid coupon.')
      }
    } catch (error) {
      next(error)
    }
  }
}


/* ===== FILE: ./routes/fileServer.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import path from 'node:path'
import { type Request, type Response, type NextFunction } from 'express'

import * as utils from '../lib/utils'
import * as security from '../lib/insecurity'
import { challenges } from '../data/datacache'
import * as challengeUtils from '../lib/challengeUtils'

export function servePublicFiles () {
  return ({ params, query }: Request, res: Response, next: NextFunction) => {
    const file = params.file

    if (!file.includes('/')) {
      verify(file, res, next)
    } else {
      res.status(403)
      next(new Error('File names cannot contain forward slashes!'))
    }
  }

  function verify (file: string, res: Response, next: NextFunction) {
    if (file && (endsWithAllowlistedFileType(file) || (file === 'incident-support.kdbx'))) {
      file = security.cutOffPoisonNullByte(file)

      challengeUtils.solveIf(challenges.directoryListingChallenge, () => { return file.toLowerCase() === 'acquisitions.md' })
      verifySuccessfulPoisonNullByteExploit(file)

      res.sendFile(path.resolve('ftp/', file))
    } else {
      res.status(403)
      next(new Error('Only .md and .pdf files are allowed!'))
    }
  }

  function verifySuccessfulPoisonNullByteExploit (file: string) {
    challengeUtils.solveIf(challenges.easterEggLevelOneChallenge, () => { return file.toLowerCase() === 'eastere.gg' })
    challengeUtils.solveIf(challenges.forgottenDevBackupChallenge, () => { return file.toLowerCase() === 'package.json.bak' })
    challengeUtils.solveIf(challenges.forgottenBackupChallenge, () => { return file.toLowerCase() === 'coupons_2013.md.bak' })
    challengeUtils.solveIf(challenges.misplacedSignatureFileChallenge, () => { return file.toLowerCase() === 'suspicious_errors.yml' })

    challengeUtils.solveIf(challenges.nullByteChallenge, () => {
      return challenges.easterEggLevelOneChallenge.solved || challenges.forgottenDevBackupChallenge.solved || challenges.forgottenBackupChallenge.solved ||
        challenges.misplacedSignatureFileChallenge.solved || file.toLowerCase() === 'encrypt.pyc'
    })
  }

  function endsWithAllowlistedFileType (param: string) {
    return utils.endsWith(param, '.md') || utils.endsWith(param, '.pdf')
  }
}


/* ===== FILE: ./routes/checkKeys.ts ===== */

import { type Request, type Response } from 'express'
import { HDNodeWallet } from 'ethers'
import * as challengeUtils from '../lib/challengeUtils'
import * as utils from '../lib/utils'
import { challenges } from '../data/datacache'

export function checkKeys () {
  return (req: Request, res: Response) => {
    try {
      const mnemonic = 'purpose betray marriage blame crunch monitor spin slide donate sport lift clutch'
      const mnemonicWallet = HDNodeWallet.fromPhrase(mnemonic)
      const privateKey = mnemonicWallet.privateKey
      const publicKey = mnemonicWallet.publicKey
      const address = mnemonicWallet.address
      challengeUtils.solveIf(challenges.nftUnlockChallenge, () => {
        return req.body.privateKey === privateKey
      })
      if (req.body.privateKey === privateKey) {
        res.status(200).json({ success: true, message: 'Challenge successfully solved', status: challenges.nftUnlockChallenge })
      } else {
        if (req.body.privateKey === address) {
          res.status(401).json({ success: false, message: 'Looks like you entered the public address of my ethereum wallet!', status: challenges.nftUnlockChallenge })
        } else if (req.body.privateKey === publicKey) {
          res.status(401).json({ success: false, message: 'Looks like you entered the public key of my ethereum wallet!', status: challenges.nftUnlockChallenge })
        } else {
          res.status(401).json({ success: false, message: 'Looks like you entered a non-Ethereum private key to access me.', status: challenges.nftUnlockChallenge })
        }
      }
    } catch (error) {
      res.status(500).json(utils.getErrorMessage(error))
    }
  }
}
export function nftUnlocked () {
  return (req: Request, res: Response) => {
    try {
      res.status(200).json({ status: challenges.nftUnlockChallenge.solved })
    } catch (error) {
      res.status(500).json(utils.getErrorMessage(error))
    }
  }
}


/* ===== FILE: ./routes/authenticatedUsers.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */
import { type Request, type Response, type NextFunction } from 'express'
import { UserModel } from '../models/user'
import { decode } from 'jsonwebtoken'
import * as security from '../lib/insecurity'

async function retrieveUserList (req: Request, res: Response, next: NextFunction) {
  try {
    const users = await UserModel.findAll()

    res.json({
      status: 'success',
      data: users.map((user) => {
        const userToken = security.authenticatedUsers.tokenOf(user)
        let lastLoginTime: number | null = null
        if (userToken) {
          const parsedToken = decode(userToken, { json: true })
          lastLoginTime = parsedToken ? Math.floor(new Date(parsedToken?.iat ?? 0 * 1000).getTime()) : null
        }

        return {
          ...user.dataValues,
          password: user.password?.replace(/./g, '*'),
          totpSecret: user.totpSecret?.replace(/./g, '*'),
          lastLoginTime
        }
      })
    })
  } catch (error) {
    next(error)
  }
}

export default () => retrieveUserList


/* ===== FILE: ./routes/imageCaptcha.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type Request, type Response, type NextFunction } from 'express'
import svgCaptcha from 'svg-captcha'
import { Op } from 'sequelize'

import { ImageCaptchaModel } from '../models/imageCaptcha'
import * as security from '../lib/insecurity'

export function imageCaptchas () {
  return (req: Request, res: Response) => {
    const captcha = svgCaptcha.create({ size: 5, noise: 2, color: true })

    const user = security.authenticatedUsers.from(req)
    if (!user) {
      res.status(401).send(res.__('You need to be logged in to request a CAPTCHA.'))
      return
    }

    const imageCaptcha = {
      image: captcha.data,
      answer: captcha.text,
      UserId: user.data.id
    }
    const imageCaptchaInstance = ImageCaptchaModel.build(imageCaptcha)
    imageCaptchaInstance.save().then(() => {
      res.json(imageCaptcha)
    }).catch(() => {
      res.status(400).send(res.__('Unable to create CAPTCHA. Please try again.'))
    })
  }
}

export const verifyImageCaptcha = () => (req: Request, res: Response, next: NextFunction) => {
  const user = security.authenticatedUsers.from(req)
  const UserId = user ? user.data ? user.data.id : undefined : undefined
  ImageCaptchaModel.findAll({
    limit: 1,
    where: {
      UserId,
      createdAt: {
        [Op.gt]: new Date(Date.now() - 300000)
      }
    },
    order: [['createdAt', 'DESC']]
  }).then(captchas => {
    if (!captchas[0] || req.body.answer === captchas[0].answer) {
      next()
    } else {
      res.status(401).send(res.__('Wrong answer to CAPTCHA. Please try again.'))
    }
  }).catch(() => {
    res.status(401).send(res.__('Something went wrong while submitting CAPTCHA. Please try again.'))
  })
}


/* ===== FILE: ./routes/redirect.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type Request, type Response, type NextFunction } from 'express'

import * as challengeUtils from '../lib/challengeUtils'
import { challenges } from '../data/datacache'
import * as security from '../lib/insecurity'
import * as utils from '../lib/utils'

export function performRedirect () {
  return ({ query }: Request, res: Response, next: NextFunction) => {
    const toUrl: string = query.to as string
    if (security.isRedirectAllowed(toUrl)) {
      challengeUtils.solveIf(challenges.redirectCryptoCurrencyChallenge, () => { return toUrl === 'https://explorer.dash.org/address/Xr556RzuwX6hg5EGpkybbv5RanJoZN17kW' || toUrl === 'https://blockchain.info/address/1AbKfgvw9psQ41NbLi8kufDQTezwG8DRZm' || toUrl === 'https://etherscan.io/address/0x0f933ab9fcaaa782d0279c300d73750e1311eae6' })
      challengeUtils.solveIf(challenges.redirectChallenge, () => { return isUnintendedRedirect(toUrl) })
      res.redirect(toUrl)
    } else {
      res.status(406)
      next(new Error('Unrecognized target URL for redirect: ' + toUrl))
    }
  }
}

function isUnintendedRedirect (toUrl: string) {
  let unintended = true
  for (const allowedUrl of security.redirectAllowlist) {
    unintended = unintended && !utils.startsWith(toUrl, allowedUrl)
  }
  return unintended
}


/* ===== FILE: ./routes/videoHandler.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import fs from 'node:fs'
import pug from 'pug'
import config from 'config'
import { type Request, type Response } from 'express'
import { AllHtmlEntities as Entities } from 'html-entities'

import * as challengeUtils from '../lib/challengeUtils'
import { themes } from '../views/themes/themes'
import { challenges } from '../data/datacache'
import * as utils from '../lib/utils'

const entities = new Entities()

export const getVideo = () => {
  return (req: Request, res: Response) => {
    const path = videoPath()
    const stat = fs.statSync(path)
    const fileSize = stat.size
    const range = req.headers.range
    if (range) {
      const parts = range.replace(/bytes=/, '').split('-')
      const start = parseInt(parts[0], 10)
      const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1
      const chunksize = (end - start) + 1
      const file = fs.createReadStream(path, { start, end })
      const head = {
        'Content-Range': `bytes ${start}-${end}/${fileSize}`,
        'Accept-Ranges': 'bytes',
        'Content-Length': chunksize,
        'Content-Location': '/assets/public/videos/owasp_promo.mp4',
        'Content-Type': 'video/mp4'
      }
      res.writeHead(206, head)
      file.pipe(res)
    } else {
      const head = {
        'Content-Length': fileSize,
        'Content-Type': 'video/mp4'
      }
      res.writeHead(200, head)
      fs.createReadStream(path).pipe(res)
    }
  }
}

export const promotionVideo = () => {
  return (req: Request, res: Response) => {
    fs.readFile('views/promotionVideo.pug', function (err, buf) {
      if (err != null) throw err
      let template = buf.toString()
      const subs = getSubsFromFile()

      challengeUtils.solveIf(challenges.videoXssChallenge, () => { return utils.contains(subs, '</script><script>alert(`xss`)</script>') })

      const themeKey = config.get<string>('application.theme') as keyof typeof themes
      const theme = themes[themeKey] || themes['bluegrey-lightgreen']
      template = template.replace(/_title_/g, entities.encode(config.get<string>('application.name')))
      template = template.replace(/_favicon_/g, favicon())
      template = template.replace(/_bgColor_/g, theme.bgColor)
      template = template.replace(/_textColor_/g, theme.textColor)
      template = template.replace(/_navColor_/g, theme.navColor)
      template = template.replace(/_primLight_/g, theme.primLight)
      template = template.replace(/_primDark_/g, theme.primDark)
      const fn = pug.compile(template)
      let compiledTemplate = fn()
      compiledTemplate = compiledTemplate.replace('<script id="subtitle"></script>', '<script id="subtitle" type="text/vtt" data-label="English" data-lang="en">' + subs + '</script>')
      res.send(compiledTemplate)
    })
  }
  function favicon () {
    return utils.extractFilename(config.get('application.favicon'))
  }
}

function getSubsFromFile () {
  const subtitles = config.get<string>('application.promotion.subtitles') ?? 'owasp_promo.vtt'
  const data = fs.readFileSync('frontend/dist/frontend/assets/public/videos/' + subtitles, 'utf8')
  return data.toString()
}

function videoPath () {
  if (config.get<string>('application.promotion.video') !== null) {
    const video = utils.extractFilename(config.get<string>('application.promotion.video'))
    return 'frontend/dist/frontend/assets/public/videos/' + video
  }
  return 'frontend/dist/frontend/assets/public/videos/owasp_promo.mp4'
}


/* ===== FILE: ./routes/b2bOrder.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import vm from 'node:vm'
import { type Request, type Response, type NextFunction } from 'express'
// @ts-expect-error FIXME due to non-existing type definitions for notevil
import { eval as safeEval } from 'notevil'

import * as challengeUtils from '../lib/challengeUtils'
import { challenges } from '../data/datacache'
import * as security from '../lib/insecurity'
import * as utils from '../lib/utils'

export function b2bOrder () {
  return ({ body }: Request, res: Response, next: NextFunction) => {
    if (utils.isChallengeEnabled(challenges.rceChallenge) || utils.isChallengeEnabled(challenges.rceOccupyChallenge)) {
      const orderLinesData = body.orderLinesData || ''
      try {
        const sandbox = { safeEval, orderLinesData }
        vm.createContext(sandbox)
        vm.runInContext('safeEval(orderLinesData)', sandbox, { timeout: 2000 })
        res.json({ cid: body.cid, orderNo: uniqueOrderNumber(), paymentDue: dateTwoWeeksFromNow() })
      } catch (err) {
        if (utils.getErrorMessage(err).match(/Script execution timed out.*/) != null) {
          challengeUtils.solveIf(challenges.rceOccupyChallenge, () => { return true })
          res.status(503)
          next(new Error('Sorry, we are temporarily not available! Please try again later.'))
        } else {
          challengeUtils.solveIf(challenges.rceChallenge, () => { return utils.getErrorMessage(err) === 'Infinite loop detected - reached max iterations' })
          next(err)
        }
      }
    } else {
      res.json({ cid: body.cid, orderNo: uniqueOrderNumber(), paymentDue: dateTwoWeeksFromNow() })
    }
  }

  function uniqueOrderNumber () {
    return security.hash(`${(new Date()).toString()}_B2B`)
  }

  function dateTwoWeeksFromNow () {
    return new Date(new Date().getTime() + (14 * 24 * 60 * 60 * 1000)).toISOString()
  }
}


/* ===== FILE: ./routes/updateUserProfile.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type Request, type Response, type NextFunction } from 'express'

import * as challengeUtils from '../lib/challengeUtils'
import { challenges } from '../data/datacache'
import * as security from '../lib/insecurity'
import { UserModel } from '../models/user'
import * as utils from '../lib/utils'

export function updateUserProfile () {
  return async (req: Request, res: Response, next: NextFunction) => {
    const loggedInUser = security.authenticatedUsers.get(req.cookies.token)

    if (!loggedInUser) {
      next(new Error('Blocked illegal activity by ' + req.socket.remoteAddress))
      return
    }

    try {
      const user = await UserModel.findByPk(loggedInUser.data.id)
      if (!user) {
        next(new Error('User not found'))
        return
      }

      challengeUtils.solveIf(challenges.csrfChallenge, () => {
        return ((req.headers.origin?.includes('://htmledit.squarefree.com')) ??
          (req.headers.referer?.includes('://htmledit.squarefree.com'))) &&
          req.body.username !== user.username
      })

      const savedUser = await user.update({ username: req.body.username })
      const userWithStatus = utils.queryResultToJson(savedUser)
      const updatedToken = security.authorize(userWithStatus)
      security.authenticatedUsers.put(updatedToken, userWithStatus)
      res.cookie('token', updatedToken)
      res.location(process.env.BASE_PATH + '/profile')
      res.redirect(process.env.BASE_PATH + '/profile')
    } catch (error) {
      next(error)
    }
  }
}


/* ===== FILE: ./routes/memory.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type Request, type Response, type NextFunction } from 'express'
import { MemoryModel } from '../models/memory'
import { UserModel } from '../models/user'

export function addMemory () {
  return async (req: Request, res: Response, next: NextFunction) => {
    const record = {
      caption: req.body.caption,
      imagePath: 'assets/public/images/uploads/' + req.file?.filename,
      UserId: req.body.UserId
    }
    const memory = await MemoryModel.create(record)
    res.status(200).json({ status: 'success', data: memory })
  }
}

export function getMemories () {
  return async (req: Request, res: Response, next: NextFunction) => {
    const memories = await MemoryModel.findAll({ include: [UserModel] })
    res.status(200).json({ status: 'success', data: memories })
  }
}


/* ===== FILE: ./routes/repeatNotification.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import * as challengeUtils from '../lib/challengeUtils'
import { type Request, type Response } from 'express'

export function repeatNotification () {
  return ({ query }: Request, res: Response) => {
    const challengeName: string = decodeURIComponent(query.challenge as string)
    const challenge = challengeUtils.findChallengeByName(challengeName)

    if (challenge?.solved) {
      challengeUtils.sendNotification(challenge, true)
    }

    res.sendStatus(200)
  }
}


/* ===== FILE: ./routes/quarantineServer.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import path from 'node:path'
import { type Request, type Response, type NextFunction } from 'express'

export function serveQuarantineFiles () {
  return ({ params, query }: Request, res: Response, next: NextFunction) => {
    const file = params.file

    if (!file.includes('/')) {
      res.sendFile(path.resolve('ftp/quarantine/', file))
    } else {
      res.status(403)
      next(new Error('File names cannot contain forward slashes!'))
    }
  }
}


/* ===== FILE: ./routes/updateProductReviews.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type Request, type Response, type NextFunction } from 'express'

import * as challengeUtils from '../lib/challengeUtils'
import { challenges } from '../data/datacache'
import * as security from '../lib/insecurity'
import * as db from '../data/mongodb'

// vuln-code-snippet start noSqlReviewsChallenge forgedReviewChallenge
export function updateProductReviews () {
  return (req: Request, res: Response, next: NextFunction) => {
    const user = security.authenticatedUsers.from(req) // vuln-code-snippet vuln-line forgedReviewChallenge
    db.reviewsCollection.update( // vuln-code-snippet neutral-line forgedReviewChallenge
      { _id: req.body.id }, // vuln-code-snippet vuln-line noSqlReviewsChallenge forgedReviewChallenge
      { $set: { message: req.body.message } },
      { multi: true } // vuln-code-snippet vuln-line noSqlReviewsChallenge
    ).then(
      (result: { modified: number, original: Array<{ author: any }> }) => {
        challengeUtils.solveIf(challenges.noSqlReviewsChallenge, () => { return result.modified > 1 }) // vuln-code-snippet hide-line
        challengeUtils.solveIf(challenges.forgedReviewChallenge, () => { return user?.data && result.original[0] && result.original[0].author !== user.data.email && result.modified === 1 }) // vuln-code-snippet hide-line
        res.json(result)
      }, (err: unknown) => {
        res.status(500).json(err)
      })
  }
}
// vuln-code-snippet end noSqlReviewsChallenge forgedReviewChallenge


/* ===== FILE: ./routes/vulnCodeSnippet.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type NextFunction, type Request, type Response } from 'express'
import yaml from 'js-yaml'
import fs from 'node:fs'

import { getCodeChallenges } from '../lib/codingChallenges'
import * as challengeUtils from '../lib/challengeUtils'
import * as accuracy from '../lib/accuracy'
import * as utils from '../lib/utils'
import { type ChallengeKey } from 'models/challenge'

interface SnippetRequestBody {
  challenge: string
}

interface VerdictRequestBody {
  selectedLines: number[]
  key: ChallengeKey
}

const setStatusCode = (error: any) => {
  switch (error.name) {
    case 'BrokenBoundary':
      return 422
    default:
      return 200
  }
}

export const retrieveCodeSnippet = async (challengeKey: string) => {
  const codeChallenges = await getCodeChallenges()
  if (codeChallenges.has(challengeKey)) {
    return codeChallenges.get(challengeKey) ?? null
  }
  return null
}

export const serveCodeSnippet = () => async (req: Request<SnippetRequestBody, Record<string, unknown>, Record<string, unknown>>, res: Response, next: NextFunction) => {
  try {
    const snippetData = await retrieveCodeSnippet(req.params.challenge)
    if (snippetData == null) {
      res.status(404).json({ status: 'error', error: `No code challenge for challenge key: ${req.params.challenge}` })
      return
    }
    res.status(200).json({ snippet: snippetData.snippet })
  } catch (error) {
    const statusCode = setStatusCode(error)
    res.status(statusCode).json({ status: 'error', error: utils.getErrorMessage(error) })
  }
}

export const retrieveChallengesWithCodeSnippet = async () => {
  const codeChallenges = await getCodeChallenges()
  return [...codeChallenges.keys()]
}

export const getVerdict = (vulnLines: number[], neutralLines: number[], selectedLines: number[]) => {
  if (selectedLines === undefined) return false
  if (vulnLines.length > selectedLines.length) return false
  if (!vulnLines.every(e => selectedLines.includes(e))) return false
  const okLines = [...vulnLines, ...neutralLines]
  const notOkLines = selectedLines.filter(x => !okLines.includes(x))
  return notOkLines.length === 0
}

export const checkVulnLines = () => async (req: Request<Record<string, unknown>, Record<string, unknown>, VerdictRequestBody>, res: Response, next: NextFunction) => {
  const key = req.body.key
  let snippetData
  try {
    snippetData = await retrieveCodeSnippet(key)
    if (snippetData == null) {
      res.status(404).json({ status: 'error', error: `No code challenge for challenge key: ${key}` })
      return
    }
  } catch (error) {
    const statusCode = setStatusCode(error)
    res.status(statusCode).json({ status: 'error', error: utils.getErrorMessage(error) })
    return
  }
  const vulnLines: number[] = snippetData.vulnLines
  const neutralLines: number[] = snippetData.neutralLines
  const selectedLines: number[] = req.body.selectedLines
  const verdict = getVerdict(vulnLines, neutralLines, selectedLines)
  let hint
  if (fs.existsSync('./data/static/codefixes/' + key + '.info.yml')) {
    const codingChallengeInfos = yaml.load(fs.readFileSync('./data/static/codefixes/' + key + '.info.yml', 'utf8'))
    if (codingChallengeInfos?.hints) {
      if (accuracy.getFindItAttempts(key) > codingChallengeInfos.hints.length) {
        if (vulnLines.length === 1) {
          hint = res.__('Line {{vulnLine}} is responsible for this vulnerability or security flaw. Select it and submit to proceed.', { vulnLine: vulnLines[0].toString() })
        } else {
          hint = res.__('Lines {{vulnLines}} are responsible for this vulnerability or security flaw. Select them and submit to proceed.', { vulnLines: vulnLines.toString() })
        }
      } else {
        const nextHint = codingChallengeInfos.hints[accuracy.getFindItAttempts(key) - 1] // -1 prevents after first attempt
        if (nextHint) hint = res.__(nextHint)
      }
    }
  }
  if (verdict) {
    await challengeUtils.solveFindIt(key)
    res.status(200).json({
      verdict: true
    })
  } else {
    accuracy.storeFindItVerdict(key, false)
    res.status(200).json({
      verdict: false,
      hint
    })
  }
}


/* ===== FILE: ./routes/angular.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import path from 'node:path'
import { type Request, type Response, type NextFunction } from 'express'

import * as utils from '../lib/utils'

export function serveAngularClient () {
  return ({ url }: Request, res: Response, next: NextFunction) => {
    if (!utils.startsWith(url, '/api') && !utils.startsWith(url, '/rest')) {
      res.sendFile(path.resolve('frontend/dist/frontend/index.html'))
    } else {
      next(new Error('Unexpected path: ' + url))
    }
  }
}


/* ===== FILE: ./routes/userProfile.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type Request, type Response, type NextFunction } from 'express'
import { AllHtmlEntities as Entities } from 'html-entities'
import config from 'config'
import pug from 'pug'
import fs from 'node:fs/promises'

import * as challengeUtils from '../lib/challengeUtils'
import { themes } from '../views/themes/themes'
import { challenges } from '../data/datacache'
import * as security from '../lib/insecurity'
import { UserModel } from '../models/user'
import * as utils from '../lib/utils'

const entities = new Entities()

function favicon () {
  return utils.extractFilename(config.get('application.favicon'))
}

export function getUserProfile () {
  return async (req: Request, res: Response, next: NextFunction) => {
    let template: string
    try {
      template = await fs.readFile('views/userProfile.pug', { encoding: 'utf-8' })
    } catch (err) {
      next(err)
      return
    }

    const loggedInUser = security.authenticatedUsers.get(req.cookies.token)
    if (!loggedInUser) {
      next(new Error('Blocked illegal activity by ' + req.socket.remoteAddress)); return
    }

    let user: UserModel | null
    try {
      user = await UserModel.findByPk(loggedInUser.data.id)
    } catch (error) {
      next(error)
      return
    }

    if (!user) {
      next(new Error('Blocked illegal activity by ' + req.socket.remoteAddress))
      return
    }

    let username = user.username

    if (username?.match(/#{(.*)}/) !== null && utils.isChallengeEnabled(challenges.usernameXssChallenge)) {
      req.app.locals.abused_ssti_bug = true
      const code = username?.substring(2, username.length - 1)
      try {
        if (!code) {
          throw new Error('Username is null')
        }
        username = eval(code) // eslint-disable-line no-eval
      } catch (err) {
        username = '\\' + username
      }
    } else {
      username = '\\' + username
    }

    const themeKey = config.get<string>('application.theme') as keyof typeof themes
    const theme = themes[themeKey] || themes['bluegrey-lightgreen']

    if (username) {
      template = template.replace(/_username_/g, username)
    }
    template = template.replace(/_emailHash_/g, security.hash(user?.email))
    template = template.replace(/_title_/g, entities.encode(config.get<string>('application.name')))
    template = template.replace(/_favicon_/g, favicon())
    template = template.replace(/_bgColor_/g, theme.bgColor)
    template = template.replace(/_textColor_/g, theme.textColor)
    template = template.replace(/_navColor_/g, theme.navColor)
    template = template.replace(/_primLight_/g, theme.primLight)
    template = template.replace(/_primDark_/g, theme.primDark)
    template = template.replace(/_logo_/g, utils.extractFilename(config.get('application.logo')))

    const fn = pug.compile(template)
    const CSP = `img-src 'self' ${user?.profileImage}; script-src 'self' 'unsafe-eval' https://code.getmdl.io http://ajax.googleapis.com`

    challengeUtils.solveIf(challenges.usernameXssChallenge, () => {
      return username && user?.profileImage.match(/;[ ]*script-src(.)*'unsafe-inline'/g) !== null && utils.contains(username, '<script>alert(`xss`)</script>')
    })

    res.set({
      'Content-Security-Policy': CSP
    })

    res.send(fn(user))
  }
}


/* ===== FILE: ./routes/showProductReviews.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type Request, type Response, type NextFunction } from 'express'

import * as challengeUtils from '../lib/challengeUtils'
import { challenges } from '../data/datacache'
import * as security from '../lib/insecurity'
import { type Review } from 'data/types'
import * as db from '../data/mongodb'
import * as utils from '../lib/utils'

// Blocking sleep function as in native MongoDB
// @ts-expect-error FIXME Type safety broken for global object
global.sleep = (time: number) => {
  // Ensure that users don't accidentally dos their servers for too long
  if (time > 2000) {
    time = 2000
  }
  const stop = new Date().getTime()
  while (new Date().getTime() < stop + time) {
    ;
  }
}

export function showProductReviews () {
  return (req: Request, res: Response, next: NextFunction) => {
    // Truncate id to avoid unintentional RCE
    const id = !utils.isChallengeEnabled(challenges.noSqlCommandChallenge) ? Number(req.params.id) : utils.trunc(req.params.id, 40)

    // Measure how long the query takes, to check if there was a nosql dos attack
    const t0 = new Date().getTime()

    db.reviewsCollection.find({ $where: 'this.product == ' + id }).then((reviews: Review[]) => {
      const t1 = new Date().getTime()
      challengeUtils.solveIf(challenges.noSqlCommandChallenge, () => { return (t1 - t0) > 2000 })
      const user = security.authenticatedUsers.from(req)
      for (let i = 0; i < reviews.length; i++) {
        if (user === undefined || reviews[i].likedBy.includes(user.data.email)) {
          reviews[i].liked = true
        }
      }
      res.json(utils.queryResultToJson(reviews))
    }, () => {
      res.status(400).json({ error: 'Wrong Params' })
    })
  }
}


/* ===== FILE: ./routes/countryMapping.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type Request, type Response } from 'express'
import logger from '../lib/logger'
import configModule from 'config'

export function countryMapping (config = configModule) {
  return (req: Request, res: Response) => {
    try {
      const countryMapping = config.get('ctf.countryMapping')
      if (!countryMapping) {
        throw new Error('No country mapping found!')
      } else {
        res.send(countryMapping)
      }
    } catch (err) {
      logger.warn('Country mapping was requested but was not found in the selected config file. Take a look at the fbctf.yml config file to find out how to configure the country mappings required by FBCTF.')
      res.status(500).send()
    }
  }
}


/* ===== FILE: ./routes/metrics.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { retrieveChallengesWithCodeSnippet } from './vulnCodeSnippet'
import { type Request, type Response, type NextFunction } from 'express'
import { ChallengeModel } from '../models/challenge'
import { UserModel } from '../models/user'
import { WalletModel } from '../models/wallet'
import { FeedbackModel } from '../models/feedback'
import { ComplaintModel } from '../models/complaint'
import { Op } from 'sequelize'
import * as challengeUtils from '../lib/challengeUtils'
import logger from '../lib/logger'
import config from 'config'
import * as utils from '../lib/utils'
import { totalCheatScore } from '../lib/antiCheat'
import * as accuracy from '../lib/accuracy'
import { reviewsCollection, ordersCollection } from '../data/mongodb'
import { challenges } from '../data/datacache'
import * as Prometheus from 'prom-client'
import onFinished from 'on-finished'

const register = Prometheus.register

const fileUploadsCountMetric = new Prometheus.Counter({
  name: 'file_uploads_count',
  help: 'Total number of successful file uploads grouped by file type.',
  labelNames: ['file_type']
})

const fileUploadErrorsMetric = new Prometheus.Counter({
  name: 'file_upload_errors',
  help: 'Total number of failed file uploads grouped by file type.',
  labelNames: ['file_type']
})

export function observeRequestMetricsMiddleware () {
  const httpRequestsMetric = new Prometheus.Counter({
    name: 'http_requests_count',
    help: 'Total HTTP request count grouped by status code.',
    labelNames: ['status_code']
  })

  return (req: Request, res: Response, next: NextFunction) => {
    onFinished(res, () => {
      const statusCode = `${Math.floor(res.statusCode / 100)}XX`
      httpRequestsMetric.labels(statusCode).inc()
    })
    next()
  }
}

export function observeFileUploadMetricsMiddleware () {
  return ({ file }: Request, res: Response, next: NextFunction) => {
    onFinished(res, () => {
      if (file != null) {
        res.statusCode < 400 ? fileUploadsCountMetric.labels(file.mimetype).inc() : fileUploadErrorsMetric.labels(file.mimetype).inc()
      }
    })
    next()
  }
}

export function serveMetrics () {
  return async (req: Request, res: Response, next: NextFunction) => {
    challengeUtils.solveIf(challenges.exposedMetricsChallenge, () => {
      const userAgent = req.headers['user-agent'] ?? ''
      const ignoredUserAgents = config.get<string[]>('challenges.metricsIgnoredUserAgents')
      return !ignoredUserAgents.some((ignoredUserAgent) => userAgent.includes(ignoredUserAgent))
    })
    res.set('Content-Type', register.contentType)
    res.end(await register.metrics())
  }
}

export function observeMetrics () {
  const app = config.get<string>('application.customMetricsPrefix')
  Prometheus.collectDefaultMetrics({})
  register.setDefaultLabels({ app })

  const versionMetrics = new Prometheus.Gauge({
    name: `${app}_version_info`,
    help: `Release version of ${config.get<string>('application.name')}.`,
    labelNames: ['version', 'major', 'minor', 'patch']
  })

  const challengeSolvedMetrics = new Prometheus.Gauge({
    name: `${app}_challenges_solved`,
    help: 'Number of solved challenges grouped by difficulty and category.',
    labelNames: ['difficulty', 'category']
  })

  const challengeTotalMetrics = new Prometheus.Gauge({
    name: `${app}_challenges_total`,
    help: 'Total number of challenges grouped by difficulty and category.',
    labelNames: ['difficulty', 'category']
  })

  const codingChallengesProgressMetrics = new Prometheus.Gauge({
    name: `${app}_coding_challenges_progress`,
    help: 'Number of coding challenges grouped by progression phase.',
    labelNames: ['phase']
  })

  const cheatScoreMetrics = new Prometheus.Gauge({
    name: `${app}_cheat_score`,
    help: 'Overall probability that any hacking or coding challenges were solved by cheating.'
  })

  const accuracyMetrics = new Prometheus.Gauge({
    name: `${app}_coding_challenges_accuracy`,
    help: 'Overall accuracy while solving coding challenges grouped by phase.',
    labelNames: ['phase']
  })

  const orderMetrics = new Prometheus.Gauge({
    name: `${app}_orders_placed_total`,
    help: `Number of orders placed in ${config.get<string>('application.name')}.`
  })

  const userMetrics = new Prometheus.Gauge({
    name: `${app}_users_registered`,
    help: 'Number of registered users grouped by customer type.',
    labelNames: ['type']
  })

  const userTotalMetrics = new Prometheus.Gauge({
    name: `${app}_users_registered_total`,
    help: 'Total number of registered users.'
  })

  const walletMetrics = new Prometheus.Gauge({
    name: `${app}_wallet_balance_total`,
    help: 'Total balance of all users\' digital wallets.'
  })

  const interactionsMetrics = new Prometheus.Gauge({
    name: `${app}_user_social_interactions`,
    help: 'Number of social interactions with users grouped by type.',
    labelNames: ['type']
  })

  const updateLoop = () => setInterval(() => {
    try {
      const version = utils.version()
      const { major, minor, patch } = version.match(/(?<major>\d+).(?<minor>\d+).(?<patch>\d+)/).groups
      versionMetrics.set({ version, major, minor, patch }, 1)

      const challengeStatuses = new Map()
      const challengeCount = new Map()

      for (const { difficulty, category, solved } of Object.values<ChallengeModel>(challenges)) {
        const key = `${difficulty}:${category}`

        // Increment by one if solved, when not solved increment by 0. This ensures that even unsolved challenges are set to , instead of not being set at all
        challengeStatuses.set(key, (challengeStatuses.get(key) || 0) + (solved ? 1 : 0))
        challengeCount.set(key, (challengeCount.get(key) || 0) + 1)
      }

      for (const key of challengeStatuses.keys()) {
        const [difficulty, category] = key.split(':', 2)

        challengeSolvedMetrics.set({ difficulty, category }, challengeStatuses.get(key))
        challengeTotalMetrics.set({ difficulty, category }, challengeCount.get(key))
      }

      void retrieveChallengesWithCodeSnippet().then(challenges => {
        ChallengeModel.count({ where: { codingChallengeStatus: { [Op.eq]: 1 } } }).then((count: number) => {
          codingChallengesProgressMetrics.set({ phase: 'find it' }, count)
        }).catch(() => {
          throw new Error('Unable to retrieve and count such challenges. Please try again')
        })

        ChallengeModel.count({ where: { codingChallengeStatus: { [Op.eq]: 2 } } }).then((count: number) => {
          codingChallengesProgressMetrics.set({ phase: 'fix it' }, count)
        }).catch((_: unknown) => {
          throw new Error('Unable to retrieve and count such challenges. Please try again')
        })

        ChallengeModel.count({ where: { codingChallengeStatus: { [Op.ne]: 0 } } }).then((count: number) => {
          codingChallengesProgressMetrics.set({ phase: 'unsolved' }, challenges.length - count)
        }).catch((_: unknown) => {
          throw new Error('Unable to retrieve and count such challenges. Please try again')
        })
      })

      cheatScoreMetrics.set(totalCheatScore())
      accuracyMetrics.set({ phase: 'find it' }, accuracy.totalFindItAccuracy())
      accuracyMetrics.set({ phase: 'fix it' }, accuracy.totalFixItAccuracy())

      ordersCollection.count({}).then((orderCount: number) => {
        if (orderCount) orderMetrics.set(orderCount)
      })

      reviewsCollection.count({}).then((reviewCount: number) => {
        if (reviewCount) interactionsMetrics.set({ type: 'review' }, reviewCount)
      })

      void UserModel.count({ where: { role: { [Op.eq]: 'customer' } } }).then((count: number) => {
        if (count) userMetrics.set({ type: 'standard' }, count)
      })

      void UserModel.count({ where: { role: { [Op.eq]: 'deluxe' } } }).then((count: number) => {
        if (count) userMetrics.set({ type: 'deluxe' }, count)
      })

      void UserModel.count().then((count: number) => {
        if (count) userTotalMetrics.set(count)
      })

      void WalletModel.sum('balance').then((totalBalance: number) => {
        if (totalBalance) walletMetrics.set(totalBalance)
      })

      void FeedbackModel.count().then((count: number) => {
        if (count) interactionsMetrics.set({ type: 'feedback' }, count)
      })

      void ComplaintModel.count().then((count: number) => {
        if (count) interactionsMetrics.set({ type: 'complaint' }, count)
      })
    } catch (e: unknown) {
      logger.warn('Error during metrics update loop: + ' + utils.getErrorMessage(e))
    }
  }, 5000)

  return {
    register,
    updateLoop
  }
}


/* ===== FILE: ./routes/dataExport.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type Request, type Response, type NextFunction } from 'express'

import * as challengeUtils from '../lib/challengeUtils'
import { type ProductModel } from '../models/product'
import { MemoryModel } from '../models/memory'
import { challenges } from '../data/datacache'
import * as security from '../lib/insecurity'
import * as db from '../data/mongodb'

export function dataExport () {
  return async (req: Request, res: Response, next: NextFunction) => {
    const loggedInUser = security.authenticatedUsers.get(req.headers?.authorization?.replace('Bearer ', ''))
    if (loggedInUser?.data?.email && loggedInUser.data.id) {
      const username = loggedInUser.data.username
      const email = loggedInUser.data.email
      const updatedEmail = email.replace(/[aeiou]/gi, '*')
      const userData:
      {
        username?: string
        email: string
        orders: Array<{
          orderId: string
          totalPrice: number
          products: ProductModel[]
          bonus: number
          eta: string
        }>
        reviews: Array<{
          message: string
          author: string
          productId: number
          likesCount: number
          likedBy: string
        }>
        memories: Array<{
          imageUrl: string
          caption: string
        }>
      } =
      {
        username,
        email,
        orders: [],
        reviews: [],
        memories: []
      }

      const memories = await MemoryModel.findAll({ where: { UserId: req.body.UserId } })
      memories.forEach((memory: MemoryModel) => {
        userData.memories.push({
          imageUrl: req.protocol + '://' + req.get('host') + '/' + memory.imagePath,
          caption: memory.caption
        })
      })

      db.ordersCollection.find({ email: updatedEmail }).then((orders: Array<{
        orderId: string
        totalPrice: number
        products: ProductModel[]
        bonus: number
        eta: string
      }>) => {
        if (orders.length > 0) {
          orders.forEach(order => {
            userData.orders.push({
              orderId: order.orderId,
              totalPrice: order.totalPrice,
              products: [...order.products],
              bonus: order.bonus,
              eta: order.eta
            })
          })
        }

        db.reviewsCollection.find({ author: email }).then((reviews: Array<{
          message: string
          author: string
          product: number
          likesCount: number
          likedBy: string
        }>) => {
          if (reviews.length > 0) {
            reviews.forEach(review => {
              userData.reviews.push({
                message: review.message,
                author: review.author,
                productId: review.product,
                likesCount: review.likesCount,
                likedBy: review.likedBy
              })
            })
          }
          const emailHash = security.hash(email).slice(0, 4)
          for (const order of userData.orders) {
            challengeUtils.solveIf(challenges.dataExportChallenge, () => { return order.orderId.split('-')[0] !== emailHash })
          }
          res.status(200).send({ userData: JSON.stringify(userData, null, 2), confirmation: 'Your data export will open in a new Browser window.' })
        },
        () => {
          next(new Error(`Error retrieving reviews for ${updatedEmail}`))
        })
      },
      () => {
        next(new Error(`Error retrieving orders for ${updatedEmail}`))
      })
    } else {
      next(new Error('Blocked illegal activity by ' + req.socket.remoteAddress))
    }
  }
}


/* ===== FILE: ./routes/continueCode.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import Hashids from 'hashids/cjs'
import { type Request, type Response } from 'express'
import { ChallengeModel } from '../models/challenge'
import { challenges } from '../data/datacache'
import { Op } from 'sequelize'

export function continueCode () {
  const hashids = new Hashids('this is my salt', 60, 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890')
  return (req: Request, res: Response) => {
    const ids = []
    for (const challenge of Object.values(challenges)) {
      if (challenge.solved) ids.push(challenge.id)
    }
    const continueCode = ids.length > 0 ? hashids.encode(ids) : undefined
    res.json({ continueCode })
  }
}

export function continueCodeFindIt () {
  const hashids = new Hashids('this is the salt for findIt challenges', 60, 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890')
  return async (req: Request, res: Response) => {
    const ids = []
    const challenges = await ChallengeModel.findAll({ where: { codingChallengeStatus: { [Op.gte]: 1 } } })
    for (const challenge of challenges) {
      ids.push(challenge.id)
    }
    const continueCode = ids.length > 0 ? hashids.encode(ids) : undefined
    res.json({ continueCode })
  }
}

export function continueCodeFixIt () {
  const hashids = new Hashids('yet another salt for the fixIt challenges', 60, 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890')
  return async (req: Request, res: Response) => {
    const ids = []
    const challenges = await ChallengeModel.findAll({ where: { codingChallengeStatus: { [Op.gte]: 2 } } })
    for (const challenge of challenges) {
      ids.push(challenge.id)
    }
    const continueCode = ids.length > 0 ? hashids.encode(ids) : undefined
    res.json({ continueCode })
  }
}


/* ===== FILE: ./routes/delivery.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type Request, type Response, type NextFunction } from 'express'

import { DeliveryModel } from '../models/delivery'
import * as security from '../lib/insecurity'

export function getDeliveryMethods () {
  return async (req: Request, res: Response, next: NextFunction) => {
    const methods = await DeliveryModel.findAll()
    if (methods) {
      const sendMethods = []
      for (const method of methods) {
        sendMethods.push({
          id: method.id,
          name: method.name,
          price: security.isDeluxe(req) ? method.deluxePrice : method.price,
          eta: method.eta,
          icon: method.icon
        })
      }
      res.status(200).json({ status: 'success', data: sendMethods })
    } else {
      res.status(400).json({ status: 'error' })
    }
  }
}

export function getDeliveryMethod () {
  return async (req: Request, res: Response, next: NextFunction) => {
    const method = await DeliveryModel.findOne({ where: { id: req.params.id } })
    if (method != null) {
      const sendMethod = {
        id: method.id,
        name: method.name,
        price: security.isDeluxe(req) ? method.deluxePrice : method.price,
        eta: method.eta,
        icon: method.icon
      }
      res.status(200).json({ status: 'success', data: sendMethod })
    } else {
      res.status(400).json({ status: 'error' })
    }
  }
}


/* ===== FILE: ./routes/restoreProgress.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import Hashids from 'hashids/cjs'
import { type Request, type Response } from 'express'

import * as challengeUtils from '../lib/challengeUtils'
import { challenges } from '../data/datacache'

const hashidsAlphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890'
const hashidRegexp = /^[a-zA-Z0-9]+$/
const invalidContinueCode = 'Invalid continue code.'

export function restoreProgress () {
  return ({ params }: Request, res: Response) => {
    const hashids = new Hashids('this is my salt', 60, hashidsAlphabet)
    const continueCode = params.continueCode
    if (!hashidRegexp.test(continueCode)) {
      return res.status(404).send(invalidContinueCode)
    }
    const ids = hashids.decode(continueCode)
    if (challengeUtils.notSolved(challenges.continueCodeChallenge) && ids.includes(999)) {
      challengeUtils.solve(challenges.continueCodeChallenge)
      res.end()
    } else if (ids.length > 0) {
      for (const challenge of Object.values(challenges)) {
        if (ids.includes(challenge.id)) {
          challengeUtils.solve(challenge, true)
        }
      }
      res.json({ data: ids.length + ' solved challenges have been restored.' })
    } else {
      res.status(404).send(invalidContinueCode)
    }
  }
}

export function restoreProgressFindIt () {
  return async ({ params }: Request, res: Response) => {
    const hashids = new Hashids('this is the salt for findIt challenges', 60, hashidsAlphabet)
    const continueCodeFindIt = params.continueCode
    if (!hashidRegexp.test(continueCodeFindIt)) {
      return res.status(404).send(invalidContinueCode)
    }
    const idsFindIt = hashids.decode(continueCodeFindIt)
    if (idsFindIt.length > 0) {
      for (const challenge of Object.values(challenges)) {
        if (idsFindIt.includes(challenge.id)) {
          await challengeUtils.solveFindIt(challenge.key, true)
        }
      }
      res.json({ data: idsFindIt.length + ' solved challenges have been restored.' })
    } else {
      res.status(404).send(invalidContinueCode)
    }
  }
}

export function restoreProgressFixIt () {
  const hashids = new Hashids('yet another salt for the fixIt challenges', 60, hashidsAlphabet)
  return async ({ params }: Request, res: Response) => {
    const continueCodeFixIt = params.continueCode
    if (!hashidRegexp.test(continueCodeFixIt)) {
      return res.status(404).send(invalidContinueCode)
    }
    const idsFixIt = hashids.decode(continueCodeFixIt)
    if (idsFixIt.length > 0) {
      for (const challenge of Object.values(challenges)) {
        if (idsFixIt.includes(challenge.id)) {
          await challengeUtils.solveFixIt(challenge.key, true)
        }
      }
      res.json({ data: idsFixIt.length + ' solved challenges have been restored.' })
    } else {
      res.status(404).send(invalidContinueCode)
    }
  }
}


/* ===== FILE: ./routes/likeProductReviews.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type Request, type Response, type NextFunction } from 'express'

import * as challengeUtils from '../lib/challengeUtils'
import { challenges } from '../data/datacache'
import * as security from '../lib/insecurity'
import { type Review } from '../data/types'
import * as db from '../data/mongodb'

const sleep = async (ms: number) => await new Promise(resolve => setTimeout(resolve, ms))

export function likeProductReviews () {
  return async (req: Request, res: Response, next: NextFunction) => {
    const id = req.body.id
    const user = security.authenticatedUsers.from(req)
    if (!user) {
      return res.status(401).json({ error: 'Unauthorized' })
    }

    try {
      const review = await db.reviewsCollection.findOne({ _id: id })
      if (!review) {
        return res.status(404).json({ error: 'Not found' })
      }

      const likedBy = review.likedBy
      if (likedBy.includes(user.data.email)) {
        return res.status(403).json({ error: 'Not allowed' })
      }

      await db.reviewsCollection.update(
        { _id: id },
        { $inc: { likesCount: 1 } }
      )

      // Artificial wait for timing attack challenge
      await sleep(150)
      try {
        const updatedReview: Review = await db.reviewsCollection.findOne({ _id: id })
        const updatedLikedBy = updatedReview.likedBy
        updatedLikedBy.push(user.data.email)

        const count = updatedLikedBy.filter(email => email === user.data.email).length
        challengeUtils.solveIf(challenges.timingAttackChallenge, () => count > 2)

        const result = await db.reviewsCollection.update(
          { _id: id },
          { $set: { likedBy: updatedLikedBy } }
        )
        res.json(result)
      } catch (err) {
        res.status(500).json(err)
      }
    } catch (err) {
      res.status(400).json({ error: 'Wrong Params' })
    }
  }
}


/* ===== FILE: ./routes/address.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type Request, type Response } from 'express'
import { AddressModel } from '../models/address'

export function getAddress () {
  return async (req: Request, res: Response) => {
    const addresses = await AddressModel.findAll({ where: { UserId: req.body.UserId } })
    res.status(200).json({ status: 'success', data: addresses })
  }
}

export function getAddressById () {
  return async (req: Request, res: Response) => {
    const address = await AddressModel.findOne({ where: { id: req.params.id, UserId: req.body.UserId } })
    if (address != null) {
      res.status(200).json({ status: 'success', data: address })
    } else {
      res.status(400).json({ status: 'error', data: 'Malicious activity detected.' })
    }
  }
}

export function delAddressById () {
  return async (req: Request, res: Response) => {
    const address = await AddressModel.destroy({ where: { id: req.params.id, UserId: req.body.UserId } })
    if (address) {
      res.status(200).json({ status: 'success', data: 'Address deleted successfully.' })
    } else {
      res.status(400).json({ status: 'error', data: 'Malicious activity detected.' })
    }
  }
}


/* ===== FILE: ./routes/orderHistory.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type Request, type Response, type NextFunction } from 'express'

import { ordersCollection } from '../data/mongodb'
import * as security from '../lib/insecurity'

export function orderHistory () {
  return async (req: Request, res: Response, next: NextFunction) => {
    const loggedInUser = security.authenticatedUsers.get(req.headers?.authorization?.replace('Bearer ', ''))
    if (loggedInUser?.data?.email && loggedInUser.data.id) {
      const email = loggedInUser.data.email
      const updatedEmail = email.replace(/[aeiou]/gi, '*')
      const order = await ordersCollection.find({ email: updatedEmail })
      res.status(200).json({ status: 'success', data: order })
    } else {
      next(new Error('Blocked illegal activity by ' + req.socket.remoteAddress))
    }
  }
}

export function allOrders () {
  return async (req: Request, res: Response, next: NextFunction) => {
    const order = await ordersCollection.find()
    res.status(200).json({ status: 'success', data: order.reverse() })
  }
}

export function toggleDeliveryStatus () {
  return async (req: Request, res: Response, next: NextFunction) => {
    const deliveryStatus = !req.body.deliveryStatus
    const eta = deliveryStatus ? '0' : '1'
    await ordersCollection.update({ _id: req.params.id }, { $set: { delivered: deliveryStatus, eta } })
    res.status(200).json({ status: 'success' })
  }
}


/* ===== FILE: ./routes/recycles.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import { type Request, type Response } from 'express'
import { RecycleModel } from '../models/recycle'

import * as utils from '../lib/utils'

export const getRecycleItem = () => (req: Request, res: Response) => {
  RecycleModel.findAll({
    where: {
      id: JSON.parse(req.params.id)
    }
  }).then((Recycle) => {
    return res.send(utils.queryResultToJson(Recycle))
  }).catch((_: unknown) => {
    return res.send('Error fetching recycled items. Please try again')
  })
}

export const blockRecycleItems = () => (req: Request, res: Response) => {
  const errMsg = { err: 'Sorry, this endpoint is not supported.' }
  return res.send(utils.queryResultToJson(errMsg))
}


/* ===== FILE: ./routes/appVersion.ts ===== */

/*
 * Copyright (c) 2014-2025 Bjoern Kimminich & the OWASP Juice Shop contributors.
 * SPDX-License-Identifier: MIT
 */

import config from 'config'
import { type Request, type Response } from 'express'

import * as utils from '../lib/utils'

export function retrieveAppVersion () {
  return (_req: Request, res: Response) => {
    res.json({
      version: config.get('application.showVersionNumber') ? utils.version() : ''
    })
  }
}


/* ===== FILE: ./cypress.config.ts ===== */

import { defineConfig } from 'cypress'
import * as security from './lib/insecurity'
import config from 'config'
import type { Memory as MemoryConfig, Product as ProductConfig } from './lib/config.types'
import * as utils from './lib/utils'
import * as otplib from 'otplib'

export default defineConfig({
  projectId: '3hrkhu',
  defaultCommandTimeout: 10000,
  retries: {
    runMode: 2
  },
  e2e: {
    baseUrl: 'http://localhost:3000',
    specPattern: 'test/cypress/e2e/**.spec.ts',
    downloadsFolder: 'test/cypress/downloads',
    fixturesFolder: false,
    supportFile: 'test/cypress/support/e2e.ts',
    setupNodeEvents (on: any) {
      on('task', {
        GenerateCoupon (discount: number) {
          return security.generateCoupon(discount)
        },
        GetBlueprint () {
          for (const product of config.get<ProductConfig[]>('products')) {
            if (product.fileForRetrieveBlueprintChallenge) {
              const blueprint = product.fileForRetrieveBlueprintChallenge
              return blueprint
            }
          }
        },
        GetChristmasProduct () {
          return config.get<ProductConfig[]>('products').filter(
            (product) => product.useForChristmasSpecialChallenge
          )[0]
        },
        GetCouponIntent () {
          const trainingData = require(`data/chatbot/${utils.extractFilename(
            config.get('application.chatBot.trainingData')
          )}`)
          const couponIntent = trainingData.data.filter(
            (data: { intent: string }) => data.intent === 'queries.couponCode'
          )[0]
          return couponIntent
        },
        GetFromMemories (property: string) {
          for (const memory of config.get<MemoryConfig[]>('memories') as any) {
            if (memory[property]) {
              return memory[property]
            }
          }
        },
        GetFromConfig (variable: string) {
          return config.get(variable)
        },
        GetOverwriteUrl () {
          return config.get('challenges.overwriteUrlForProductTamperingChallenge')
        },
        GetPastebinLeakProduct () {
          return config.get<ProductConfig[]>('products').filter(
            (product) => product.keywordsForPastebinDataLeakChallenge
          )[0]
        },
        GetTamperingProductId () {
          const products = config.get<ProductConfig[]>('products')
          for (let i = 0; i < products.length; i++) {
            if (products[i].urlForProductTamperingChallenge) {
              return i + 1
            }
          }
        },
        GenerateAuthenticator (inputString: string) {
          return otplib.authenticator.generate(inputString)
        },
        toISO8601 () {
          const date = new Date()
          return utils.toISO8601(date)
        },
        isDocker () {
          return utils.isDocker()
        },
        isWindows () {
          return utils.isWindows()
        }
      })
    }
  }
})
